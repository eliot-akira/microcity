(function () {
    'use strict';

    (function() {
        const env = {"env":{"NODE_ENV":"development"}};
        try {
            if (process) {
                process.env = Object.assign({}, process.env);
                Object.assign(process.env, env);
                return;
            }
        } catch (e) {} // avoid ReferenceError: process is not defined
        globalThis.process = { env:env };
    })();

    const DIRT = 0;
    const RIVER = 2;
    const REDGE = 3;
    const CHANNEL = 4;
    const FIRSTRIVEDGE = 5;
    const LASTRIVEDGE = 20;
    const WATER_HIGH = LASTRIVEDGE;
    const TREEBASE = 21;
    const WOODS_LOW = TREEBASE;
    const WOODS = 37;
    const UNUSED_TRASH2 = 39;
    const WOODS_HIGH = UNUSED_TRASH2;
    const WOODS2 = 40;
    const WOODS5 = 43;
    const RUBBLE = 44;
    const LASTRUBBLE = 47;
    const FLOOD = 48;
    const LASTFLOOD = 51;
    const RADTILE = 52;
    const FIRE = 56;
    const FIREBASE = FIRE;
    const HBRIDGE = 64;
    const ROADBASE = HBRIDGE;
    const VBRIDGE = 65;
    const ROADS = 66;
    const ROADS2 = 67;
    const ROADS3 = 68;
    const ROADS4 = 69;
    const ROADS5 = 70;
    const ROADS6 = 71;
    const ROADS7 = 72;
    const ROADS8 = 73;
    const ROADS9 = 74;
    const ROADS10 = 75;
    const INTERSECTION = 76;
    const HROADPOWER = 77;
    const VROADPOWER = 78;
    const BRWH = 79;
    const LTRFBASE = 80;
    const BRWV = 95;
    const HTRFBASE = 144;
    const LASTROAD = 206;
    const HPOWER = 208;
    const VPOWER = 209;
    const LHPOWER = 210;
    const LVPOWER = 211;
    const LVPOWER2 = 212;
    const LVPOWER3 = 213;
    const LVPOWER4 = 214;
    const LVPOWER5 = 215;
    const LVPOWER6 = 216;
    const LVPOWER7 = 217;
    const LVPOWER8 = 218;
    const LVPOWER9 = 219;
    const LVPOWER10 = 220;
    const RAILHPOWERV = 221;
    const RAILVPOWERH = 222;
    const POWERBASE = HPOWER;
    const HRAIL = 224;
    const VRAIL = 225;
    const LHRAIL = 226;
    const LVRAIL = 227;
    const LVRAIL2 = 228;
    const LVRAIL3 = 229;
    const LVRAIL4 = 230;
    const LVRAIL5 = 231;
    const LVRAIL6 = 232;
    const LVRAIL7 = 233;
    const LVRAIL8 = 234;
    const LVRAIL9 = 235;
    const LVRAIL10 = 236;
    const HRAILROAD = 237;
    const VRAILROAD = 238;
    const RAILBASE = HRAIL;
    const LASTRAIL = 238;
    const RESBASE = 240;
    const FREEZ = 244;
    const HOUSE = 249;
    const LHTHR = HOUSE;
    const HHTHR = 260;
    const RZB = 265;
    const HOSPITALBASE = 405;
    const HOSPITAL = 409;
    const COMBASE = 423;
    const COMCLR = 427;
    const CZB = 436;
    const INDBASE = 612;
    const INDCLR = 616;
    const LASTIND = 620;
    const IZB = 625;
    const PORTBASE = 693;
    const PORT = 698;
    const LASTPORT = 708;
    const AIRPORTBASE = 709;
    const RADAR = 711;
    const AIRPORT = 716;
    const COALBASE = 745;
    const POWERPLANT = 750;
    const LASTPOWERPLANT = 760;
    const FIRESTBASE = 761;
    const FIRESTATION = 765;
    const POLICESTBASE = 770;
    const POLICESTATION = 774;
    const STADIUMBASE = 779;
    const STADIUM = 784;
    const FULLSTADIUM = 800;
    const NUCLEARBASE = 811;
    const NUCLEAR = 816;
    const LASTZONE = 826;
    const LIGHTNINGBOLT = 827;
    const HBRDG0 = 828;
    const HBRDG1 = 829;
    const HBRDG2 = 830;
    const HBRDG3 = 831;
    const RADAR0 = 832;
    const FOUNTAIN = 840;
    const INDBASE2 = 844;
    const TINYEXP = 860;
    const LASTTINYEXP = 867;
    const COALSMOKE1 = 916;
    const COALSMOKE3 = 924;
    const FOOTBALLGAME1 = 932;
    const FOOTBALLGAME2 = 940;
    const VBRDG0 = 948;
    const VBRDG1 = 949;
    const VBRDG2 = 950;
    const VBRDG3 = 951;
    const CHURCH1BASE = 956;
    const CHURCH7LAST = 1018;
    const TILE_COUNT = 1024;
    const TILE_INVALID = -1;

    var __defProp$$ = Object.defineProperty;
    var __name$$ = (target, value) => __defProp$$(target, "name", { value, configurable: true });
    const TILE_SIZE = 16;
    const TILES_PER_ROW = Math.sqrt(TILE_COUNT);
    class TileSet {
      constructor(image, callback, errorCallback) {
        if (callback === void 0 || errorCallback === void 0) {
          if (callback === void 0 && errorCallback === void 0) {
            throw new Error(
              "Tileset constructor called with no callback or errorCallback"
            );
          } else {
            throw new Error(
              "Tileset constructor called with no " + (callback === void 0 ? "callback" : "errorCallback")
            );
          }
        }
        this.isValid = false;
        image.width;
        image.height;
        const tileWidth = this.tileWidth = TILE_SIZE;
        const c = document.createElement("canvas");
        c.width = tileWidth;
        c.height = tileWidth;
        const cx = c.getContext("2d");
        const tileCount = TILE_COUNT;
        let notifications = 0;
        const self = this;
        const imageLoad = /* @__PURE__ */ __name$$(function() {
          notifications++;
          if (notifications === tileCount) {
            self.isValid = true;
            window.setTimeout(callback, 0);
          }
        }, "imageLoad");
        for (let i = 0; i < tileCount; i++) {
          cx.clearRect(0, 0, tileWidth, tileWidth);
          const sourceX = i % TILES_PER_ROW * tileWidth;
          const sourceY = Math.floor(i / TILES_PER_ROW) * tileWidth;
          cx.drawImage(
            image,
            sourceX,
            sourceY,
            tileWidth,
            tileWidth,
            0,
            0,
            tileWidth,
            tileWidth
          );
          this[i] = new Image();
          this[i].onload = imageLoad;
          this[i].src = c.toDataURL();
        }
      }
    }
    __name$$(TileSet, "TileSet");

    var __defProp$_ = Object.defineProperty;
    var __name$_ = (target, value) => __defProp$_(target, "name", { value, configurable: true });
    const clamp = /* @__PURE__ */ __name$_(function(value, min, max) {
      if (value < min)
        return min;
      if (value > max)
        return max;
      return value;
    }, "clamp");
    const makeConstantDescriptor = /* @__PURE__ */ __name$_(function(value) {
      return {
        configurable: false,
        enumerable: false,
        writeable: false,
        value
      };
    }, "makeConstantDescriptor");
    const normaliseDOMid = /* @__PURE__ */ __name$_(function(id) {
      return (id[0] !== "#" ? "#" : "") + id;
    }, "normaliseDOMid");
    const reflectEvent = /* @__PURE__ */ __name$_(function(message, value) {
      this._emitEvent(message, value);
    }, "reflectEvent");
    function getChance(chance, rng = getRandom16) {
      return (rng() & chance) === 0;
    }
    __name$_(getChance, "getChance");
    function getERandom(max, rng = getRandom) {
      const firstCandidate = rng(max);
      const secondCandidate = rng(max);
      return Math.min(firstCandidate, secondCandidate);
    }
    __name$_(getERandom, "getERandom");
    function getRandom(max, mathGlobal = Math) {
      return mathGlobal.floor(mathGlobal.random() * (max + 1));
    }
    __name$_(getRandom, "getRandom");
    function getRandom16(rng = getRandom) {
      return rng(65535);
    }
    __name$_(getRandom16, "getRandom16");
    function getRandom16Signed(rng = getRandom16) {
      const value = rng();
      if (value < 32768) {
        return value;
      } else {
        return -(2 ** 16) + value;
      }
    }
    __name$_(getRandom16Signed, "getRandom16Signed");
    const MiscUtils = {
      clamp,
      makeConstantDescriptor,
      normaliseDOMid,
      reflectEvent
    };

    var __defProp$Z = Object.defineProperty;
    var __name$Z = (target, value) => __defProp$Z(target, "name", { value, configurable: true });
    class DirectionValue {
      constructor(name) {
        this.name = name;
      }
      oppositeDirection() {
        return this.transform(4);
      }
      rotateClockwise() {
        return this.transform(1);
      }
      rotateCounterClockwise() {
        return this.transform(allDirections.length - 1);
      }
      toString() {
        return this.name;
      }
      transform(delta) {
        const ourIndex = directionIndex(this);
        const desired = ourIndex + delta;
        return allDirections[desired % allDirections.length];
      }
    }
    __name$Z(DirectionValue, "DirectionValue");
    const NORTH = Object.freeze(new DirectionValue("NORTH"));
    const NORTHEAST = Object.freeze(new DirectionValue("NORTHEAST"));
    const EAST = Object.freeze(new DirectionValue("EAST"));
    const SOUTHEAST = Object.freeze(new DirectionValue("SOUTHEAST"));
    const SOUTH = Object.freeze(new DirectionValue("SOUTH"));
    const SOUTHWEST = Object.freeze(new DirectionValue("SOUTHWEST"));
    const WEST$1 = Object.freeze(new DirectionValue("WEST"));
    const NORTHWEST = Object.freeze(new DirectionValue("NORTHWEST"));
    const allDirections = [
      NORTH,
      NORTHEAST,
      EAST,
      SOUTHEAST,
      SOUTH,
      SOUTHWEST,
      WEST$1,
      NORTHWEST
    ];
    function directionIndex(direction) {
      return allDirections.indexOf(direction);
    }
    __name$Z(directionIndex, "directionIndex");
    const cardinalDirections = [
      NORTH,
      EAST,
      SOUTH,
      WEST$1
    ];
    function forEachCardinalDirection(callback) {
      cardinalDirections.forEach((dir) => callback(dir));
    }
    __name$Z(forEachCardinalDirection, "forEachCardinalDirection");
    function getRandomCardinalDirection() {
      return getRandomDirectionFrom(cardinalDirections);
    }
    __name$Z(getRandomCardinalDirection, "getRandomCardinalDirection");
    function getRandomDirection() {
      return getRandomDirectionFrom(allDirections);
    }
    __name$Z(getRandomDirection, "getRandomDirection");
    function getRandomDirectionFrom(directionArray) {
      const maxIndex = directionArray.length - 1;
      const index = getRandom(maxIndex);
      return directionArray[index];
    }
    __name$Z(getRandomDirectionFrom, "getRandomDirectionFrom");

    var __defProp$Y = Object.defineProperty;
    var __name$Y = (target, value) => __defProp$Y(target, "name", { value, configurable: true });
    function assert(assertionPassed, message) {
      if (!assertionPassed) {
        alert(`Assertion failed: ${message}`);
      }
    }
    __name$Y(assert, "assert");

    var __defProp$X = Object.defineProperty;
    var __name$X = (target, value) => __defProp$X(target, "name", { value, configurable: true });
    class DirectionDelta {
      constructor(xDelta, yDelta) {
        this.xDelta = xDelta;
        this.yDelta = yDelta;
      }
    }
    __name$X(DirectionDelta, "DirectionDelta");
    function getDeltaFor(direction) {
      switch (direction) {
        case NORTH:
          return new DirectionDelta(0, -1);
        case NORTHEAST:
          return new DirectionDelta(1, -1);
        case EAST:
          return new DirectionDelta(1, 0);
        case SOUTHEAST:
          return new DirectionDelta(1, 1);
        case SOUTH:
          return new DirectionDelta(0, 1);
        case SOUTHWEST:
          return new DirectionDelta(-1, 1);
        case WEST$1:
          return new DirectionDelta(-1, 0);
        case NORTHWEST:
          return new DirectionDelta(-1, -1);
        default:
          throw new Error(`Unexpected direction!`);
      }
    }
    __name$X(getDeltaFor, "getDeltaFor");
    class Position {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
      static move(position, direction) {
        const { x, y } = position;
        const { xDelta, yDelta } = getDeltaFor(direction);
        return new Position(x + xDelta, y + yDelta);
      }
      static origin() {
        return new Position(0, 0);
      }
      toString() {
        return `(${this.x}, ${this.y})`;
      }
    }
    __name$X(Position, "Position");

    var __defProp$W = Object.defineProperty;
    var __name$W = (target, value) => __defProp$W(target, "name", { value, configurable: true });
    class Bounds {
      constructor(inclusiveStartX, inclusiveStartY, widthCount, heightCount) {
        this.inclusiveStartX = inclusiveStartX;
        this.inclusiveStartY = inclusiveStartY;
        assert(widthCount > 0, "bounded region must have a width");
        assert(heightCount > 0, "bounded region must have a width");
        this.exclusiveEndX = inclusiveStartX + widthCount;
        this.exclusiveEndY = inclusiveStartY + heightCount;
      }
      static fromOrigin(width, height) {
        return new Bounds(0, 0, width, height);
      }
      contains(position) {
        const { x, y } = position;
        return this.xInBounds(x) && this.yInBounds(y);
      }
      toString() {
        const upperCorner = new Position(this.inclusiveStartX, this.inclusiveStartY);
        const lowerCorner = new Position(this.exclusiveEndX - 1, this.exclusiveEndY - 1);
        return `Bounds Rectangle: ${upperCorner} - ${lowerCorner}`;
      }
      xInBounds(x) {
        return x >= this.inclusiveStartX && x < this.exclusiveEndX;
      }
      yInBounds(y) {
        return y >= this.inclusiveStartY && y < this.exclusiveEndY;
      }
    }
    __name$W(Bounds, "Bounds");

    const NOFLAGS = 0;
    const POWERBIT = 32768;
    const CONDBIT = 16384;
    const BURNBIT = 8192;
    const BULLBIT = 4096;
    const ANIMBIT = 2048;
    const ZONEBIT = 1024;
    const BLBNBIT = BULLBIT | BURNBIT;
    const BLBNCNBIT = BULLBIT | BURNBIT | CONDBIT;
    const BNCNBIT = BURNBIT | CONDBIT;
    const ASCBIT = ANIMBIT | CONDBIT | BURNBIT;
    const ALLBITS = POWERBIT | CONDBIT | BURNBIT | BULLBIT | ANIMBIT | ZONEBIT;
    const BIT_START = 1024;
    const BIT_MASK = BIT_START - 1;

    var __defProp$V = Object.defineProperty;
    var __name$V = (target, value) => __defProp$V(target, "name", { value, configurable: true });
    class Tile {
      constructor(value = DIRT, flags = 0) {
        this.validateArguments(value, flags, "Tile constructor");
        this.value = value | flags;
      }
      getValue() {
        return this.valueFromCombinedValue(this.value);
      }
      getFlags() {
        return this.flagsFromCombinedValue(this.value);
      }
      getRawValue() {
        return this.value;
      }
      addFlags(flags) {
        this.validateFlags(flags, "addFlags");
        if (flags === NOFLAGS) {
          return;
        }
        this.value |= flags;
      }
      setValue(desiredValue) {
        if (desiredValue < TILE_INVALID) {
          throw new Error(`setValue called with out-of-range value ${desiredValue}`);
        }
        const value = this.valueFromCombinedValue(desiredValue);
        const bitMask = this.flagsToSetFromCombinedValue(desiredValue);
        this.set(value, bitMask);
      }
      setFlags(flags) {
        this.validateFlags(flags, "setFlags");
        const existingValue = this.value & ~ALLBITS;
        this.value = existingValue | flags;
      }
      removeFlags(flags) {
        this.validateFlags(flags, "removeFlags");
        if (flags === NOFLAGS) {
          return;
        }
        this.value &= ~flags;
      }
      setFrom(tile) {
        if (!tile) {
          console.log("Tile is undefined");
          return;
        }
        this.value = tile.value;
      }
      set(value, flags) {
        this.validateArguments(value, flags, "set");
        this.value = value | flags;
      }
      isAnimated() {
        return this.checkBits(ANIMBIT);
      }
      isBulldozable() {
        return this.checkBits(BULLBIT);
      }
      isConductive() {
        return this.checkBits(CONDBIT);
      }
      isCombustible() {
        return this.checkBits(BURNBIT);
      }
      isPowered() {
        return this.checkBits(POWERBIT);
      }
      isZone() {
        return this.checkBits(ZONEBIT);
      }
      toString() {
        const qualities = [
          "animated",
          "bulldozable",
          "combustible",
          "conductive",
          "powered",
          "zone"
        ];
        const qualitiesText = qualities.map((quality) => this.getQualityText(quality)).join(", ");
        const tileValue = this.getValue();
        return `Tile# ${tileValue}: ${qualitiesText}`;
      }
      getQualityText(quality) {
        const predicate = this.predicateForQuality(quality);
        const qualityValue = this[predicate]();
        return `${quality}: ${this.summariseBoolean(qualityValue)}`;
      }
      predicateForQuality(quality) {
        return `is${quality[0].toUpperCase()}${quality.slice(1)}`;
      }
      summariseBoolean(bool) {
        return bool ? `\u2714` : `\u2718`;
      }
      valueFromCombinedValue(value) {
        return value & BIT_MASK;
      }
      flagsFromCombinedValue(value) {
        return value & ALLBITS;
      }
      flagsToSetFromCombinedValue(value) {
        const embeddedFlags = this.flagsFromCombinedValue(value);
        return embeddedFlags > 0 ? embeddedFlags : this.getFlags();
      }
      checkBits(flag) {
        return (this.value & flag) > 0;
      }
      validateArguments(value, flags, context) {
        this.validateValue(value, context);
        this.validateFlags(flags, context);
      }
      validateValue(value, context) {
        if (this.valueIsInvalid(value)) {
          throw new Error(`${context} called with out-of-range value ${value}`);
        }
      }
      validateFlags(flags, context) {
        if (this.flagsAreInvalid(flags)) {
          throw new Error(`${context} called with out-of-range flags 0x${flags.toString(16)}`);
        }
      }
      valueIsInvalid(value) {
        return value < TILE_INVALID || value >= TILE_COUNT;
      }
      flagsAreInvalid(flags) {
        return flags !== 0 && (flags < BIT_START || (flags & ~ALLBITS) !== 0);
      }
    }
    __name$V(Tile, "Tile");

    var __defProp$U = Object.defineProperty;
    var __name$U = (target, value) => __defProp$U(target, "name", { value, configurable: true });
    function GameMap(width, height, defaultValue) {
      if (arguments.length > 1 && typeof width === "number" && (width < 1 || height < 1)) {
        throw new Error(
          "GameMap constructor called with invalid width or height " + width + " " + height
        );
      }
      const defaultWidth = 120;
      const defaultHeight = 100;
      if (arguments.length === 0) {
        width = defaultWidth;
        height = defaultHeight;
        defaultValue = new Tile().getValue();
      } else if (arguments.length === 1) {
        if (typeof width === "number") {
          defaultValue = width;
        } else {
          defaultValue = width.getValue();
        }
        width = defaultWidth;
        height = defaultHeight;
      } else if (arguments.length === 2) {
        defaultValue = new Tile().getValue();
      } else if (arguments.length === 3) {
        if (typeof defaultValue === "object")
          defaultValue = defaultValue.getValue();
      }
      this.width = width;
      this.height = height;
      this.bounds = Bounds.fromOrigin(width, height);
      const data = [];
      for (let i = 0, l = width * height; i < l; i++) {
        data[i] = new Tile(defaultValue);
      }
      this._data = data;
      this.cityCentreX = Math.floor(this.width / 2);
      this.cityCentreY = Math.floor(this.height / 2);
      this.pollutionMaxX = this.cityCentreX;
      this.pollutionMaxY = this.cityCentreY;
    }
    __name$U(GameMap, "GameMap");
    const saveProps$4 = [
      "cityCentreX",
      "cityCentreY",
      "pollutionMaxX",
      "pollutionMaxY",
      "width",
      "height"
    ];
    GameMap.prototype.save = function(saveData) {
      for (let i = 0, l = saveProps$4.length; i < l; i++) {
        saveData[saveProps$4[i]] = this[saveProps$4[i]];
      }
      saveData.map = this._data.map(function(t) {
        return { value: t.getRawValue() };
      });
    };
    GameMap.prototype.load = function(saveData) {
      for (var i = 0, l = saveProps$4.length; i < l; i++) {
        this[saveProps$4[i]] = saveData[saveProps$4[i]] || this[saveProps$4[i]];
      }
      const map = saveData.map;
      for (i = 0, l = map.length; i < l; i++) {
        this.setTileValue(
          i % this.width,
          Math.floor(i / this.width),
          map[i].value
        );
      }
    };
    GameMap.prototype._calculateIndex = function(x, y) {
      return x + y * this.width;
    };
    GameMap.prototype.isPositionInBounds = function(pos) {
      return this.bounds.contains(pos);
    };
    GameMap.prototype.testBounds = function(x, y) {
      return this.isPositionInBounds(new Position(x, y));
    };
    GameMap.prototype.getTile = function(x, y, newTile) {
      if (typeof x === "object") {
        y = x.y;
        x = x.x;
      }
      const width = this.width;
      const height = this.height;
      if (x < 0 || y < 0 || x >= width || y >= height) {
        console.warn("getTile called with bad bounds", x, y);
        return new Tile(TILE_INVALID);
      }
      const tileIndex = x + y * width;
      const tile = this._data[tileIndex];
      if (!newTile)
        return tile;
      newTile.setFrom(tile);
      return tile;
    };
    GameMap.prototype.getTileValue = function(x, y) {
      if (arguments.length < 1) {
        throw new Error(
          "GameMap getTileValue called with too few arguments" + [].toString.apply(arguments)
        );
      }
      if (typeof x === "object") {
        y = x.y;
        x = x.x;
      }
      if (!this.testBounds(x, y)) {
        throw new Error(
          "GameMap getTileValue called with invalid bounds " + x + ", " + y
        );
      }
      const tileIndex = this._calculateIndex(x, y);
      if (!this._data[tileIndex])
        return;
      return this._data[tileIndex].getValue();
    };
    GameMap.prototype.getTileFlags = function(x, y) {
      if (arguments.length < 1) {
        throw new Error(
          "GameMap getTileFlags called with too few arguments" + [].toString.apply(arguments)
        );
      }
      if (typeof x === "object") {
        y = x.y;
        x = x.x;
      }
      if (!this.testBounds(x, y)) {
        throw new Error(
          "GameMap getTileFlags called with invalid bounds " + x + ", " + y
        );
      }
      const tileIndex = this._calculateIndex(x, y);
      return this._data[tileIndex].getFlags();
    };
    GameMap.prototype.getTiles = function(x, y, w, h) {
      if (arguments.length < 3) {
        throw new Error(
          "GameMap getTiles called with too few arguments" + [].toString.apply(arguments)
        );
      }
      if (arguments.length === 3) {
        h = w;
        w = y;
        y = x.y;
        x = x.x;
      }
      if (!this.testBounds(x, y)) {
        throw new Error(
          "GameMap getTiles called with invalid bounds " + x + ", " + y
        );
      }
      const res = [];
      for (let a = y, ylim = y + h; a < ylim; a++) {
        res[a - y] = [];
        for (let b = x, xlim = x + w; b < xlim; b++) {
          const tileIndex = this._calculateIndex(b, a);
          res[a - y].push(this._data[tileIndex]);
        }
      }
      return res;
    };
    GameMap.prototype.getTileValuesForPainting = function(x, y, w, h, result) {
      result = result || [];
      if (arguments.length < 3) {
        throw new Error(
          "GameMap getTileValuesForPainting called with too few arguments" + [].toString.apply(arguments)
        );
      }
      if (arguments.length === 3) {
        h = w;
        w = y;
        y = x.y;
        x = x.x;
      }
      const width = this.width;
      const height = this.height;
      for (let a = y, ylim = y + h; a < ylim; a++) {
        for (let b = x, xlim = x + w; b < xlim; b++) {
          if (a < 0 || b < 0 || a >= height || b >= width) {
            result[(a - y) * w + (b - x)] = TILE_INVALID;
            continue;
          }
          const tileIndex = b + a * width;
          if (!this._data[tileIndex])
            console.log(tileIndex, width, height, this._data);
          result[(a - y) * w + (b - x)] = this._data[tileIndex].getRawValue();
        }
      }
      return result;
    };
    GameMap.prototype.getTileFromMapOrDefault = function(pos, dir, defaultTile) {
      switch (dir) {
        case NORTH:
          if (pos.y > 0)
            return this.getTileValue(pos.x, pos.y - 1);
          return defaultTile;
        case EAST:
          if (pos.x < this.width - 1)
            return this.getTileValue(pos.x + 1, pos.y);
          return defaultTile;
        case SOUTH:
          if (pos.y < this.height - 1)
            return this.getTileValue(pos.x, pos.y + 1);
          return defaultTile;
        case WEST$1:
          if (pos.x > 0)
            return this.getTileValue(pos.x - 1, pos.y);
          return defaultTile;
        default:
          return defaultTile;
      }
    };
    GameMap.prototype.setTile = function(x, y, value, flags) {
      if (arguments.length < 3) {
        throw new Error(
          "GameMap setTile called with too few arguments" + [].toString.apply(arguments)
        );
      }
      if (arguments.length === 3) {
        flags = value;
        value = y;
        y = x.y;
        x = x.x;
      }
      if (!this.testBounds(x, y)) {
        throw new Error(
          "GameMap setTile called with invalid bounds " + x + ", " + y
        );
      }
      const tileIndex = this._calculateIndex(x, y);
      this._data[tileIndex].set(value, flags);
    };
    GameMap.prototype.setTo = function(x, y, tile) {
      if (arguments.length < 2) {
        throw new Error(
          "GameMap setTo called with too few arguments" + [].toString.apply(arguments)
        );
      }
      if (tile === void 0) {
        tile = y;
        y = x.y;
        x = x.x;
      }
      if (!this.testBounds(x, y)) {
        throw new Error("GameMap setTo called with invalid bounds " + x + ", " + y);
      }
      const tileIndex = this._calculateIndex(x, y);
      this._data[tileIndex] = tile;
    };
    GameMap.prototype.setTileValue = function(x, y, value) {
      if (arguments.length < 2) {
        throw new Error(
          "GameMap setTileValue called with too few arguments" + [].toString.apply(arguments)
        );
      }
      if (arguments.length === 2) {
        value = y;
        y = x.y;
        x = x.x;
      }
      if (!this.testBounds(x, y)) {
        console.log("GameMap setTileValue called with invalid bounds " + x + ", " + y);
        ReadableStreamDefaultController;
      }
      const tileIndex = this._calculateIndex(x, y);
      if (!this._data[tileIndex])
        return;
      this._data[tileIndex].setValue(value);
    };
    GameMap.prototype.setTileFlags = function(x, y, flags) {
      if (arguments.length < 2) {
        throw new Error(
          "GameMap setTileFlags called with too few arguments" + [].toString.apply(arguments)
        );
      }
      if (arguments.length === 2) {
        flags = y;
        y = x.y;
        x = x.x;
      }
      if (!this.testBounds(x, y)) {
        throw new Error(
          "GameMap setTileFlags called with invalid bounds " + x + ", " + y
        );
      }
      const tileIndex = this._calculateIndex(x, y);
      this._data[tileIndex].setFlags(flags);
    };
    GameMap.prototype.addTileFlags = function(x, y, flags) {
      if (arguments.length < 2) {
        throw new Error(
          "GameMap addTileFlags called with too few arguments" + [].toString.apply(arguments)
        );
      }
      if (arguments.length === 2) {
        flags = y;
        y = x.y;
        x = x.x;
      }
      if (!this.testBounds(x, y)) {
        throw new Error(
          "GameMap addTileFlags called with invalid bounds " + x + ", " + y
        );
      }
      const tileIndex = this._calculateIndex(x, y);
      this._data[tileIndex].addFlags(flags);
    };
    GameMap.prototype.removeTileFlags = function(x, y, flags) {
      if (arguments.length < 2) {
        throw new Error(
          "GameMap removeTileFlags called with too few arguments" + [].toString.apply(arguments)
        );
      }
      if (arguments.length === 2) {
        flags = y;
        y = x.y;
        x = x.x;
      }
      if (!this.testBounds(x, y)) {
        throw new Error(
          "GameMap removeTileFlags called with invalid bounds " + x + ", " + y
        );
      }
      const tileIndex = this._calculateIndex(x, y);
      this._data[tileIndex].removeFlags(flags);
    };
    GameMap.prototype.putZone = function(centreX, centreY, centreTile, size) {
      let x, y;
      if (!this.testBounds(centreX, centreY) || !this.testBounds(centreX - 1 + size - 1, centreY - 1 + size - 1)) {
        throw new Error(
          "GameMap putZone called with invalid bounds " + x + ", " + y
        );
      }
      let tile = centreTile - 1 - size;
      const startX = centreX - 1;
      const startY = centreY - 1;
      for (y = startY; y < startY + size; y++) {
        for (x = startX; x < startX + size; x++) {
          if (x === centreX && y === centreY) {
            this.setTo(x, y, new Tile(tile, BNCNBIT | ZONEBIT));
          } else
            this.setTo(x, y, new Tile(tile, BNCNBIT));
          tile += 1;
        }
      }
    };

    var __defProp$T = Object.defineProperty;
    var __name$T = (target, value) => __defProp$T(target, "name", { value, configurable: true });
    let TERRAIN_CREATE_ISLAND;
    const ISLAND_RADIUS = 18;
    const clearMap = /* @__PURE__ */ __name$T(function(map) {
      for (let x = 0; x < map.width; x++) {
        for (let y = 0; y < map.height; y++) {
          map.setTile(x, y, DIRT, 0);
        }
      }
    }, "clearMap");
    var makeNakedIsland = /* @__PURE__ */ __name$T(function(map) {
      const terrainIslandRadius = ISLAND_RADIUS;
      let x, y;
      for (x = 0; x < map.width; x++) {
        for (y = 0; y < map.height; y++) {
          if (x < 5 || x >= map.width - 5 || y < 5 || y >= map.height - 5) {
            map.setTile(x, y, RIVER, 0);
          } else {
            map.setTile(x, y, DIRT, 0);
          }
        }
      }
      for (x = 0; x < map.width - 5; x += 2) {
        let mapY = getERandom(terrainIslandRadius);
        plopBRiver(map, new Position(x, mapY));
        mapY = map.height - 10 - getERandom(terrainIslandRadius);
        plopBRiver(map, new Position(x, mapY));
        plopSRiver(map, new Position(x, 0));
        plopSRiver(map, new Position(x, map.height - 6));
      }
      for (y = 0; y < map.height - 5; y += 2) {
        let mapX = getERandom(terrainIslandRadius);
        plopBRiver(map, new Position(mapX, y));
        mapX = map.width - 10 - getERandom(terrainIslandRadius);
        plopBRiver(map, new Position(mapX, y));
        plopSRiver(map, new Position(0, y));
        plopSRiver(map, new Position(map.width - 6, y));
      }
    }, "makeNakedIsland");
    var makeIsland = /* @__PURE__ */ __name$T(function(map) {
      makeNakedIsland(map);
      smoothRiver(map);
      doTrees(map);
    }, "makeIsland");
    var makeLakes = /* @__PURE__ */ __name$T(function(map) {
      let numLakes;
      numLakes = getRandom(10);
      while (numLakes > 0) {
        const x = getRandom(map.width - 21) + 10;
        const y = getRandom(map.height - 20) + 10;
        makeSingleLake(map, new Position(x, y));
        numLakes--;
      }
    }, "makeLakes");
    var makeSingleLake = /* @__PURE__ */ __name$T(function(map, pos) {
      let numPlops = getRandom(12) + 2;
      while (numPlops > 0) {
        const plopPos = new Position(
          pos,
          getRandom(12) - 6,
          getRandom(12) - 6
        );
        if (getRandom(4))
          plopSRiver(map, plopPos);
        else
          plopBRiver(map, plopPos);
        numPlops--;
      }
    }, "makeSingleLake");
    const treeSplash = /* @__PURE__ */ __name$T(function(map, x, y) {
      let numTrees;
      numTrees = getRandom(150) + 50;
      let treePos = new Position(x, y);
      while (numTrees > 0) {
        const dir = getRandomDirection();
        treePos = Position.move(treePos, dir);
        if (!map.isPositionInBounds(treePos))
          return;
        if (map.getTileValue(treePos) === DIRT)
          map.setTile(treePos, WOODS, BLBNBIT);
        numTrees--;
      }
    }, "treeSplash");
    var doTrees = /* @__PURE__ */ __name$T(function(map) {
      let amount;
      amount = getRandom(100) + 50;
      for (let x = 0; x < amount; x++) {
        const xloc = getRandom(map.width - 1);
        const yloc = getRandom(map.height - 1);
        treeSplash(map, xloc, yloc);
      }
      smoothTrees(map);
      smoothTrees(map);
    }, "doTrees");
    const riverEdges = [
      13 | BULLBIT,
      13 | BULLBIT,
      17 | BULLBIT,
      15 | BULLBIT,
      5 | BULLBIT,
      RIVER,
      19 | BULLBIT,
      17 | BULLBIT,
      9 | BULLBIT,
      11 | BULLBIT,
      RIVER,
      13 | BULLBIT,
      7 | BULLBIT,
      9 | BULLBIT,
      5 | BULLBIT,
      RIVER
    ];
    var smoothRiver = /* @__PURE__ */ __name$T(function(map) {
      const dx = [-1, 0, 1, 0];
      const dy = [0, 1, 0, -1];
      for (let x = 0; x < map.width; x++) {
        for (let y = 0; y < map.height; y++) {
          if (map.getTileValue(x, y) === REDGE) {
            let bitIndex = 0;
            for (let z = 0; z < 4; z++) {
              bitIndex = bitIndex << 1;
              const xTemp = x + dx[z];
              const yTemp = y + dy[z];
              if (map.testBounds(xTemp, yTemp) && map.getTileValue(xTemp, yTemp) !== DIRT && (map.getTileValue(xTemp, yTemp) < WOODS_LOW || map.getTileValue(xTemp, yTemp) > WOODS_HIGH)) {
                bitIndex++;
              }
            }
            let temp = riverEdges[bitIndex & 15];
            if (temp !== RIVER && getRandom(1))
              temp++;
            map.setTileValue(x, y, temp, 0);
          }
        }
      }
    }, "smoothRiver");
    const isTree = /* @__PURE__ */ __name$T(function(tileValue) {
      return tileValue >= WOODS_LOW && tileValue <= WOODS_HIGH;
    }, "isTree");
    var smoothTrees = /* @__PURE__ */ __name$T(function(map) {
      for (let x = 0; x < map.width; x++) {
        for (let y = 0; y < map.height; y++) {
          if (isTree(map.getTileValue(x, y)))
            smoothTreesAt(map, x, y, false);
        }
      }
    }, "smoothTrees");
    const treeTable = [0, 0, 0, 34, 0, 0, 36, 35, 0, 32, 0, 33, 30, 31, 29, 37];
    var smoothTreesAt = /* @__PURE__ */ __name$T(function(map, x, y, preserve) {
      const dx = [-1, 0, 1, 0];
      const dy = [0, 1, 0, -1];
      if (!isTree(map.getTileValue(x, y)))
        return;
      let bitIndex = 0;
      for (let i = 0; i < 4; i++) {
        bitIndex = bitIndex << 1;
        const xTemp = x + dx[i];
        const yTemp = y + dy[i];
        if (map.testBounds(xTemp, yTemp) && isTree(map.getTileValue(xTemp, yTemp))) {
          bitIndex++;
        }
      }
      let temp = treeTable[bitIndex & 15];
      if (temp) {
        if (temp !== WOODS) {
          if (x + y & 1)
            temp = temp - 8;
        }
        map.setTile(x, y, temp, BLBNBIT);
      } else {
        if (!preserve)
          map.setTileValue(x, y, temp, 0);
      }
    }, "smoothTreesAt");
    var doRivers = /* @__PURE__ */ __name$T(function(map, terrainPos) {
      let riverDir = getRandomCardinalDirection();
      doBRiver(map, terrainPos, riverDir, riverDir);
      riverDir = riverDir.oppositeDirection();
      const terrainDir = doBRiver(map, terrainPos, riverDir, riverDir);
      riverDir = getRandomCardinalDirection();
      doSRiver(map, terrainPos, riverDir, terrainDir);
    }, "doRivers");
    var doBRiver = /* @__PURE__ */ __name$T(function(map, pos, riverDir, terrainDir) {
      let rate1, rate2;
      {
        rate1 = 100;
        rate2 = 200;
      }
      while (map.testBounds(pos.x + 4, pos.y + 4)) {
        plopBRiver(map, pos);
        if (getRandom(rate1) < 10) {
          terrainDir = riverDir;
        } else {
          if (getRandom(rate2) > 90) {
            terrainDir = terrainDir.rotateClockwise();
          }
          if (getRandom(rate2) > 90) {
            terrainDir = terrainDir.rotateCounterClockwise();
          }
        }
        pos = Position.move(pos, terrainDir);
      }
      return terrainDir;
    }, "doBRiver");
    var doSRiver = /* @__PURE__ */ __name$T(function(map, pos, riverDir, terrainDir) {
      let rate1, rate2;
      {
        rate1 = 100;
        rate2 = 200;
      }
      while (map.testBounds(pos.x + 3, pos.y + 3)) {
        plopSRiver(map, pos);
        if (getRandom(rate1) < 10) {
          terrainDir = riverDir;
        } else {
          if (getRandom(rate2) > 90) {
            terrainDir = terrainDir.rotateClockwise();
          }
          if (getRandom(rate2) > 90) {
            terrainDir = terrainDir.rotateCounterClockwise();
          }
        }
        pos = Position.move(pos, terrainDir);
      }
      return terrainDir;
    }, "doSRiver");
    const putOnMap = /* @__PURE__ */ __name$T(function(map, newVal, x, y) {
      if (newVal === 0)
        return;
      if (!map.testBounds(x, y))
        return;
      const tileValue = map.getTileValue(x, y);
      if (tileValue !== DIRT) {
        if (tileValue === RIVER) {
          if (newVal !== CHANNEL)
            return;
        }
        if (tileValue === CHANNEL)
          return;
      }
      map.setTile(x, y, newVal, 0);
    }, "putOnMap");
    var plopBRiver = /* @__PURE__ */ __name$T(function(map, pos) {
      const BRMatrix = [
        [0, 0, 0, REDGE, REDGE, REDGE, 0, 0, 0],
        [0, 0, REDGE, RIVER, RIVER, RIVER, REDGE, 0, 0],
        [0, REDGE, RIVER, RIVER, RIVER, RIVER, RIVER, REDGE, 0],
        [REDGE, RIVER, RIVER, RIVER, RIVER, RIVER, RIVER, RIVER, REDGE],
        [REDGE, RIVER, RIVER, RIVER, CHANNEL, RIVER, RIVER, RIVER, REDGE],
        [REDGE, RIVER, RIVER, RIVER, RIVER, RIVER, RIVER, RIVER, REDGE],
        [0, REDGE, RIVER, RIVER, RIVER, RIVER, RIVER, REDGE, 0],
        [0, 0, REDGE, RIVER, RIVER, RIVER, REDGE, 0, 0],
        [0, 0, 0, REDGE, REDGE, REDGE, 0, 0, 0]
      ];
      for (let x = 0; x < 9; x++) {
        for (let y = 0; y < 9; y++) {
          putOnMap(map, BRMatrix[y][x], pos.x + x, pos.y + y);
        }
      }
    }, "plopBRiver");
    var plopSRiver = /* @__PURE__ */ __name$T(function(map, pos) {
      const SRMatrix = [
        [0, 0, REDGE, REDGE, 0, 0],
        [0, REDGE, RIVER, RIVER, REDGE, 0],
        [REDGE, RIVER, RIVER, RIVER, RIVER, REDGE],
        [REDGE, RIVER, RIVER, RIVER, RIVER, REDGE],
        [0, REDGE, RIVER, RIVER, REDGE, 0],
        [0, 0, REDGE, REDGE, 0, 0]
      ];
      for (let x = 0; x < 6; x++) {
        for (let y = 0; y < 6; y++) {
          putOnMap(map, SRMatrix[y][x], pos.x + x, pos.y + y);
        }
      }
    }, "plopSRiver");
    const MapGenerator = /* @__PURE__ */ __name$T(function(w, h) {
      w = w || 120;
      h = h || 100;
      TERRAIN_CREATE_ISLAND = getRandom(2) - 1;
      const map = new GameMap(w, h);
      if (TERRAIN_CREATE_ISLAND < 0) {
        if (getRandom(100) < 10) {
          makeIsland(map);
          return map;
        }
      }
      if (TERRAIN_CREATE_ISLAND === 1)
        makeNakedIsland(map);
      else
        clearMap(map);
      {
        const terrainXStart = 40 + getRandom(map.width - 80);
        const terrainYStart = 33 + getRandom(map.height - 67);
        const terrainPos = new Position(terrainXStart, terrainYStart);
        doRivers(map, terrainPos);
      }
      makeLakes(map);
      smoothRiver(map);
      doTrees(map);
      return map;
    }, "MapGenerator");

    var __defProp$S = Object.defineProperty;
    var __name$S = (target, value) => __defProp$S(target, "name", { value, configurable: true });
    const ID = /* @__PURE__ */ __name$S((n) => n, "ID");
    class BlockMap {
      constructor(gameMapWidth, gameMapHeight, blockSize) {
        this.gameMapWidth = gameMapWidth;
        this.gameMapHeight = gameMapHeight;
        this.blockSize = blockSize;
        this.data = [];
        this._width = this.convertToBlockCount(this.gameMapWidth);
        this._height = this.convertToBlockCount(this.gameMapHeight);
        this.clear();
      }
      get width() {
        return this._width;
      }
      get height() {
        return this._height;
      }
      get(blockX, blockY) {
        const index = this.toIndex(blockX, blockY);
        return this.data[index];
      }
      set(blockX, blockY, value) {
        const index = this.toIndex(blockX, blockY);
        this.data[index] = value;
      }
      worldGet(worldX, worldY) {
        const { x, y } = this.toBlockCoordinate(worldX, worldY);
        return this.get(x, y);
      }
      worldSet(worldX, worldY, value) {
        const { x, y } = this.toBlockCoordinate(worldX, worldY);
        this.set(x, y, value);
      }
      clear() {
        this.forEach((x, y) => this.set(x, y, 0));
      }
      copyFrom(source, transform = ID) {
        if (this.hasIncompatibleDimensions(source)) {
          console.warn("Copying from incompatible blockMap!");
        }
        this.forEach((x, y) => this.set(x, y, transform(source.get(x, y))));
      }
      forEach(fn) {
        const maxWidth = this.width;
        const maxHeight = this.height;
        for (let x = 0; x < maxWidth; x++) {
          for (let y = 0; y < maxHeight; y++) {
            fn(x, y);
          }
        }
      }
      convertToBlockCount(value) {
        return Math.floor((value + this.blockSize - 1) / this.blockSize);
      }
      hasIncompatibleDimensions(map) {
        return map.gameMapHeight !== this.gameMapHeight || map.gameMapWidth !== this.gameMapWidth || map.blockSize !== this.blockSize;
      }
      toBlockCoordinate(worldX, worldY) {
        const x = this.toBlockIndex(worldX);
        const y = this.toBlockIndex(worldY);
        return { x, y };
      }
      toBlockIndex(worldIndex) {
        return Math.floor(worldIndex / this.blockSize);
      }
      toIndex(blockX, blockY) {
        return this.width * blockY + blockX;
      }
    }
    __name$S(BlockMap, "BlockMap");

    var __defProp$R = Object.defineProperty;
    var __name$R = (target, value) => __defProp$R(target, "name", { value, configurable: true });
    const unwrapTile = /* @__PURE__ */ __name$R(function(f) {
      return function(tile) {
        if (tile instanceof Tile)
          tile = tile.getValue();
        return f.call(null, tile);
      };
    }, "unwrapTile");
    const canBulldoze = unwrapTile(function(tileValue) {
      return tileValue >= FIRSTRIVEDGE && tileValue <= LASTRUBBLE || tileValue >= POWERBASE + 2 && tileValue <= POWERBASE + 12 || tileValue >= TINYEXP && tileValue <= LASTTINYEXP + 2;
    });
    const isCommercial = unwrapTile(function(tile) {
      return tile >= COMBASE && tile < INDBASE;
    });
    const isCommercialZone = /* @__PURE__ */ __name$R(function(tile) {
      return tile.isZone() && isCommercial(tile);
    }, "isCommercialZone");
    const isDriveable = unwrapTile(function(tile) {
      return tile >= ROADBASE && tile <= LASTROAD || tile >= RAILHPOWERV && tile <= LASTRAIL;
    });
    const isFire = unwrapTile(function(tile) {
      return tile >= FIREBASE && tile < ROADBASE;
    });
    const isFlood = unwrapTile(function(tile) {
      return tile >= FLOOD && tile < LASTFLOOD;
    });
    const isIndustrial = unwrapTile(function(tile) {
      return tile >= INDBASE && tile < PORTBASE;
    });
    const isIndustrialZone = /* @__PURE__ */ __name$R(function(tile) {
      return tile.isZone() && isIndustrial(tile);
    }, "isIndustrialZone");
    const isManualExplosion = unwrapTile(function(tile) {
      return tile >= TINYEXP && tile <= LASTTINYEXP;
    });
    const isRail = unwrapTile(function(tile) {
      return tile >= RAILBASE && tile < RESBASE;
    });
    const isResidential = unwrapTile(function(tile) {
      return tile >= RESBASE && tile < HOSPITALBASE;
    });
    const isResidentialZone = /* @__PURE__ */ __name$R(function(tile) {
      return tile.isZone() && isResidential(tile);
    }, "isResidentialZone");
    const isRoad = unwrapTile(function(tile) {
      return tile >= ROADBASE && tile < POWERBASE;
    });
    const normalizeRoad = unwrapTile(function(tile) {
      return tile >= ROADBASE && tile <= LASTROAD + 1 ? (tile & 15) + 64 : tile;
    });
    const randomFire = /* @__PURE__ */ __name$R(function() {
      return new Tile(FIRE + (getRandom16() & 3), ANIMBIT);
    }, "randomFire");
    const randomRubble = /* @__PURE__ */ __name$R(function() {
      return new Tile(RUBBLE + (getRandom16() & 3), BULLBIT);
    }, "randomRubble");
    const TileUtils = {
      canBulldoze,
      isCommercial,
      isCommercialZone,
      isDriveable,
      isFire,
      isFlood,
      isIndustrial,
      isIndustrialZone,
      isManualExplosion,
      isRail,
      isResidential,
      isResidentialZone,
      isRoad,
      normalizeRoad,
      randomFire,
      randomRubble
    };

    const SPRITE_TRAIN = 1;
    const SPRITE_HELICOPTER = 2;
    const SPRITE_AIRPLANE = 3;
    const SPRITE_SHIP = 4;
    const SPRITE_MONSTER = 5;
    const SPRITE_TORNADO = 6;
    const SPRITE_EXPLOSION = 7;
    const SpriteConstants = {
      SPRITE_TRAIN,
      SPRITE_HELICOPTER,
      SPRITE_AIRPLANE,
      SPRITE_SHIP,
      SPRITE_MONSTER,
      SPRITE_TORNADO,
      SPRITE_EXPLOSION
    };

    var __defProp$Q = Object.defineProperty;
    var __name$Q = (target, value) => __defProp$Q(target, "name", { value, configurable: true });
    const checkBigZone = /* @__PURE__ */ __name$Q(function(tileValue) {
      let result;
      switch (tileValue) {
        case POWERPLANT:
        case PORT:
        case NUCLEAR:
        case STADIUM:
          result = { zoneSize: 4, deltaX: 0, deltaY: 0 };
          break;
        case POWERPLANT + 1:
        case COALSMOKE3:
        case COALSMOKE3 + 1:
        case COALSMOKE3 + 2:
        case PORT + 1:
        case NUCLEAR + 1:
        case STADIUM + 1:
          result = { zoneSize: 4, deltaX: -1, deltaY: 0 };
          break;
        case POWERPLANT + 4:
        case PORT + 4:
        case NUCLEAR + 4:
        case STADIUM + 4:
          result = { zoneSize: 4, deltaX: 0, deltaY: -1 };
          break;
        case POWERPLANT + 5:
        case PORT + 5:
        case NUCLEAR + 5:
        case STADIUM + 5:
          result = { zoneSize: 4, deltaX: -1, deltaY: -1 };
          break;
        case AIRPORT:
          result = { zoneSize: 6, deltaX: 0, deltaY: 0 };
          break;
        case AIRPORT + 1:
          result = { zoneSize: 6, deltaX: -1, deltaY: 0 };
          break;
        case AIRPORT + 2:
          result = { zoneSize: 6, deltaX: -2, deltaY: 0 };
          break;
        case AIRPORT + 3:
          result = { zoneSize: 6, deltaX: -3, deltaY: 0 };
          break;
        case AIRPORT + 6:
          result = { zoneSize: 6, deltaX: 0, deltaY: -1 };
          break;
        case AIRPORT + 7:
          result = { zoneSize: 6, deltaX: -1, deltaY: -1 };
          break;
        case AIRPORT + 8:
          result = { zoneSize: 6, deltaX: -2, deltaY: -1 };
          break;
        case AIRPORT + 9:
          result = { zoneSize: 6, deltaX: -3, deltaY: -1 };
          break;
        case AIRPORT + 12:
          result = { zoneSize: 6, deltaX: 0, deltaY: -2 };
          break;
        case AIRPORT + 13:
          result = { zoneSize: 6, deltaX: -1, deltaY: -2 };
          break;
        case AIRPORT + 14:
          result = { zoneSize: 6, deltaX: -2, deltaY: -2 };
          break;
        case AIRPORT + 15:
          result = { zoneSize: 6, deltaX: -3, deltaY: -2 };
          break;
        case AIRPORT + 18:
          result = { zoneSize: 6, deltaX: 0, deltaY: -3 };
          break;
        case AIRPORT + 19:
          result = { zoneSize: 6, deltaX: -1, deltaY: -3 };
          break;
        case AIRPORT + 20:
          result = { zoneSize: 6, deltaX: -2, deltaY: -3 };
          break;
        case AIRPORT + 21:
          result = { zoneSize: 6, deltaX: -3, deltaY: -3 };
          break;
        default:
          result = { zoneSize: 0, deltaX: 0, deltaY: 0 };
          break;
      }
      return result;
    }, "checkBigZone");
    const checkZoneSize = /* @__PURE__ */ __name$Q(function(tileValue) {
      if (tileValue >= RESBASE - 1 && tileValue <= PORTBASE - 1 || tileValue >= LASTPOWERPLANT + 1 && tileValue <= POLICESTATION + 4 || tileValue >= CHURCH1BASE && tileValue <= CHURCH7LAST) {
        return 3;
      }
      if (tileValue >= PORTBASE && tileValue <= LASTPORT || tileValue >= COALBASE && tileValue <= LASTPOWERPLANT || tileValue >= STADIUMBASE && tileValue <= LASTZONE) {
        return 4;
      }
      return 0;
    }, "checkZoneSize");
    const fireZone = /* @__PURE__ */ __name$Q(function(map, x, y, blockMaps) {
      const tileValue = map.getTileValue(x, y);
      let zoneSize = 2;
      let value = blockMaps.rateOfGrowthMap.worldGet(x, y);
      value = MiscUtils.clamp(value - 20, -200, 200);
      blockMaps.rateOfGrowthMap.worldSet(x, y, value);
      if (tileValue === AIRPORT)
        zoneSize = 5;
      else if (tileValue >= PORTBASE)
        zoneSize = 3;
      else if (tileValue < PORTBASE)
        zoneSize = 2;
      for (let xDelta = -1; xDelta < zoneSize; xDelta++) {
        for (let yDelta = -1; yDelta < zoneSize; yDelta++) {
          const xTem = x + xDelta;
          const yTem = y + yDelta;
          if (!map.testBounds(xTem, yTem))
            continue;
          if (map.getTileValue(xTem, yTem >= ROADBASE)) {
            map.addTileFlags(xTem, yTem, BULLBIT);
          }
        }
      }
    }, "fireZone");
    const getLandPollutionValue = /* @__PURE__ */ __name$Q(function(blockMaps, x, y) {
      let landValue = blockMaps.landValueMap.worldGet(x, y);
      landValue -= blockMaps.pollutionDensityMap.worldGet(x, y);
      if (landValue < 30)
        return 0;
      if (landValue < 80)
        return 1;
      if (landValue < 150)
        return 2;
      return 3;
    }, "getLandPollutionValue");
    const incRateOfGrowth = /* @__PURE__ */ __name$Q(function(blockMaps, x, y, growthDelta) {
      const currentRate = blockMaps.rateOfGrowthMap.worldGet(x, y);
      const newValue = MiscUtils.clamp(currentRate + growthDelta * 4, -200, 200);
      blockMaps.rateOfGrowthMap.worldSet(x, y, newValue);
    }, "incRateOfGrowth");
    const putZone = /* @__PURE__ */ __name$Q(function(map, x, y, centreTile, isPowered) {
      for (let dY = -1; dY < 2; dY++) {
        for (let dX = -1; dX < 2; dX++) {
          const tileValue = map.getTileValue(x + dX, y + dY);
          if (tileValue >= FLOOD && tileValue < ROADBASE) {
            return;
          }
        }
      }
      map.putZone(x, y, centreTile, 3);
      map.addTileFlags(x, y, BULLBIT);
      if (isPowered)
        map.addTileFlags(x, y, POWERBIT);
    }, "putZone");
    const ZoneUtils = {
      checkBigZone,
      checkZoneSize,
      fireZone,
      getLandPollutionValue,
      incRateOfGrowth,
      putZone
    };

    var __defProp$P = Object.defineProperty;
    var __name$P = (target, value) => __defProp$P(target, "name", { value, configurable: true });
    const pixToWorld = /* @__PURE__ */ __name$P(function(p) {
      return p >> 4;
    }, "pixToWorld");
    const worldToPix = /* @__PURE__ */ __name$P(function(w) {
      return w << 4;
    }, "worldToPix");
    const turnTo = /* @__PURE__ */ __name$P(function(presentDir, desiredDir) {
      if (presentDir === desiredDir)
        return presentDir;
      if (presentDir < desiredDir) {
        if (desiredDir - presentDir < 4)
          presentDir++;
        else
          presentDir--;
      } else {
        if (presentDir - desiredDir < 4)
          presentDir--;
        else
          presentDir++;
      }
      if (presentDir > 8)
        presentDir = 1;
      if (presentDir < 1)
        presentDir = 8;
      return presentDir;
    }, "turnTo");
    const getTileValue = /* @__PURE__ */ __name$P(function(map, x, y) {
      const wX = pixToWorld(x);
      const wY = pixToWorld(y);
      if (wX < 0 || wX >= map.width || wY < 0 || wY >= map.height)
        return -1;
      return map.getTileValue(wX, wY);
    }, "getTileValue");
    const directionTable = [0, 3, 2, 1, 3, 4, 5, 7, 6, 5, 7, 8, 1];
    const getDir = /* @__PURE__ */ __name$P(function(orgX, orgY, destX, destY) {
      let deltaX = destX - orgX;
      let deltaY = destY - orgY;
      let i;
      if (deltaX < 0) {
        if (deltaY < 0) {
          i = 11;
        } else {
          i = 8;
        }
      } else {
        if (deltaY < 0) {
          i = 2;
        } else {
          i = 5;
        }
      }
      deltaX = Math.abs(deltaX);
      deltaY = Math.abs(deltaY);
      if (deltaX * 2 < deltaY)
        i++;
      else if (deltaY * 2 < deltaX)
        i--;
      if (i < 0 || i > 12)
        i = 0;
      return directionTable[i];
    }, "getDir");
    const absoluteDistance = /* @__PURE__ */ __name$P(function(orgX, orgY, destX, destY) {
      const deltaX = destX - orgX;
      const deltaY = destY - orgY;
      return Math.abs(deltaX) + Math.abs(deltaY);
    }, "absoluteDistance");
    const checkWet = /* @__PURE__ */ __name$P(function(tileValue) {
      if (tileValue === HPOWER || tileValue === VPOWER || tileValue === HRAIL || tileValue === VRAIL || tileValue === BRWH || tileValue === BRWV) {
        return true;
      } else
        return false;
    }, "checkWet");
    const destroyMapTile = /* @__PURE__ */ __name$P(function(spriteManager, map, blockMaps, ox, oy) {
      const x = pixToWorld(ox);
      const y = pixToWorld(oy);
      if (!map.testBounds(x, y))
        return;
      const tile = map.getTile(x, y);
      const tileValue = tile.getValue();
      if (tileValue < TREEBASE)
        return;
      if (!tile.isCombustible()) {
        if (tileValue >= ROADBASE && tileValue <= LASTROAD) {
          map.setTile(x, y, RIVER, 0);
        }
        return;
      }
      if (tile.isZone()) {
        ZoneUtils.fireZone(map, x, y, blockMaps);
        if (tileValue > RZB)
          spriteManager.makeExplosionAt(ox, oy);
      }
      if (checkWet(tileValue))
        map.setTile(x, y, RIVER, 0);
      else
        map.setTile(x, y, TINYEXP, BULLBIT | ANIMBIT);
    }, "destroyMapTile");
    const getDistance = /* @__PURE__ */ __name$P(function(x1, y1, x2, y2) {
      return Math.abs(x1 - x2) + Math.abs(y1 - y2);
    }, "getDistance");
    const checkSpriteCollision = /* @__PURE__ */ __name$P(function(s1, s2) {
      return s1.frame !== 0 && s2.frame !== 0 && getDistance(s1.x, s1.y, s2.x, s2.y) < 30;
    }, "checkSpriteCollision");
    const SpriteUtils = {
      absoluteDistance,
      checkSpriteCollision,
      destroyMapTile,
      getDir,
      getTileValue,
      turnTo,
      pixToWorld,
      worldToPix
    };

    var __defProp$O = Object.defineProperty;
    var __name$O = (target, value) => __defProp$O(target, "name", { value, configurable: true });
    function Traffic(map, spriteManager) {
      this._map = map;
      this._stack = [];
      this._spriteManager = spriteManager;
    }
    __name$O(Traffic, "Traffic");
    Traffic.prototype.makeTraffic = function(x, y, blockMaps, destFn) {
      this._stack = [];
      const pos = new Position(x, y);
      if (this.findPerimeterRoad(pos)) {
        const drive = this.tryDrive(pos, destFn);
        if (drive) {
          this.addToTrafficDensityMap(blockMaps);
          return Traffic.ROUTE_FOUND;
        }
        return Traffic.NO_ROUTE_FOUND;
      } else {
        return Traffic.NO_ROAD_FOUND;
      }
    };
    Traffic.prototype.addToTrafficDensityMap = function(blockMaps) {
      const trafficDensityMap = blockMaps.trafficDensityMap;
      while (this._stack.length > 0) {
        const pos = this._stack.pop();
        if (!this._map.testBounds(pos.x, pos.y))
          continue;
        const tileValue = this._map.getTileValue(pos.x, pos.y);
        if (tileValue >= ROADBASE && tileValue < POWERBASE) {
          let traffic = trafficDensityMap.worldGet(pos.x, pos.y);
          traffic += 50;
          traffic = Math.min(traffic, 240);
          trafficDensityMap.worldSet(pos.x, pos.y, traffic);
          if (traffic >= 240 && getRandom(5) === 0) {
            const sprite = this._spriteManager.getSprite(SPRITE_HELICOPTER);
            if (sprite !== null) {
              sprite.destX = SpriteUtils.worldToPix(pos.x);
              sprite.destY = SpriteUtils.worldToPix(pos.y);
            }
          }
        }
      }
    };
    const perimX = [-1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2];
    const perimY = [-2, -2, -2, -1, 0, 1, 2, 2, 2, 1, 0, -1];
    Traffic.prototype.findPerimeterRoad = function(pos) {
      for (let i = 0; i < 12; i++) {
        const xx = pos.x + perimX[i];
        const yy = pos.y + perimY[i];
        if (this._map.testBounds(xx, yy)) {
          if (TileUtils.isDriveable(this._map.getTileValue(xx, yy))) {
            pos.x = xx;
            pos.y = yy;
            return true;
          }
        }
      }
      return false;
    };
    const MAX_TRAFFIC_DISTANCE = 30;
    Traffic.prototype.tryDrive = function(startPos, destFn) {
      let dirLast;
      let drivePos = new Position(startPos.x, startPos.y);
      for (let dist = 0; dist < MAX_TRAFFIC_DISTANCE; dist++) {
        const dir = this.tryGo(drivePos, dirLast);
        if (dir) {
          drivePos = Position.move(drivePos, dir);
          dirLast = dir.oppositeDirection();
          if (dist & 1)
            this._stack.push(new Position(drivePos.x, drivePos.y));
          if (this.driveDone(drivePos, destFn))
            return true;
        } else {
          if (this._stack.length > 0) {
            this._stack.pop();
            dist += 3;
          } else {
            return false;
          }
        }
      }
      return false;
    };
    Traffic.prototype.tryGo = function(pos, dirLast) {
      const directions = [];
      let count = 0;
      forEachCardinalDirection((dir) => {
        if (dir !== dirLast && TileUtils.isDriveable(
          this._map.getTileFromMapOrDefault(pos, dir, DIRT)
        )) {
          directions.push(dir);
          count++;
        }
      });
      if (count === 0) {
        return;
      }
      if (count === 1) {
        return directions[0];
      }
      const index = getRandom(directions.length - 1);
      return directions[index];
    };
    Traffic.prototype.driveDone = function(pos, destFn) {
      if (pos.y > 0) {
        if (destFn(this._map.getTileValue(pos.x, pos.y - 1)))
          return true;
      }
      if (pos.x < this._map.width - 1) {
        if (destFn(this._map.getTileValue(pos.x + 1, pos.y)))
          return true;
      }
      if (pos.y < this._map.height - 1) {
        if (destFn(this._map.getTileValue(pos.x, pos.y + 1)))
          return true;
      }
      if (pos.x > 0) {
        if (destFn(this._map.getTileValue(pos.x - 1, pos.y)))
          return true;
      }
      return false;
    };
    Object.defineProperties(Traffic, {
      ROUTE_FOUND: MiscUtils.makeConstantDescriptor(1),
      NO_ROUTE_FOUND: MiscUtils.makeConstantDescriptor(0),
      NO_ROAD_FOUND: MiscUtils.makeConstantDescriptor(-1)
    });

    var __defProp$N = Object.defineProperty;
    var __name$N = (target, value) => __defProp$N(target, "name", { value, configurable: true });
    const getZonePopulation$2 = /* @__PURE__ */ __name$N(function(map, x, y, tileValue) {
      if (tileValue === COMCLR)
        return 0;
      return Math.floor((tileValue - CZB) / 9) % 5 + 1;
    }, "getZonePopulation");
    const placeCommercial = /* @__PURE__ */ __name$N(function(map, x, y, population, lpValue, zonePower) {
      const centreTile = (lpValue * 5 + population) * 9 + CZB;
      ZoneUtils.putZone(map, x, y, centreTile, zonePower);
    }, "placeCommercial");
    const growZone$2 = /* @__PURE__ */ __name$N(function(map, x, y, blockMaps, population, lpValue, zonePower) {
      let landValue = blockMaps.landValueMap.worldGet(x, y);
      landValue = landValue >> 5;
      if (population > landValue)
        return;
      if (population < 5) {
        placeCommercial(map, x, y, population, lpValue, zonePower);
        ZoneUtils.incRateOfGrowth(blockMaps, x, y, 8);
      }
    }, "growZone");
    const degradeZone$2 = /* @__PURE__ */ __name$N(function(map, x, y, blockMaps, populationCategory, lpCategory, zonePower) {
      if (populationCategory > 1) {
        placeCommercial(map, x, y, populationCategory - 2, lpCategory, zonePower);
      } else {
        ZoneUtils.putZone(map, x, y, COMCLR, zonePower);
      }
      ZoneUtils.incRateOfGrowth(blockMaps, x, y, -8);
    }, "degradeZone");
    const commercialFound = /* @__PURE__ */ __name$N(function(map, x, y, simData) {
      let lpValue;
      simData.census.comZonePop += 1;
      const tileValue = map.getTileValue(x, y);
      const population = getZonePopulation$2(map, x, y, tileValue);
      simData.census.comPop += population;
      const zonePower = map.getTile(x, y).isPowered();
      let trafficOK = Traffic.ROUTE_FOUND;
      if (population > getRandom(5)) {
        trafficOK = simData.trafficManager.makeTraffic(
          x,
          y,
          simData.blockMaps,
          TileUtils.isIndustrial
        );
        if (trafficOK === Traffic.NO_ROAD_FOUND) {
          lpValue = ZoneUtils.getLandPollutionValue(simData.blockMaps, x, y);
          degradeZone$2(map, x, y, simData.blockMaps, population, lpValue, zonePower);
          return;
        }
      }
      if (getChance(7)) {
        const locationScore = trafficOK === Traffic.NO_ROAD_FOUND ? -3e3 : simData.blockMaps.cityCentreDistScoreMap.worldGet(x, y);
        let zoneScore = simData.valves.comValve + locationScore;
        if (!zonePower)
          zoneScore = -500;
        if (zonePower && zoneScore > -350 && zoneScore - 26380 > getRandom16Signed()) {
          lpValue = ZoneUtils.getLandPollutionValue(simData.blockMaps, x, y);
          growZone$2(map, x, y, simData.blockMaps, population, lpValue, zonePower);
          return;
        }
        if (zoneScore < 350 && zoneScore + 26380 < getRandom16Signed()) {
          lpValue = ZoneUtils.getLandPollutionValue(simData.blockMaps, x, y);
          degradeZone$2(map, x, y, simData.blockMaps, population, lpValue, zonePower);
        }
      }
    }, "commercialFound");
    const Commercial = {
      registerHandlers: function(mapScanner, repairManager) {
        mapScanner.addAction(TileUtils.isCommercialZone, commercialFound);
      },
      getZonePopulation: getZonePopulation$2
    };

    var __defProp$M = Object.defineProperty;
    var __name$M = (target, value) => __defProp$M(target, "name", { value, configurable: true });
    var getZonePopulation$1 = /* @__PURE__ */ __name$M(function(map, x, y, tileValue) {
      if (tileValue === INDCLR)
        return 0;
      return Math.floor((tileValue - IZB) / 9) % 4 + 1;
    }, "getZonePopulation");
    var placeIndustrial = /* @__PURE__ */ __name$M(function(map, x, y, populationCategory, valueCategory, zonePower) {
      var centreTile = (valueCategory * 4 + populationCategory) * 9 + IZB;
      ZoneUtils.putZone(map, x, y, centreTile, zonePower);
    }, "placeIndustrial");
    var growZone$1 = /* @__PURE__ */ __name$M(function(map, x, y, blockMaps, population, valueCategory, zonePower) {
      if (population < 4) {
        placeIndustrial(map, x, y, population, valueCategory, zonePower);
        ZoneUtils.incRateOfGrowth(blockMaps, x, y, 8);
      }
    }, "growZone");
    var degradeZone$1 = /* @__PURE__ */ __name$M(function(map, x, y, blockMaps, populationCategory, valueCategory, zonePower) {
      if (populationCategory > 1)
        placeIndustrial(map, x, y, populationCategory - 2, valueCategory, zonePower);
      else
        ZoneUtils.putZone(map, x, y, INDCLR, zonePower);
      ZoneUtils.incRateOfGrowth(blockMaps, x, y, -8);
    }, "degradeZone");
    var animated = [true, false, true, true, false, false, true, true];
    var xDelta$7 = [-1, 0, 1, 0, 0, 0, 0, 1];
    var yDelta$7 = [-1, 0, -1, -1, 0, 0, -1, -1];
    var setAnimation = /* @__PURE__ */ __name$M(function(map, x, y, tileValue, isPowered) {
      if (tileValue < IZB)
        return;
      var i = tileValue - IZB >> 3;
      if (animated[i] && isPowered) {
        map.addTileFlags(x + xDelta$7[i], y + yDelta$7[i], ASCBIT);
      } else {
        map.addTileFlags(x + xDelta$7[i], y + yDelta$7[i], BNCNBIT);
        map.removeTileFlags(x + xDelta$7[i], y + yDelta$7[i], ANIMBIT);
      }
    }, "setAnimation");
    var industrialFound = /* @__PURE__ */ __name$M(function(map, x, y, simData) {
      simData.census.indZonePop += 1;
      var tileValue = map.getTileValue(x, y);
      var population = getZonePopulation$1(map, x, y, tileValue);
      simData.census.indPop += population;
      var zonePower = map.getTile(x, y).isPowered();
      setAnimation(map, x, y, tileValue, zonePower);
      var trafficOK = Traffic.ROUTE_FOUND;
      if (population > getRandom(5)) {
        trafficOK = simData.trafficManager.makeTraffic(
          x,
          y,
          simData.blockMaps,
          TileUtils.isResidential
        );
        if (trafficOK === Traffic.NO_ROAD_FOUND) {
          var newValue = getRandom16() & 1;
          degradeZone$1(map, x, y, simData.blockMaps, population, newValue, zonePower);
          return;
        }
      }
      if (getChance(7)) {
        var zoneScore = simData.valves.indValve + (trafficOK === Traffic.NO_ROAD_FOUND ? -1e3 : 0);
        if (!zonePower)
          zoneScore = -500;
        if (zoneScore > -350 && zoneScore - 26380 > getRandom16Signed()) {
          growZone$1(
            map,
            x,
            y,
            simData.blockMaps,
            population,
            getRandom16() & 1,
            zonePower
          );
          return;
        }
        if (zoneScore < 350 && zoneScore + 26380 < getRandom16Signed())
          degradeZone$1(
            map,
            x,
            y,
            simData.blockMaps,
            population,
            getRandom16() & 1,
            zonePower
          );
      }
    }, "industrialFound");
    var Industrial = {
      registerHandlers: function(mapScanner, repairManager) {
        mapScanner.addAction(TileUtils.isIndustrialZone, industrialFound);
      },
      getZonePopulation: getZonePopulation$1
    };

    var __defProp$L = Object.defineProperty;
    var __name$L = (target, value) => __defProp$L(target, "name", { value, configurable: true });
    const placeResidential = /* @__PURE__ */ __name$L(function(map, x, y, population, lpValue, zonePower) {
      const centreTile = (lpValue * 4 + population) * 9 + RZB;
      ZoneUtils.putZone(map, x, y, centreTile, zonePower);
    }, "placeResidential");
    const getFreeZonePopulation = /* @__PURE__ */ __name$L(function(map, x, y, tileValue) {
      let count = 0;
      for (let xx = x - 1; xx <= x + 1; xx++) {
        for (let yy = y - 1; yy <= y + 1; yy++) {
          if (xx === x && yy === y)
            continue;
          tileValue = map.getTileValue(xx, yy);
          if (tileValue >= LHTHR && tileValue <= HHTHR) {
            count += 1;
          }
        }
      }
      return count;
    }, "getFreeZonePopulation");
    const getZonePopulation = /* @__PURE__ */ __name$L(function(map, x, y, tileValue) {
      if (tileValue instanceof Tile)
        tileValue = tile.getValue();
      if (tileValue === FREEZ) {
        return getFreeZonePopulation(map, x, y, tileValue);
      }
      const populationIndex = Math.floor((tileValue - RZB) / 9) % 4 + 1;
      return populationIndex * 8 + 16;
    }, "getZonePopulation");
    const evalLot = /* @__PURE__ */ __name$L(function(map, x, y) {
      const xDelta = [0, 1, 0, -1];
      const yDelta = [-1, 0, 1, 0];
      if (!map.testBounds(x, y))
        return -1;
      let tileValue = map.getTileValue(x, y);
      if (tileValue < RESBASE || tileValue > RESBASE + 8) {
        return -1;
      }
      let score = 1;
      for (let i = 0; i < 4; i++) {
        const edgeX = x + xDelta[i];
        const edgeY = y + yDelta[i];
        if (edgeX < 0 || edgeX >= map.width || edgeY < 0 || edgeY >= map.height) {
          continue;
        }
        tileValue = map.getTileValue(edgeX, edgeY);
        if (tileValue !== DIRT && tileValue <= LASTROAD) {
          score += 1;
        }
      }
      return score;
    }, "evalLot");
    const buildHouse = /* @__PURE__ */ __name$L(function(map, x, y, lpValue) {
      let best = 0;
      let bestScore = 0;
      const xDelta = [0, -1, 0, 1, -1, 1, -1, 0, 1];
      const yDelta = [0, -1, -1, -1, 0, 0, 1, 1, 1];
      for (let i = 0; i < 9; i++) {
        const xx = x + xDelta[i];
        const yy = y + yDelta[i];
        const score = evalLot(map, xx, yy);
        if (score > bestScore) {
          bestScore = score;
          best = i;
        } else if (score === bestScore && getChance(7)) {
          best = i;
        }
      }
      if (best > 0 && map.testBounds(x + xDelta[best], y + yDelta[best])) {
        map.setTile(
          x + xDelta[best],
          y + yDelta[best],
          HOUSE + getRandom(2) + lpValue * 3,
          BLBNCNBIT
        );
      }
    }, "buildHouse");
    const growZone = /* @__PURE__ */ __name$L(function(map, x, y, blockMaps, population, lpValue, zonePower) {
      const pollution = blockMaps.pollutionDensityMap.worldGet(x, y);
      if (pollution > 128)
        return;
      const tileValue = map.getTileValue(x, y);
      if (tileValue === FREEZ) {
        if (population < 8) {
          buildHouse(map, x, y, lpValue);
          ZoneUtils.incRateOfGrowth(blockMaps, x, y, 1);
        } else if (blockMaps.populationDensityMap.worldGet(x, y) > 64) {
          placeResidential(map, x, y, 0, lpValue, zonePower);
          ZoneUtils.incRateOfGrowth(blockMaps, x, y, 8);
        }
        return;
      }
      if (population < 40) {
        placeResidential(
          map,
          x,
          y,
          Math.floor(population / 8) - 1,
          lpValue,
          zonePower
        );
        ZoneUtils.incRateOfGrowth(blockMaps, x, y, 8);
      }
    }, "growZone");
    const freeZone = [0, 3, 6, 1, 4, 7, 2, 5, 8];
    const degradeZone = /* @__PURE__ */ __name$L(function(map, x, y, blockMaps, population, lpValue, zonePower) {
      let xx, yy;
      if (population === 0)
        return;
      if (population > 16) {
        placeResidential(
          map,
          x,
          y,
          Math.floor((population - 24) / 8),
          lpValue,
          zonePower
        );
        ZoneUtils.incRateOfGrowth(blockMaps, x, y, -8);
        return;
      }
      if (population === 16) {
        map.setTile(x, y, FREEZ, BLBNCNBIT | ZONEBIT);
        for (yy = y - 1; yy <= y + 1; yy++) {
          for (xx = x - 1; xx <= x + 1; xx++) {
            if (xx === x && yy === y)
              continue;
            map.setTile(
              x,
              y,
              LHTHR + lpValue + getRandom(2),
              BLBNCNBIT
            );
          }
        }
        ZoneUtils.incRateOfGrowth(blockMaps, x, y, -8);
        return;
      }
      let i = 0;
      ZoneUtils.incRateOfGrowth(blockMaps, x, y, -1);
      for (xx = x - 1; xx <= x + 1; xx++) {
        for (yy = y - 1; yy <= y + 1; yy++, i++) {
          const currentValue = map.getTileValue(xx, yy);
          if (currentValue >= LHTHR && currentValue <= HHTHR) {
            map.setTile(xx, yy, freeZone[i] + RESBASE, BLBNCNBIT);
            return;
          }
        }
      }
    }, "degradeZone");
    const evalResidential = /* @__PURE__ */ __name$L(function(blockMaps, x, y, traffic) {
      if (traffic === Traffic.NO_ROAD_FOUND)
        return -3e3;
      let landValue = blockMaps.landValueMap.worldGet(x, y);
      landValue -= blockMaps.pollutionDensityMap.worldGet(x, y);
      if (landValue < 0)
        landValue = 0;
      else
        landValue = Math.min(landValue * 32, 6e3);
      return landValue - 3e3;
    }, "evalResidential");
    const residentialFound = /* @__PURE__ */ __name$L(function(map, x, y, simData) {
      let lpValue;
      simData.census.resZonePop += 1;
      const tileValue = map.getTileValue(x, y);
      const population = getZonePopulation(map, x, y, tileValue);
      simData.census.resPop += population;
      const zonePower = map.getTile(x, y).isPowered();
      let trafficOK = Traffic.ROUTE_FOUND;
      if (population > getRandom(35)) {
        trafficOK = simData.trafficManager.makeTraffic(
          x,
          y,
          simData.blockMaps,
          TileUtils.isCommercial
        );
        if (trafficOK === Traffic.NO_ROAD_FOUND) {
          lpValue = ZoneUtils.getLandPollutionValue(simData.blockMaps, x, y);
          degradeZone(map, x, y, simData.blockMaps, population, lpValue, zonePower);
          return;
        }
      }
      if (tileValue === FREEZ || getChance(7)) {
        const locationScore = evalResidential(simData.blockMaps, x, y, trafficOK);
        let zoneScore = simData.valves.resValve + locationScore;
        if (!zonePower)
          zoneScore = -500;
        if (zoneScore > -350 && zoneScore - 26380 > getRandom16Signed()) {
          if (population === 0 && getChance(3)) {
            makeHospital(map, x, y, simData, zonePower);
            return;
          }
          lpValue = ZoneUtils.getLandPollutionValue(simData.blockMaps, x, y);
          growZone(map, x, y, simData.blockMaps, population, lpValue, zonePower);
          return;
        }
        if (zoneScore < 350 && zoneScore + 26380 < getRandom16Signed()) {
          lpValue = ZoneUtils.getLandPollutionValue(simData.blockMaps, x, y);
          degradeZone(map, x, y, simData.blockMaps, population, lpValue, zonePower);
        }
      }
    }, "residentialFound");
    function makeHospital(map, x, y, simData, zonePower) {
      if (simData.census.needHospital > 0) {
        ZoneUtils.putZone(map, x, y, HOSPITAL, zonePower);
        simData.census.needHospital = 0;
      }
    }
    __name$L(makeHospital, "makeHospital");
    const hospitalFound = /* @__PURE__ */ __name$L(function(map, x, y, simData) {
      simData.census.hospitalPop += 1;
      if (simData.census.needHospital === -1) {
        if (getRandom(20) === 0) {
          ZoneUtils.putZone(
            map,
            x,
            y,
            FREEZ,
            map.getTile(x, y).isPowered()
          );
        }
      }
    }, "hospitalFound");
    const Residential = {
      registerHandlers: function(mapScanner, repairManager) {
        mapScanner.addAction(TileUtils.isResidentialZone, residentialFound);
        mapScanner.addAction(HOSPITAL, hospitalFound);
        repairManager.addAction(HOSPITAL, 15, 3);
      },
      getZonePopulation
    };

    var __defProp$K = Object.defineProperty;
    var __name$K = (target, value) => __defProp$K(target, "name", { value, configurable: true });
    const SMOOTH_NEIGHBOURS_THEN_BLOCK = 0;
    const SMOOTH_ALL_THEN_CLAMP = 1;
    const smoothMap = /* @__PURE__ */ __name$K(function(src, dest, smoothStyle) {
      for (let x = 0, width = src.width; x < width; x++) {
        for (let y = 0, height = src.height; y < height; y++) {
          let edges = 0;
          if (x > 0)
            edges += src.get(x - 1, y);
          if (x < src.width - 1)
            edges += src.get(x + 1, y);
          if (y > 0)
            edges += src.get(x, y - 1);
          if (y < src.height - 1)
            edges += src.get(x, y + 1);
          if (smoothStyle === SMOOTH_NEIGHBOURS_THEN_BLOCK) {
            edges = src.get(x, y) + Math.floor(edges / 4);
            dest.set(x, y, Math.floor(edges / 2));
          } else {
            edges = edges + src.get(x, y) >> 2;
            if (edges > 255)
              edges = 255;
            dest.set(x, y, edges);
          }
        }
      }
    }, "smoothMap");
    const neutraliseRateOfGrowthMap = /* @__PURE__ */ __name$K(function(blockMaps) {
      const rateOfGrowthMap = blockMaps.rateOfGrowthMap;
      for (let x = 0, width = rateOfGrowthMap.width; x < width; x++) {
        for (let y = 0, height = rateOfGrowthMap.height; y < height; y++) {
          let rate = rateOfGrowthMap.get(x, y);
          if (rate === 0)
            continue;
          if (rate > 0)
            rate--;
          else
            rate++;
          rate = MiscUtils.clamp(rate, -200, 200);
          rateOfGrowthMap.set(x, y, rate);
        }
      }
    }, "neutraliseRateOfGrowthMap");
    const neutraliseTrafficMap = /* @__PURE__ */ __name$K(function(blockMaps) {
      const trafficDensityMap = blockMaps.trafficDensityMap;
      for (let x = 0, width = trafficDensityMap.width; x < width; x++) {
        for (let y = 0, height = trafficDensityMap.height; y < height; y++) {
          let trafficDensity = trafficDensityMap.get(x, y);
          if (trafficDensity === 0)
            continue;
          if (trafficDensity <= 24)
            trafficDensity = 0;
          else if (trafficDensity > 200)
            trafficDensity = trafficDensity - 34;
          else
            trafficDensity = trafficDensity - 24;
          trafficDensityMap.set(x, y, trafficDensity);
        }
      }
    }, "neutraliseTrafficMap");
    const getPollutionValue = /* @__PURE__ */ __name$K(function(tileValue) {
      if (tileValue < POWERBASE) {
        if (tileValue >= HTRFBASE)
          return 75;
        if (tileValue >= LTRFBASE)
          return 50;
        if (tileValue < ROADBASE) {
          if (tileValue > FIREBASE)
            return 90;
          if (tileValue >= RADTILE)
            return 255;
        }
        return 0;
      }
      if (tileValue <= LASTIND)
        return 0;
      if (tileValue < PORTBASE)
        return 50;
      if (tileValue <= LASTPOWERPLANT)
        return 100;
      return 0;
    }, "getPollutionValue");
    const getCityCentreDistance = /* @__PURE__ */ __name$K(function(map, x, y) {
      let xDis, yDis;
      if (x > map.cityCentreX)
        xDis = x - map.cityCentreX;
      else
        xDis = map.cityCentreX - x;
      if (y > map.cityCentreY)
        yDis = y - map.cityCentreY;
      else
        yDis = map.cityCentreY - y;
      return Math.min(xDis + yDis, 64);
    }, "getCityCentreDistance");
    const pollutionTerrainLandValueScan = /* @__PURE__ */ __name$K(function(map, census, blockMaps) {
      const tempMap1 = blockMaps.tempMap1;
      const tempMap2 = blockMaps.tempMap2;
      const tempMap3 = blockMaps.tempMap3;
      tempMap3.clear();
      const landValueMap = blockMaps.landValueMap;
      const terrainDensityMap = blockMaps.terrainDensityMap;
      const pollutionDensityMap = blockMaps.pollutionDensityMap;
      const crimeRateMap = blockMaps.crimeRateMap;
      let x, y, width, height;
      let totalLandValue = 0;
      let developedTileCount = 0;
      for (x = 0, width = landValueMap.width; x < width; x++) {
        for (y = 0, height = landValueMap.height; y < height; y++) {
          let pollutionLevel = 0;
          let developed = false;
          const worldX = x * 2;
          const worldY = y * 2;
          for (let mapX = worldX; mapX <= worldX + 1; mapX++) {
            for (let mapY = worldY; mapY <= worldY + 1; mapY++) {
              const tileValue = map.getTileValue(mapX, mapY);
              if (tileValue === DIRT)
                continue;
              if (tileValue < RUBBLE) {
                const terrainValue = tempMap3.worldGet(mapX, mapY);
                tempMap3.worldSet(mapX, mapY, terrainValue + 15);
                continue;
              }
              pollutionLevel += getPollutionValue(tileValue);
              if (tileValue >= ROADBASE)
                developed = true;
            }
          }
          pollutionLevel = Math.min(pollutionLevel, 255);
          tempMap1.set(x, y, pollutionLevel);
          if (developed) {
            let landValue = 34 - Math.floor(getCityCentreDistance(map, worldX, worldY) / 2);
            landValue = landValue << 2;
            landValue += terrainDensityMap.get(x >> 1, y >> 1);
            landValue -= pollutionDensityMap.get(x, y);
            if (crimeRateMap.get(x, y) > 190)
              landValue -= 20;
            landValue = MiscUtils.clamp(landValue, 1, 250);
            landValueMap.set(x, y, landValue);
            totalLandValue += landValue;
            developedTileCount++;
          } else {
            landValueMap.set(x, y, 0);
          }
        }
      }
      if (developedTileCount > 0) {
        census.landValueAverage = Math.floor(totalLandValue / developedTileCount);
      } else
        census.landValueAverage = 0;
      smoothMap(tempMap1, tempMap2, SMOOTH_ALL_THEN_CLAMP);
      smoothMap(tempMap2, tempMap1, SMOOTH_ALL_THEN_CLAMP);
      let maxPollution = 0;
      let pollutedTileCount = 0;
      let totalPollution = 0;
      for (x = 0, width = map.width; x < width; x += pollutionDensityMap.blockSize) {
        for (y = 0, height = map.height; y < height; y += pollutionDensityMap.blockSize) {
          const pollution = tempMap1.worldGet(x, y);
          pollutionDensityMap.worldSet(x, y, pollution);
          if (pollution !== 0) {
            pollutedTileCount++;
            totalPollution += pollution;
            if (pollution > maxPollution || pollution === maxPollution && getChance(3)) {
              maxPollution = pollution;
              map.pollutionMaxX = x;
              map.pollutionMaxY = y;
            }
          }
        }
      }
      if (pollutedTileCount) {
        census.pollutionAverage = Math.floor(totalPollution / pollutedTileCount);
      } else
        census.pollutionAverage = 0;
      smoothMap(tempMap3, terrainDensityMap, SMOOTH_NEIGHBOURS_THEN_BLOCK);
    }, "pollutionTerrainLandValueScan");
    const crimeScan = /* @__PURE__ */ __name$K(function(census, blockMaps) {
      const policeStationMap = blockMaps.policeStationMap;
      const policeStationEffectMap = blockMaps.policeStationEffectMap;
      const crimeRateMap = blockMaps.crimeRateMap;
      const landValueMap = blockMaps.landValueMap;
      const populationDensityMap = blockMaps.populationDensityMap;
      smoothMap(
        policeStationMap,
        policeStationEffectMap,
        SMOOTH_NEIGHBOURS_THEN_BLOCK
      );
      smoothMap(
        policeStationEffectMap,
        policeStationMap,
        SMOOTH_NEIGHBOURS_THEN_BLOCK
      );
      smoothMap(
        policeStationMap,
        policeStationEffectMap,
        SMOOTH_NEIGHBOURS_THEN_BLOCK
      );
      let totalCrime = 0;
      let crimeZoneCount = 0;
      for (let x = 0, width = crimeRateMap.mapWidth, blockSize = crimeRateMap.blockSize; x < width; x += blockSize) {
        for (var y = 0, height = crimeRateMap.mapHeight, b; y < height; y += blockSize) {
          let value = landValueMap.worldGet(x, y);
          if (value > 0) {
            crimeZoneCount += 1;
            value = 128 - value;
            value += populationDensityMap.worldGet(x, y);
            value = Math.min(value, 300);
            value -= policeStationMap.worldGet(x, y);
            value = MiscUtils.clamp(value, 0, 250);
            crimeRateMap.worldSet(x, y, value);
            totalCrime += value;
          } else {
            crimeRateMap.worldSet(x, y, 0);
          }
        }
      }
      if (crimeZoneCount > 0) {
        census.crimeAverage = Math.floor(totalCrime / crimeZoneCount);
      } else
        census.crimeAverage = 0;
    }, "crimeScan");
    const fillCityCentreDistScoreMap = /* @__PURE__ */ __name$K(function(map, blockMaps) {
      const cityCentreDistScoreMap = blockMaps.cityCentreDistScoreMap;
      for (let x = 0, width = cityCentreDistScoreMap.width; x < width; x++) {
        for (let y = 0, height = cityCentreDistScoreMap.height; y < height; y++) {
          let value = Math.floor(getCityCentreDistance(map, x * 8, y * 8) / 2);
          value = value * 4;
          value = 64 - value;
          cityCentreDistScoreMap.set(x, y, value);
        }
      }
    }, "fillCityCentreDistScoreMap");
    const getPopulationDensity = /* @__PURE__ */ __name$K(function(map, x, y, tile) {
      if (tile < COMBASE) {
        return Residential.getZonePopulation(map, x, y, tile);
      }
      if (tile < INDBASE) {
        return Commercial.getZonePopulation(map, x, y, tile) * 8;
      }
      if (tile < PORTBASE) {
        return Industrial.getZonePopulation(map, x, y, tile) * 8;
      }
      return 0;
    }, "getPopulationDensity");
    const populationDensityScan = /* @__PURE__ */ __name$K(function(map, blockMaps) {
      const tempMap1 = blockMaps.tempMap1;
      const tempMap2 = blockMaps.tempMap2;
      blockMaps.populationDensityMap;
      let xTot = 0;
      let yTot = 0;
      let zoneTotal = 0;
      tempMap1.clear();
      for (let x = 0, width = map.width; x < width; x++) {
        for (let y = 0, height = map.height; y < height; y++) {
          const tile = map.getTile(x, y);
          if (tile.isZone()) {
            const tileValue = tile.getValue();
            let population = getPopulationDensity(map, x, y, tileValue) * 8;
            population = Math.min(population, 254);
            tempMap1.worldSet(x, y, population);
            xTot += x;
            yTot += y;
            zoneTotal++;
          }
        }
      }
      smoothMap(tempMap1, tempMap2, SMOOTH_ALL_THEN_CLAMP);
      smoothMap(tempMap2, tempMap1, SMOOTH_ALL_THEN_CLAMP);
      smoothMap(tempMap1, tempMap2, SMOOTH_ALL_THEN_CLAMP);
      blockMaps.populationDensityMap.copyFrom(tempMap2, function(x) {
        return x * 2;
      });
      fillCityCentreDistScoreMap(map, blockMaps);
      if (zoneTotal > 0) {
        map.cityCentreX = Math.floor(xTot / zoneTotal);
        map.cityCentreY = Math.floor(yTot / zoneTotal);
      } else {
        map.cityCentreX = Math.floor(map.width / 2);
        map.cityCentreY = Math.floor(map.height / 2);
      }
    }, "populationDensityScan");
    const fireAnalysis = /* @__PURE__ */ __name$K(function(blockMaps) {
      const fireStationMap = blockMaps.fireStationMap;
      const fireStationEffectMap = blockMaps.fireStationEffectMap;
      smoothMap(fireStationMap, fireStationEffectMap, SMOOTH_NEIGHBOURS_THEN_BLOCK);
      smoothMap(fireStationEffectMap, fireStationMap, SMOOTH_NEIGHBOURS_THEN_BLOCK);
      smoothMap(fireStationMap, fireStationEffectMap, SMOOTH_NEIGHBOURS_THEN_BLOCK);
    }, "fireAnalysis");
    const BlockMapUtils = {
      crimeScan,
      fireAnalysis,
      neutraliseRateOfGrowthMap,
      neutraliseTrafficMap,
      pollutionTerrainLandValueScan,
      populationDensityScan
    };

    var __defProp$J = Object.defineProperty;
    var __name$J = (target, value) => __defProp$J(target, "name", { value, configurable: true });
    const EventEmitter = /* @__PURE__ */ __name$J(function(obj) {
      const events = {};
      const addListener = /* @__PURE__ */ __name$J(function(event, listener) {
        if (!(event in events))
          events[event] = [];
        const listeners = events[event];
        if (listeners.indexOf(listener) === -1)
          listeners.push(listener);
      }, "addListener");
      const removeListener = /* @__PURE__ */ __name$J(function(event, listener) {
        if (!(event in events))
          events[event] = [];
        const listeners = events[event];
        const index = listeners.indexOf(listener);
        if (index !== -1)
          listeners.splice(index, 1);
      }, "removeListener");
      const emitEvent = /* @__PURE__ */ __name$J(function(event, value) {
        if (event === void 0) {
          console.warn("Sending undefined event!");
        }
        if (!(event in events))
          events[event] = [];
        const listeners = events[event];
        for (let i = 0, l = listeners.length; i < l; i++)
          listeners[i](value);
      }, "emitEvent");
      const addProps = /* @__PURE__ */ __name$J(function(obj2, message) {
        const hasExistingProp = [
          "addEventListener",
          "removeEventListener",
          "_emitEvent"
        ].some(function(prop) {
          return obj2[prop] !== void 0;
        });
        if (hasExistingProp) {
          throw new Error(
            "Cannot decorate " + message + ": existing properties would be overwritten!"
          );
        }
        obj2.addEventListener = addListener;
        obj2.removeEventListener = removeListener;
        obj2._emitEvent = emitEvent;
      }, "addProps");
      if (typeof obj === "object")
        addProps(obj, "object");
      else
        addProps(obj.prototype, "constructor");
      return obj;
    }, "EventEmitter");

    const AUTOBUDGET_CHANGED = "Autobudget changed";
    const BUDGET_NEEDED = "User needs to budget";
    const BUDGET_REQUESTED = "Budget window requested";
    const BUDGET_WINDOW_CLOSED = "Budget window closed";
    const BLACKOUTS_REPORTED = "Blackouts reported";
    const CLASSIFICATION_UPDATED = "Classification updated";
    const CONGRATS_SHOWING = "Congratulations showing";
    const CONGRATS_WINDOW_CLOSED = "Congratulations window closed";
    const DATE_UPDATED = "Date changed";
    const DEBUG_WINDOW_REQUESTED = "Debug Window Requested";
    const DEBUG_WINDOW_CLOSED = "Debug Window Closed";
    const DISASTER_REQUESTED = "Disaster Requested";
    const DISASTER_WINDOW_CLOSED = "Disaster window closed";
    const EARTHQUAKE = "Earthquake";
    const EVAL_REQUESTED = "Evaluation Requested";
    const EVAL_UPDATED = "Evaluation Updated";
    const EVAL_WINDOW_CLOSED = "Eval window closed";
    const EXPLOSION_REPORTED = "Explosion Reported";
    const FIRE_REPORTED = "Fire!";
    const FIRE_STATION_NEEDS_FUNDING = "Fire station needs funding";
    const FLOODING_REPORTED = "Flooding reported";
    const FRONT_END_MESSAGE = "Front-end Message";
    const FUNDS_CHANGED = "Total funds has changed";
    const HEAVY_TRAFFIC = "Total funds has changed";
    const HELICOPTER_CRASHED = "Helicopter crashed";
    const HIGH_CRIME = "High crime";
    const HIGH_POLLUTION = "High pollution";
    const MONSTER_SIGHTED = "Monster sighted";
    const NAG_WINDOW_CLOSED = "Nag window closed";
    const NEED_AIRPORT = "Airport needed";
    const NEED_ELECTRICITY = "More power needed";
    const NEED_FIRE_STATION = "Fire station needed";
    const NEED_MORE_COMMERCIAL = "More commercial zones needed";
    const NEED_MORE_INDUSTRIAL = "More industrial zones needed";
    const NEED_MORE_RAILS = "More railways needed";
    const NEED_MORE_RESIDENTIAL = "More residential needed";
    const NEED_MORE_ROADS = "More roads needed";
    const NEED_POLICE_STATION = "Police station needed";
    const NEED_SEAPORT = "Seaport needed";
    const NEED_STADIUM = "Stadium needed";
    const NO_MONEY = "No money";
    const NOT_ENOUGH_POWER = "Not enough power";
    const NUCLEAR_MELTDOWN = "Nuclear Meltdown";
    const PLANE_CRASHED = "Plane crashed";
    const POLICE_NEEDS_FUNDING = "Police need funding";
    const POPULATION_UPDATED = "Population updated";
    const QUERY_WINDOW_CLOSED = "Query window closed";
    const QUERY_WINDOW_NEEDED = "Query window needed";
    const REACHED_CAPITAL = "Now a capital";
    const REACHED_CITY = "Now a city";
    const REACHED_METROPOLIS = "Now a metropolis";
    const REACHED_MEGALOPOLIS = "Now a megalopolis";
    const REACHED_TOWN = "Now a town";
    const REACHED_VILLAGE = "Now a village";
    const ROAD_NEEDS_FUNDING = "Roads need funding";
    const SAVE_REQUESTED = "Save requested";
    const SAVE_WINDOW_CLOSED = "Save window closed";
    const SCORE_UPDATED = "Scoe updated";
    const SCREENSHOT_LINK_CLOSED = "Screenshot link closed";
    const SCREENSHOT_WINDOW_CLOSED = "Screenshot window closed";
    const SCREENSHOT_WINDOW_REQUESTED = "Screenshot window requested";
    const SETTINGS_WINDOW_CLOSED = "Settings window closed";
    const SETTINGS_WINDOW_REQUESTED = "Settings window requested";
    const SHIP_CRASHED = "Shipwrecked";
    const SOUND_EXPLOSIONHIGH = "Explosion! Bang!";
    const SOUND_EXPLOSIONLOW = "Explosion! Bang!";
    const SOUND_HEAVY_TRAFFIC = "Heavy Traffic sound";
    const SOUND_HONKHONK = "HonkHonk sound";
    const SOUND_MONSTER = "Monster sound";
    const SPEED_CHANGE = "Speed change";
    const SPRITE_DYING = "Sprite dying";
    const SPRITE_MOVED = "Sprite move";
    const TAX_TOO_HIGH = "Tax too high";
    const TOOL_CLICKED = "Tool clicked";
    const TORNADO_SIGHTED = "Tornado sighted";
    const TOUCH_WINDOW_CLOSED = "Touch Window closed";
    const TRAFFIC_JAMS = "Traffic jams reported";
    const TRAIN_CRASHED = "Train crashed";
    const VALVES_UPDATED = "Valves updated";
    const WELCOME = "Welcome";
    const DISASTER_MESSAGES = [
      EARTHQUAKE,
      EXPLOSION_REPORTED,
      FIRE_REPORTED,
      FLOODING_REPORTED,
      MONSTER_SIGHTED,
      NUCLEAR_MELTDOWN,
      TORNADO_SIGHTED
    ];
    const CRASHES = [
      HELICOPTER_CRASHED,
      PLANE_CRASHED,
      SHIP_CRASHED,
      TRAIN_CRASHED
    ];

    var Messages = /*#__PURE__*/Object.freeze({
        __proto__: null,
        AUTOBUDGET_CHANGED: AUTOBUDGET_CHANGED,
        BUDGET_NEEDED: BUDGET_NEEDED,
        BUDGET_REQUESTED: BUDGET_REQUESTED,
        BUDGET_WINDOW_CLOSED: BUDGET_WINDOW_CLOSED,
        BLACKOUTS_REPORTED: BLACKOUTS_REPORTED,
        CLASSIFICATION_UPDATED: CLASSIFICATION_UPDATED,
        CONGRATS_SHOWING: CONGRATS_SHOWING,
        CONGRATS_WINDOW_CLOSED: CONGRATS_WINDOW_CLOSED,
        DATE_UPDATED: DATE_UPDATED,
        DEBUG_WINDOW_REQUESTED: DEBUG_WINDOW_REQUESTED,
        DEBUG_WINDOW_CLOSED: DEBUG_WINDOW_CLOSED,
        DISASTER_REQUESTED: DISASTER_REQUESTED,
        DISASTER_WINDOW_CLOSED: DISASTER_WINDOW_CLOSED,
        EARTHQUAKE: EARTHQUAKE,
        EVAL_REQUESTED: EVAL_REQUESTED,
        EVAL_UPDATED: EVAL_UPDATED,
        EVAL_WINDOW_CLOSED: EVAL_WINDOW_CLOSED,
        EXPLOSION_REPORTED: EXPLOSION_REPORTED,
        FIRE_REPORTED: FIRE_REPORTED,
        FIRE_STATION_NEEDS_FUNDING: FIRE_STATION_NEEDS_FUNDING,
        FLOODING_REPORTED: FLOODING_REPORTED,
        FRONT_END_MESSAGE: FRONT_END_MESSAGE,
        FUNDS_CHANGED: FUNDS_CHANGED,
        HEAVY_TRAFFIC: HEAVY_TRAFFIC,
        HELICOPTER_CRASHED: HELICOPTER_CRASHED,
        HIGH_CRIME: HIGH_CRIME,
        HIGH_POLLUTION: HIGH_POLLUTION,
        MONSTER_SIGHTED: MONSTER_SIGHTED,
        NAG_WINDOW_CLOSED: NAG_WINDOW_CLOSED,
        NEED_AIRPORT: NEED_AIRPORT,
        NEED_ELECTRICITY: NEED_ELECTRICITY,
        NEED_FIRE_STATION: NEED_FIRE_STATION,
        NEED_MORE_COMMERCIAL: NEED_MORE_COMMERCIAL,
        NEED_MORE_INDUSTRIAL: NEED_MORE_INDUSTRIAL,
        NEED_MORE_RAILS: NEED_MORE_RAILS,
        NEED_MORE_RESIDENTIAL: NEED_MORE_RESIDENTIAL,
        NEED_MORE_ROADS: NEED_MORE_ROADS,
        NEED_POLICE_STATION: NEED_POLICE_STATION,
        NEED_SEAPORT: NEED_SEAPORT,
        NEED_STADIUM: NEED_STADIUM,
        NO_MONEY: NO_MONEY,
        NOT_ENOUGH_POWER: NOT_ENOUGH_POWER,
        NUCLEAR_MELTDOWN: NUCLEAR_MELTDOWN,
        PLANE_CRASHED: PLANE_CRASHED,
        POLICE_NEEDS_FUNDING: POLICE_NEEDS_FUNDING,
        POPULATION_UPDATED: POPULATION_UPDATED,
        QUERY_WINDOW_CLOSED: QUERY_WINDOW_CLOSED,
        QUERY_WINDOW_NEEDED: QUERY_WINDOW_NEEDED,
        REACHED_CAPITAL: REACHED_CAPITAL,
        REACHED_CITY: REACHED_CITY,
        REACHED_METROPOLIS: REACHED_METROPOLIS,
        REACHED_MEGALOPOLIS: REACHED_MEGALOPOLIS,
        REACHED_TOWN: REACHED_TOWN,
        REACHED_VILLAGE: REACHED_VILLAGE,
        ROAD_NEEDS_FUNDING: ROAD_NEEDS_FUNDING,
        SAVE_REQUESTED: SAVE_REQUESTED,
        SAVE_WINDOW_CLOSED: SAVE_WINDOW_CLOSED,
        SCORE_UPDATED: SCORE_UPDATED,
        SCREENSHOT_LINK_CLOSED: SCREENSHOT_LINK_CLOSED,
        SCREENSHOT_WINDOW_CLOSED: SCREENSHOT_WINDOW_CLOSED,
        SCREENSHOT_WINDOW_REQUESTED: SCREENSHOT_WINDOW_REQUESTED,
        SETTINGS_WINDOW_CLOSED: SETTINGS_WINDOW_CLOSED,
        SETTINGS_WINDOW_REQUESTED: SETTINGS_WINDOW_REQUESTED,
        SHIP_CRASHED: SHIP_CRASHED,
        SOUND_EXPLOSIONHIGH: SOUND_EXPLOSIONHIGH,
        SOUND_EXPLOSIONLOW: SOUND_EXPLOSIONLOW,
        SOUND_HEAVY_TRAFFIC: SOUND_HEAVY_TRAFFIC,
        SOUND_HONKHONK: SOUND_HONKHONK,
        SOUND_MONSTER: SOUND_MONSTER,
        SPEED_CHANGE: SPEED_CHANGE,
        SPRITE_DYING: SPRITE_DYING,
        SPRITE_MOVED: SPRITE_MOVED,
        TAX_TOO_HIGH: TAX_TOO_HIGH,
        TOOL_CLICKED: TOOL_CLICKED,
        TORNADO_SIGHTED: TORNADO_SIGHTED,
        TOUCH_WINDOW_CLOSED: TOUCH_WINDOW_CLOSED,
        TRAFFIC_JAMS: TRAFFIC_JAMS,
        TRAIN_CRASHED: TRAIN_CRASHED,
        VALVES_UPDATED: VALVES_UPDATED,
        WELCOME: WELCOME,
        DISASTER_MESSAGES: DISASTER_MESSAGES,
        CRASHES: CRASHES
    });

    const policeMaintenanceCost = 100;
    const fireMaintenanceCost = 100;
    const roadMaintenanceCost = 1;
    const railMaintenanceCost = 2;
    const Budget = EventEmitter(function() {
      Object.defineProperties(this, {
        MAX_ROAD_EFFECT: MiscUtils.makeConstantDescriptor(32),
        MAX_POLICESTATION_EFFECT: MiscUtils.makeConstantDescriptor(1e3),
        MAX_FIRESTATION_EFFECT: MiscUtils.makeConstantDescriptor(1e3)
      });
      this.roadEffect = this.MAX_ROAD_EFFECT;
      this.policeEffect = this.MAX_POLICESTATION_EFFECT;
      this.fireEffect = this.MAX_FIRESTATION_EFFECT;
      this.totalFunds = 0;
      this.cityTax = 7;
      this.cashFlow = 0;
      this.taxFund = 0;
      this.roadMaintenanceBudget = 0;
      this.fireMaintenanceBudget = 0;
      this.policeMaintenanceBudget = 0;
      this.roadPercent = 1;
      this.firePercent = 1;
      this.policePercent = 1;
      this.roadSpend = 0;
      this.fireSpend = 0;
      this.policeSpend = 0;
      this.awaitingValues = false;
      this.autoBudget = true;
    });
    const saveProps$3 = [
      "autoBudget",
      "totalFunds",
      "policePercent",
      "roadPercent",
      "firePercent",
      "roadSpend",
      "policeSpend",
      "fireSpend",
      "roadMaintenanceBudget",
      "policeMaintenanceBudget",
      "fireMaintenanceBudget",
      "cityTax",
      "roadEffect",
      "policeEffect",
      "fireEffect"
    ];
    Budget.prototype.save = function(saveData) {
      for (let i = 0, l = saveProps$3.length; i < l; i++) {
        saveData[saveProps$3[i]] = this[saveProps$3[i]];
      }
    };
    Budget.prototype.load = function(saveData) {
      for (let i = 0, l = saveProps$3.length; i < l; i++) {
        this[saveProps$3[i]] = saveData[saveProps$3[i]] || this[saveProps$3[i]];
      }
      this._emitEvent(AUTOBUDGET_CHANGED, this.autoBudget);
      this._emitEvent(FUNDS_CHANGED, this.totalFunds);
    };
    Budget.prototype.setAutoBudget = function(value) {
      this.autoBudget = value;
      this._emitEvent(AUTOBUDGET_CHANGED, this.autoBudget);
    };
    const RLevels = [0.7, 0.9, 1.2];
    const FLevels = [1.4, 1.2, 0.8];
    Budget.prototype._calculateBestPercentages = function() {
      this.roadSpend = Math.round(this.roadMaintenanceBudget * this.roadPercent);
      this.fireSpend = Math.round(this.fireMaintenanceBudget * this.firePercent);
      this.policeSpend = Math.round(
        this.policeMaintenanceBudget * this.policePercent
      );
      const total = this.roadSpend + this.fireSpend + this.policeSpend;
      if (total === 0) {
        this.roadPercent = 1;
        this.firePercent = 1;
        this.policePercent = 1;
        return { road: 1, fire: 1, police: 1 };
      }
      let roadCost = 0;
      let fireCost = 0;
      let policeCost = 0;
      let cashRemaining = this.totalFunds + this.taxFund;
      if (cashRemaining >= this.roadSpend)
        roadCost = this.roadSpend;
      else
        roadCost = cashRemaining;
      cashRemaining -= roadCost;
      if (cashRemaining >= this.fireSpend)
        fireCost = this.fireSpend;
      else
        fireCost = cashRemaining;
      cashRemaining -= fireCost;
      if (cashRemaining >= this.policeSpend)
        policeCost = this.policeSpend;
      else
        policeCost = cashRemaining;
      cashRemaining -= policeCost;
      if (this.roadMaintenanceBudget > 0) {
        this.roadPercent = (roadCost / this.roadMaintenanceBudget).toPrecision(2) - 0;
      } else
        this.roadPercent = 1;
      if (this.fireMaintenanceBudget > 0) {
        this.firePercent = (fireCost / this.fireMaintenanceBudget).toPrecision(2) - 0;
      } else
        this.firePercent = 1;
      if (this.policeMaintenanceBudget > 0) {
        this.policePercent = (policeCost / this.policeMaintenanceBudget).toPrecision(2) - 0;
      } else
        this.policePercent = 1;
      return { road: roadCost, police: policeCost, fire: fireCost };
    };
    Budget.prototype.doBudgetWindow = function() {
      return this.doBudgetNow(true);
    };
    Budget.prototype.doBudgetNow = function(fromWindow) {
      const costs = this._calculateBestPercentages();
      if (!this.autoBudget && !fromWindow) {
        this.autoBudget = false;
        this.awaitingValues = true;
        this._emitEvent(BUDGET_NEEDED);
        return;
      }
      const roadCost = costs.road;
      const policeCost = costs.police;
      const fireCost = costs.fire;
      const totalCost = roadCost + policeCost + fireCost;
      const cashRemaining = this.totalFunds + this.taxFund - totalCost;
      if (cashRemaining > 0 && this.autoBudget || fromWindow) {
        this.awaitingValues = false;
        this.doBudgetSpend(roadCost, fireCost, policeCost);
        return;
      }
      this.setAutoBudget(false);
      this.awaitingValues = true;
      this._emitEvent(BUDGET_NEEDED);
      this._emitEvent(NO_MONEY);
    };
    Budget.prototype.doBudgetSpend = function(roadValue, fireValue, policeValue) {
      this.roadSpend = roadValue;
      this.fireSpend = fireValue;
      this.policeSpend = policeValue;
      const total = this.roadSpend + this.fireSpend + this.policeSpend;
      this.spend(-(this.taxFund - total));
      this.updateFundEffects();
    };
    Budget.prototype.updateFundEffects = function() {
      this.roadSpend = Math.round(this.roadMaintenanceBudget * this.roadPercent);
      this.fireSpend = Math.round(this.fireMaintenanceBudget * this.firePercent);
      this.policeSpend = Math.round(
        this.policeMaintenanceBudget * this.policePercent
      );
      this.roadEffect = this.MAX_ROAD_EFFECT;
      this.policeEffect = this.MAX_POLICESTATION_EFFECT;
      this.fireEffect = this.MAX_FIRESTATION_EFFECT;
      if (this.roadMaintenanceBudget > 0) {
        this.roadEffect = Math.floor(
          this.roadEffect * this.roadSpend / this.roadMaintenanceBudget
        );
      }
      if (this.fireMaintenanceBudget > 0) {
        this.fireEffect = Math.floor(
          this.fireEffect * this.fireSpend / this.fireMaintenanceBudget
        );
      }
      if (this.policeMaintenanceBudget > 0) {
        this.policeEffect = Math.floor(
          this.policeEffect * this.policeSpend / this.policeMaintenanceBudget
        );
      }
    };
    Budget.prototype.collectTax = function(gameLevel, census) {
      this.cashFlow = 0;
      this.policeMaintenanceBudget = census.policeStationPop * policeMaintenanceCost;
      this.fireMaintenanceBudget = census.fireStationPop * fireMaintenanceCost;
      const roadCost = census.roadTotal * roadMaintenanceCost;
      const railCost = census.railTotal * railMaintenanceCost;
      this.roadMaintenanceBudget = Math.floor(
        (roadCost + railCost) * RLevels[gameLevel]
      );
      this.taxFund = Math.floor(
        Math.floor(census.totalPop * census.landValueAverage / 120) * this.cityTax * FLevels[gameLevel]
      );
      if (census.totalPop > 0) {
        this.cashFlow = this.taxFund - (this.policeMaintenanceBudget + this.fireMaintenanceBudget + this.roadMaintenanceBudget);
        this.doBudgetNow(false);
      } else {
        this.roadEffect = this.MAX_ROAD_EFFECT;
        this.policeEffect = this.MAX_POLICESTATION_EFFECT;
        this.fireEffect = this.MAX_FIRESTATION_EFFECT;
      }
    };
    Budget.prototype.setTax = function(amount) {
      if (amount === this.cityTax)
        return;
      this.cityTax = amount;
    };
    Budget.prototype.setFunds = function(amount) {
      if (amount === this.totalFunds)
        return;
      this.totalFunds = Math.max(0, amount);
      this._emitEvent(FUNDS_CHANGED, this.totalFunds);
      if (this.totalFunds === 0)
        this._emitEvent(NO_MONEY);
    };
    Budget.prototype.spend = function(amount) {
      this.setFunds(this.totalFunds - amount);
    };
    Budget.prototype.shouldDegradeRoad = function() {
      return this.roadEffect < Math.floor(15 * this.MAX_ROAD_EFFECT / 16);
    };

    var __defProp$I = Object.defineProperty;
    var __name$I = (target, value) => __defProp$I(target, "name", { value, configurable: true });
    const arrs = ["res", "com", "ind", "crime", "money", "pollution"];
    function Census() {
      this.clearCensus();
      this.changed = false;
      this.crimeRamp = 0;
      this.pollutionRamp = 0;
      this.landValueAverage = 0;
      this.pollutionAverage = 0;
      this.crimeAverage = 0;
      this.totalPop = 0;
      const createArray = /* @__PURE__ */ __name$I(function(arrName) {
        this[arrName] = [];
        for (let a = 0; a < 120; a++)
          this[arrName][a] = 0;
      }, "createArray");
      for (let i = 0; i < arrs.length; i++) {
        const name10 = arrs[i] + "Hist10";
        const name120 = arrs[i] + "Hist120";
        createArray.call(this, name10);
        createArray.call(this, name120);
      }
    }
    __name$I(Census, "Census");
    const rotate10Arrays = /* @__PURE__ */ __name$I(function() {
      for (let i = 0; i < arrs.length; i++) {
        const name10 = arrs[i] + "Hist10";
        this[name10].pop();
        this[name10].unshift(0);
      }
    }, "rotate10Arrays");
    const rotate120Arrays = /* @__PURE__ */ __name$I(function() {
      for (let i = 0; i < arrs.length; i++) {
        const name120 = arrs[i] + "Hist120";
        this[name120].pop();
        this[name120].unshift(0);
      }
    }, "rotate120Arrays");
    Census.prototype.clearCensus = function() {
      this.poweredZoneCount = 0;
      this.unpoweredZoneCount = 0;
      this.firePop = 0;
      this.roadTotal = 0;
      this.railTotal = 0;
      this.resPop = 0;
      this.comPop = 0;
      this.indPop = 0;
      this.resZonePop = 0;
      this.comZonePop = 0;
      this.indZonePop = 0;
      this.hospitalPop = 0;
      this.churchPop = 0;
      this.policeStationPop = 0;
      this.fireStationPop = 0;
      this.stadiumPop = 0;
      this.coalPowerPop = 0;
      this.nuclearPowerPop = 0;
      this.seaportPop = 0;
      this.airportPop = 0;
    };
    const saveProps$2 = [
      "resPop",
      "comPop",
      "indPop",
      "crimeRamp",
      "pollutionRamp",
      "landValueAverage",
      "pollutionAverage",
      "crimeAverage",
      "totalPop",
      "resHist10",
      "resHist120",
      "comHist10",
      "comHist120",
      "indHist10",
      "indHist120",
      "crimeHist10",
      "crimeHist120",
      "moneyHist10",
      "moneyHist120",
      "pollutionHist10",
      "pollutionHist120"
    ];
    Census.prototype.save = function(saveData) {
      for (let i = 0, l = saveProps$2.length; i < l; i++) {
        saveData[saveProps$2[i]] = this[saveProps$2[i]];
      }
    };
    Census.prototype.load = function(saveData) {
      for (let i = 0, l = saveProps$2.length; i < l; i++) {
        this[saveProps$2[i]] = saveData[saveProps$2[i]] || this[saveProps$2[i]];
      }
    };
    Census.prototype.take10Census = function(budget) {
      const resPopDenom = 8;
      rotate10Arrays.call(this);
      this.resHist10[0] = Math.floor(this.resPop / resPopDenom);
      this.comHist10[0] = this.comPop;
      this.indHist10[0] = this.indPop;
      this.crimeRamp += Math.floor((this.crimeAverage - this.crimeRamp) / 4);
      this.crimeHist10[0] = Math.min(this.crimeRamp, 255);
      this.pollutionRamp += Math.floor(
        (this.pollutionAverage - this.pollutionRamp) / 4
      );
      this.pollutionHist10[0] = Math.min(this.pollutionRamp, 255);
      const x = Math.floor(budget.cashFlow / 20) + 128;
      this.moneyHist10[0] = MiscUtils.clamp(x, 0, 255);
      this.resPop >> 8;
      if (this.hospitalPop < this.resPopScaled)
        this.needHospital = 1;
      else if (this.hospitalPop > this.resPopScaled)
        this.needHospital = -1;
      else if (this.hospitalPop === this.resPopScaled)
        this.needHospital = 0;
      this.changed = true;
    };
    Census.prototype.take120Census = function() {
      rotate120Arrays.call(this);
      const resPopDenom = 8;
      this.resHist120[0] = Math.floor(this.resPop / resPopDenom);
      this.comHist120[0] = this.comPop;
      this.indHist120[0] = this.indPop;
      this.crimeHist120[0] = this.crimeHist10[0];
      this.pollutionHist120[0] = this.pollutionHist10[0];
      this.moneyHist120[0] = this.moneyHist10[0];
      this.changed = true;
    };

    var __defProp$H = Object.defineProperty;
    var __name$H = (target, value) => __defProp$H(target, "name", { value, configurable: true });
    const DisasterManager = EventEmitter(function(map, spriteManager, gameLevel) {
      this._map = map;
      this._spriteManager = spriteManager;
      this._gameLevel = gameLevel;
      this._floodCount = 0;
      this.disastersEnabled = false;
    });
    const DisChance = [479, 239, 59];
    DisasterManager.prototype.doDisasters = function(census) {
      if (this._floodCount)
        this._floodCount--;
      if (!this.disastersEnabled)
        return;
      if (!getRandom(DisChance[this._gameLevel])) {
        switch (getRandom(8)) {
          case 0:
          case 1:
            this.setFire();
            break;
          case 2:
          case 3:
            this.makeFlood();
            break;
          case 4:
            break;
          case 5:
            this._spriteManager.makeTornado();
            break;
          case 6:
            break;
          case 7:
          case 8:
            if (census.pollutionAverage > 60)
              this._spriteManager.makeMonster();
            break;
        }
      }
    };
    DisasterManager.prototype.scenarioDisaster = function() {
    };
    DisasterManager.prototype.makeMeltdown = function() {
      for (let x = 0; x < this._map.width - 1; x++) {
        for (let y = 0; y < this._map.height - 1; y++) {
          if (this._map.getTileValue(x, y) === NUCLEAR) {
            this.doMeltdown(x, y);
            return;
          }
        }
      }
    };
    const vulnerable = /* @__PURE__ */ __name$H(function(tile) {
      const tileValue = tile.getValue();
      if (tileValue < RESBASE || tileValue > LASTZONE || tile.isZone()) {
        return false;
      }
      return true;
    }, "vulnerable");
    DisasterManager.prototype.makeEarthquake = function() {
      const strength = getRandom(700) + 300;
      this.doEarthquake(strength);
      this._emitEvent(EARTHQUAKE, {
        x: this._map.cityCenterX,
        y: this._map.cityCenterY
      });
      for (let i = 0; i < strength; i++) {
        const x = getRandom(this._map.width - 1);
        const y = getRandom(this._map.height - 1);
        if (!this._map.testBounds(x, y))
          continue;
        if (vulnerable(this._map.getTile(x, y))) {
          if ((i & 3) !== 0)
            this._map.setTo(x, y, TileUtils.randomRubble());
          else
            this._map.setTo(x, y, TileUtils.randomFire());
        }
      }
    };
    DisasterManager.prototype.setFire = function(times, zonesOnly) {
      times = times || 1;
      zonesOnly = zonesOnly || false;
      for (let i = 0; i < times; i++) {
        const x = getRandom(this._map.width - 1);
        const y = getRandom(this._map.height - 1);
        if (!this._map.testBounds(x, y))
          continue;
        let tile = this._map.getTile(x, y);
        if (!tile.isZone()) {
          tile = tile.getValue();
          const lowerLimit = zonesOnly ? LHTHR : TREEBASE;
          if (tile > lowerLimit && tile < LASTZONE) {
            this._map.setTo(x, y, TileUtils.randomFire());
            this._emitEvent(FIRE_REPORTED, { showable: true, x, y });
            return;
          }
        }
      }
    };
    DisasterManager.prototype.makeCrash = function() {
      let s = this._spriteManager.getSprite(SPRITE_AIRPLANE);
      if (s !== null) {
        s.explodeSprite();
        return;
      }
      const x = getRandom(this._map.width - 1);
      const y = getRandom(this._map.height - 1);
      this._spriteManager.generatePlane(x, y);
      s = this._spriteManager.getSprite(SPRITE_AIRPLANE);
      s.explodeSprite();
    };
    DisasterManager.prototype.makeFire = function() {
      this.setFire(40, false);
    };
    const Dx = [0, 1, 0, -1];
    const Dy = [-1, 0, 1, 0];
    DisasterManager.prototype.makeFlood = function() {
      for (let i = 0; i < 300; i++) {
        const x = getRandom(this._map.width - 1);
        const y = getRandom(this._map.height - 1);
        if (!this._map.testBounds(x, y))
          continue;
        let tileValue = this._map.getTileValue(x, y);
        if (tileValue > CHANNEL && tileValue <= WATER_HIGH) {
          for (let j = 0; j < 4; j++) {
            const xx = x + Dx[j];
            const yy = y + Dy[j];
            if (!this._map.testBounds(xx, yy))
              continue;
            const tile = this._map.getTile(xx, yy);
            tileValue = tile.getValue();
            if (tile === DIRT || tile.isBulldozable() && tile.isCombustible) {
              this._map.setTile(xx, yy, FLOOD, 0);
              this._floodCount = 30;
              this._emitEvent(FLOODING_REPORTED, {
                showable: true,
                x: xx,
                y: yy
              });
              return;
            }
          }
        }
      }
    };
    DisasterManager.prototype.doFlood = function(x, y, blockMaps) {
      if (this._floodCount > 0) {
        for (let i = 0; i < 4; i++) {
          if (getChance(7)) {
            const xx = x + Dx[i];
            const yy = y + Dy[i];
            if (this._map.testBounds(xx, yy)) {
              const tile = this._map.getTile(xx, yy);
              const tileValue = tile.getValue();
              if (tile.isCombustible() || tileValue === DIRT || tileValue >= WOODS5 && tileValue < FLOOD) {
                if (tile.isZone())
                  ZoneUtils.fireZone(this._map, xx, yy, blockMaps);
                this._map.setTile(xx, yy, FLOOD + getRandom(2), 0);
              }
            }
          }
        }
      } else {
        if (getChance(15))
          this._map.setTile(x, y, DIRT, 0);
      }
    };
    DisasterManager.prototype.doMeltdown = function(x, y) {
      this._spriteManager.makeExplosion(x - 1, y - 1);
      this._spriteManager.makeExplosion(x - 1, y + 2);
      this._spriteManager.makeExplosion(x + 2, y - 1);
      this._spriteManager.makeExplosion(x + 2, y + 2);
      let dY, dX;
      for (dX = x - 1; dX < x + 3; dX++) {
        for (dY = y - 1; dY < y + 3; dY++) {
          this._map.setTo(dX, dY, TileUtils.randomFire());
        }
      }
      for (let i = 0; i < 200; i++) {
        dX = x - 20 + getRandom(40);
        dY = y - 15 + getRandom(30);
        if (!this._map.testBounds(dX, dY))
          continue;
        const tile = this._map.getTile(dX, dY);
        if (tile.isZone())
          continue;
        if (tile.isCombustible() || tile.getValue() === DIRT) {
          this._map.setTile(dX, dY, RADTILE, 0);
        }
      }
      this._emitEvent(NUCLEAR_MELTDOWN, { showable: true, x, y });
    };

    var __defProp$G = Object.defineProperty;
    var __name$G = (target, value) => __defProp$G(target, "name", { value, configurable: true });
    const handleService = /* @__PURE__ */ __name$G(function(censusStat, budgetEffect, blockMap) {
      return function(map, x, y, simData) {
        simData.census[censusStat] += 1;
        let effect = simData.budget[budgetEffect];
        const isPowered = map.getTile(x, y).isPowered();
        if (!isPowered)
          effect = Math.floor(effect / 2);
        const pos = new Position(x, y);
        const connectedToRoads = simData.trafficManager.findPerimeterRoad(pos);
        if (!connectedToRoads)
          effect = Math.floor(effect / 2);
        let currentEffect = simData.blockMaps[blockMap].worldGet(x, y);
        currentEffect += effect;
        simData.blockMaps[blockMap].worldSet(x, y, currentEffect);
      };
    }, "handleService");
    const policeStationFound = handleService(
      "policeStationPop",
      "policeEffect",
      "policeStationMap"
    );
    const fireStationFound = handleService(
      "fireStationPop",
      "fireEffect",
      "fireStationMap"
    );
    const EmergencyServices = {
      registerHandlers: function(mapScanner, repairManager) {
        mapScanner.addAction(POLICESTATION, policeStationFound);
        mapScanner.addAction(FIRESTATION, fireStationFound);
      }
    };

    var __defProp$F = Object.defineProperty;
    var __name$F = (target, value) => __defProp$F(target, "name", { value, configurable: true });
    var PROBLEMS = [
      "CVP_CRIME",
      "CVP_POLLUTION",
      "CVP_HOUSING",
      "CVP_TAXES",
      "CVP_TRAFFIC",
      "CVP_UNEMPLOYMENT",
      "CVP_FIRE"
    ];
    var NUMPROBLEMS = PROBLEMS.length;
    var NUM_COMPLAINTS = 4;
    var problemData = [];
    var Evaluation = EventEmitter(function(gameLevel) {
      this.problemVotes = [];
      this.problemOrder = [];
      this.evalInit();
      this.gameLevel = "" + gameLevel;
    });
    Evaluation.prototype.cityEvaluation = function(simData) {
      var census = simData.census;
      if (census.totalPop > 0) {
        for (var i = 0; i < NUMPROBLEMS; i++)
          problemData.push(0);
        this.getAssessedValue(census);
        this.getPopulation(census);
        this.doProblems(simData.census, simData.budget, simData.blockMaps);
        this.getScore(simData);
        this.doVotes();
      } else {
        this.evalInit();
        this.cityYes = 50;
      }
    };
    Evaluation.prototype.evalInit = function() {
      this.cityYes = 0;
      this.cityPop = 0;
      this.cityPopDelta = 0;
      this.cityAssessedValue = 0;
      this.cityClass = Evaluation.CC_VILLAGE;
      this.cityClassLast = Evaluation.CC_VILLAGE;
      this.cityScore = 500;
      this.cityScoreDelta = 0;
      for (var i = 0; i < NUMPROBLEMS; i++)
        this.problemVotes[i] = { index: i, voteCount: 0 };
      for (i = 0; i < NUM_COMPLAINTS; i++)
        this.problemOrder[i] = NUMPROBLEMS;
    };
    var saveProps$1 = ["cityClass", "cityScore"];
    Evaluation.prototype.save = function(saveData) {
      for (var i = 0, l = saveProps$1.length; i < l; i++)
        saveData[saveProps$1[i]] = this[saveProps$1[i]];
    };
    Evaluation.prototype.load = function(saveData) {
      for (var i = 0, l = saveProps$1.length; i < l; i++)
        this[saveProps$1[i]] = saveData[saveProps$1[i]];
    };
    Evaluation.prototype.getAssessedValue = function(census) {
      var value;
      value = census.roadTotal * 5;
      value += census.railTotal * 10;
      value += census.policeStationPop * 1e3;
      value += census.fireStationPop * 1e3;
      value += census.hospitalPop * 400;
      value += census.stadiumPop * 3e3;
      value += census.seaportPop * 5e3;
      value += census.airportPop * 1e4;
      value += census.coalPowerPop * 3e3;
      value += census.nuclearPowerPop * 6e3;
      this.cityAssessedValue = value * 1e3;
    };
    Evaluation.prototype.getPopulation = function(census) {
      var oldPopulation = this.cityPop;
      this.cityPop = (census.resPop + (census.comPop + census.indPop) * 8) * 20;
      this.cityPopDelta = this.cityPop - oldPopulation;
      if (this.cityPopDelta !== 0)
        this._emitEvent(POPULATION_UPDATED, this.cityPop);
      return this.cityPop;
    };
    Evaluation.prototype.getCityClass = function(cityPopulation) {
      this.cityClass = Evaluation.CC_VILLAGE;
      if (cityPopulation > 2e3)
        this.cityClass = Evaluation.CC_TOWN;
      if (cityPopulation > 1e4)
        this.cityClass = Evaluation.CC_CITY;
      if (cityPopulation > 5e4)
        this.cityClass = Evaluation.CC_CAPITAL;
      if (cityPopulation > 1e5)
        this.cityClass = Evaluation.CC_METROPOLIS;
      if (cityPopulation > 5e5)
        this.cityClass = Evaluation.CC_MEGALOPOLIS;
      if (this.cityClass !== this.cityClassLast) {
        this.cityClassLast = this.cityClass;
        this._emitEvent(CLASSIFICATION_UPDATED, this.cityClass);
      }
      return this.cityClass;
    };
    Evaluation.prototype.voteProblems = function() {
      for (var i = 0; i < NUMPROBLEMS; i++) {
        this.problemVotes[i].index = i;
        this.problemVotes[i].voteCount = 0;
      }
      var problem = 0;
      var voteCount = 0;
      var loopCount = 0;
      while (voteCount < 100 && loopCount < 600) {
        var voterProblemTolerance = getRandom(300);
        if (problemData[problem] > voterProblemTolerance) {
          this.problemVotes[problem].voteCount += 1;
          voteCount++;
        }
        problem = (problem + 1) % NUMPROBLEMS;
        loopCount++;
      }
    };
    var getTrafficAverage = /* @__PURE__ */ __name$F(function(blockMaps, census) {
      var trafficDensityMap = blockMaps.trafficDensityMap;
      var landValueMap = blockMaps.landValueMap;
      var trafficTotal = 0;
      var count = 1;
      for (var x = 0; x < landValueMap.gameMapWidth; x += landValueMap.blockSize) {
        for (var y = 0; y < landValueMap.gameMapHeight; y += landValueMap.blockSize) {
          if (landValueMap.worldGet(x, y) > 0) {
            trafficTotal += trafficDensityMap.worldGet(x, y);
            count++;
          }
        }
      }
      var trafficAverage = census.trafficAverage = Math.floor(trafficTotal / count) * 2.4;
      return trafficAverage;
    }, "getTrafficAverage");
    var getUnemployment = /* @__PURE__ */ __name$F(function(census) {
      var b = (census.comPop + census.indPop) * 8;
      if (b === 0)
        return 0;
      var r = census.resPop / b;
      b = Math.round((r - 1) * 255);
      return Math.min(b, 255);
    }, "getUnemployment");
    var getFireSeverity = /* @__PURE__ */ __name$F(function(census) {
      return Math.min(census.firePop * 5, 255);
    }, "getFireSeverity");
    Evaluation.prototype.doProblems = function(census, budget, blockMaps) {
      problemData[Evaluation.CRIME] = census.crimeAverage;
      problemData[Evaluation.POLLUTION] = census.pollutionAverage;
      problemData[Evaluation.HOUSING] = census.landValueAverage * 7 / 10;
      problemData[Evaluation.TAXES] = budget.cityTax * 10;
      problemData[Evaluation.TRAFFIC] = getTrafficAverage(blockMaps, census);
      problemData[Evaluation.UNEMPLOYMENT] = getUnemployment(census);
      problemData[Evaluation.FIRE] = getFireSeverity(census);
      this.voteProblems();
      this.problemVotes.sort(function(a, b) {
        return b.voteCount - a.voteCount;
      });
      this.problemOrder = this.problemVotes.map(function(pv, i) {
        if (i >= NUM_COMPLAINTS || pv.voteCount === 0)
          return null;
        return pv.index;
      });
    };
    Evaluation.prototype.getScore = function(simData) {
      var census = simData.census;
      var budget = simData.budget;
      var valves = simData.valves;
      var cityScoreLast = this.cityScore;
      var score = 0;
      for (var i = 0; i < NUMPROBLEMS; i++)
        score += problemData[i];
      score = Math.floor(score / 3);
      score = (250 - Math.min(score, 250)) * 4;
      var demandPenalty = 0.85;
      if (valves.resCap)
        score = Math.round(score * demandPenalty);
      if (valves.comCap)
        score = Math.round(score * demandPenalty);
      if (valves.indCap)
        score = Math.round(score * demandPenalty);
      if (budget.roadEffect < budget.MAX_ROAD_EFFECT)
        score -= budget.MAX_ROAD_EFFECT - budget.roadEffect;
      if (budget.policeEffect < budget.MAX_POLICE_STATION_EFFECT)
        score = Math.round(
          score * (0.9 + budget.policeEffect / (10 * budget.MAX_POLICE_STATION_EFFECT))
        );
      if (budget.fireEffect < budget.MAX_FIRE_STATION_EFFECT)
        score = Math.round(
          score * (0.9 + budget.fireEffect / (10 * budget.MAX_FIRE_STATION_EFFECT))
        );
      if (valves.resValve < -1e3)
        score = Math.round(score * 0.85);
      if (valves.comValve < -1e3)
        score = Math.round(score * 0.85);
      if (valves.indValve < -1e3)
        score = Math.round(score * 0.85);
      var scale = 1;
      if (this.cityPop === 0 || this.cityPopDelta === 0 || this.cityPopDelta === this.cityPop) {
        scale = 1;
      } else if (this.cityPopDelta > 0) {
        scale = this.cityPopDelta / this.cityPop + 1;
      } else if (this.cityPopDelta < 0) {
        scale = 0.95 + Math.floor(this.cityPopDelta / (this.cityPop - this.cityPopDelta));
      }
      score = Math.round(score * scale);
      score = score - getFireSeverity(census) - budget.cityTax;
      scale = census.unpoweredZoneCount + census.poweredZoneCount;
      if (scale > 0)
        score = Math.round(score * (census.poweredZoneCount / scale));
      score = MiscUtils.clamp(score, 0, 1e3);
      this.cityScore = Math.round((this.cityScore + score) / 2);
      this.cityScoreDelta = this.cityScore - cityScoreLast;
      if (this.cityScoreDelta !== 0)
        this._emitEvent(SCORE_UPDATED, this.cityScore);
    };
    Evaluation.prototype.doVotes = function() {
      this.cityYes = 0;
      for (var i = 0; i < 100; i++) {
        var voterExpectation = getRandom(1e3);
        if (this.cityScore > voterExpectation)
          this.cityYes++;
      }
    };
    Evaluation.prototype.getProblemNumber = function(i) {
      if (i < 0 || i >= NUM_COMPLAINTS)
        return null;
      return this.problemOrder[i];
    };
    Object.defineProperties(Evaluation, {
      CC_VILLAGE: MiscUtils.makeConstantDescriptor("VILLAGE"),
      CC_TOWN: MiscUtils.makeConstantDescriptor("TOWN"),
      CC_CITY: MiscUtils.makeConstantDescriptor("CITY"),
      CC_CAPITAL: MiscUtils.makeConstantDescriptor("CAPITAL"),
      CC_METROPOLIS: MiscUtils.makeConstantDescriptor("METROPOLIS"),
      CC_MEGALOPOLIS: MiscUtils.makeConstantDescriptor("MEGALOPOLIS"),
      CRIME: MiscUtils.makeConstantDescriptor(0),
      POLLUTION: MiscUtils.makeConstantDescriptor(1),
      HOUSING: MiscUtils.makeConstantDescriptor(2),
      TAXES: MiscUtils.makeConstantDescriptor(3),
      TRAFFIC: MiscUtils.makeConstantDescriptor(4),
      UNEMPLOYMENT: MiscUtils.makeConstantDescriptor(5),
      FIRE: MiscUtils.makeConstantDescriptor(6)
    });

    var __defProp$E = Object.defineProperty;
    var __name$E = (target, value) => __defProp$E(target, "name", { value, configurable: true });
    const tile$1 = new Tile();
    function MapScanner(map) {
      this._map = map;
      this._actions = [];
    }
    __name$E(MapScanner, "MapScanner");
    const isCallable$1 = /* @__PURE__ */ __name$E(function(f) {
      return typeof f === "function";
    }, "isCallable");
    MapScanner.prototype.addAction = function(criterion, action) {
      this._actions.push({ criterion, action });
    };
    MapScanner.prototype.mapScan = function(startX, maxX, simData) {
      for (let y = 0; y < this._map.height; y++) {
        for (let x = startX; x < maxX; x++) {
          this._map.getTile(x, y, tile$1);
          const tileValue = tile$1.getValue();
          if (tileValue < FLOOD)
            continue;
          if (tile$1.isConductive())
            simData.powerManager.setTilePower(x, y);
          if (tile$1.isZone()) {
            simData.repairManager.checkTile(x, y, simData.cityTime);
            const powered = tile$1.isPowered();
            if (powered)
              simData.census.poweredZoneCount += 1;
            else
              simData.census.unpoweredZoneCount += 1;
          }
          for (let i = 0, l = this._actions.length; i < l; i++) {
            const current = this._actions[i];
            const callable = isCallable$1(current.criterion);
            if (callable && current.criterion.call(null, tile$1)) {
              current.action.call(null, this._map, x, y, simData);
              break;
            } else if (!callable && current.criterion === tileValue) {
              current.action.call(null, this._map, x, y, simData);
              break;
            }
          }
        }
      }
    };

    var __defProp$D = Object.defineProperty;
    var __name$D = (target, value) => __defProp$D(target, "name", { value, configurable: true });
    const xDelta$6 = [-1, 0, 1, 0];
    const yDelta$6 = [0, -1, 0, 1];
    const fireFound = /* @__PURE__ */ __name$D(function(map, x, y, simData) {
      simData.census.firePop += 1;
      if ((getRandom16() & 3) !== 0)
        return;
      for (let i2 = 0; i2 < 4; i2++) {
        if (getChance(7)) {
          const xTem = x + xDelta$6[i2];
          const yTem = y + yDelta$6[i2];
          if (map.testBounds(xTem, yTem)) {
            const tile = map.getTile(x, y);
            if (!tile.isCombustible())
              continue;
            if (tile.isZone()) {
              ZoneUtils.fireZone(map, x, y, simData.blockMaps);
              if (tile.getValue() > IZB)
                simData.spriteManager.makeExplosionAt(x, y);
            }
            map.setTo(TileUtils.randomFire());
          }
        }
      }
      let rate = 10;
      const i = simData.blockMaps.fireStationEffectMap.worldGet(x, y);
      if (i > 100)
        rate = 1;
      else if (i > 20)
        rate = 2;
      else if (i > 0)
        rate = 3;
      if (getRandom(rate) === 0)
        map.setTo(x, y, TileUtils.randomRubble());
    }, "fireFound");
    const radiationFound = /* @__PURE__ */ __name$D(function(map, x, y, simData) {
      if (getChance(4095))
        map.setTile(x, y, DIRT, 0);
    }, "radiationFound");
    const floodFound = /* @__PURE__ */ __name$D(function(map, x, y, simData) {
      simData.disasterManager.doFlood(x, y, simData.blockMaps);
    }, "floodFound");
    const MiscTiles = {
      registerHandlers: function(mapScanner, repairManager) {
        mapScanner.addAction(TileUtils.isFire, fireFound, true);
        mapScanner.addAction(RADTILE, radiationFound, true);
        mapScanner.addAction(TileUtils.isFlood, floodFound, true);
      }
    };

    const COAL_POWER_STRENGTH = 700;
    const NUCLEAR_POWER_STRENGTH = 2e3;
    const PowerManager = EventEmitter(function(map) {
      this._map = map;
      this._powerStack = [];
      this.powerGridMap = new BlockMap(this._map.width, this._map.height, 1);
    });
    PowerManager.prototype.setTilePower = function(x, y) {
      const tile = this._map.getTile(x, y);
      const tileValue = tile.getValue();
      if (tileValue === NUCLEAR || tileValue === POWERPLANT || this.powerGridMap.worldGet(x, y) > 0) {
        tile.addFlags(POWERBIT);
        return;
      }
      tile.removeFlags(POWERBIT);
    };
    PowerManager.prototype.clearPowerStack = function() {
      this._powerStackPointer = 0;
      this._powerStack = [];
    };
    PowerManager.prototype.testForConductive = function(pos, testDir) {
      const movedPos = Position.move(pos, testDir);
      if (this._map.isPositionInBounds(movedPos)) {
        if (this._map.getTile(movedPos.x, movedPos.y).isConductive()) {
          if (this.powerGridMap.worldGet(movedPos.x, movedPos.y) === 0)
            return true;
        }
      }
      return false;
    };
    PowerManager.prototype.doPowerScan = function(census) {
      this.powerGridMap.clear();
      const maxPower = census.coalPowerPop * COAL_POWER_STRENGTH + census.nuclearPowerPop * NUCLEAR_POWER_STRENGTH;
      let powerConsumption = 0;
      while (this._powerStack.length > 0) {
        var pos = this._powerStack.pop();
        var anyDir = void 0;
        var conNum;
        do {
          powerConsumption++;
          if (powerConsumption > maxPower) {
            this._emitEvent(NOT_ENOUGH_POWER);
            return;
          }
          if (anyDir)
            pos = Position.move(pos, anyDir);
          this.powerGridMap.worldSet(pos.x, pos.y, 1);
          conNum = 0;
          forEachCardinalDirection((dir) => {
            if (conNum >= 2) {
              return;
            }
            if (this.testForConductive(pos, dir)) {
              conNum++;
              anyDir = dir;
            }
          });
          if (conNum > 1)
            this._powerStack.push(new Position(pos.x, pos.y));
        } while (conNum);
      }
    };
    PowerManager.prototype.coalPowerFound = function(map, x, y, simData) {
      simData.census.coalPowerPop += 1;
      this._powerStack.push(new Position(x, y));
      const dX2 = [-1, 2, 1, 2];
      const dY2 = [-1, -1, 0, 0];
      for (let i = 0; i < 4; i++)
        map.addTileFlags(x + dX2[i], y + dY2[i], ANIMBIT);
    };
    const meltdownTable = [3e4, 2e4, 1e4];
    PowerManager.prototype.nuclearPowerFound = function(map, x, y, simData) {
      if (simData.disasterManager.disastersEnabled && getRandom(meltdownTable[simData.gameLevel]) === 0) {
        simData.disasterManager.doMeltdown(x, y);
        return;
      }
      simData.census.nuclearPowerPop += 1;
      this._powerStack.push(new Position(x, y));
      for (let i = 0; i < 4; i++) {
        map.addTileFlags(x, y, ANIMBIT | CONDBIT | POWERBIT | BURNBIT);
      }
    };
    PowerManager.prototype.registerHandlers = function(mapScanner, repairManager) {
      mapScanner.addAction(POWERPLANT, this.coalPowerFound.bind(this));
      mapScanner.addAction(NUCLEAR, this.nuclearPowerFound.bind(this));
      repairManager.addAction(POWERPLANT, 7, 4);
      repairManager.addAction(NUCLEAR, 7, 4);
    };

    var __defProp$C = Object.defineProperty;
    var __name$C = (target, value) => __defProp$C(target, "name", { value, configurable: true });
    function RepairManager(map) {
      this._map = map;
      this._actions = [];
    }
    __name$C(RepairManager, "RepairManager");
    const isCallable = /* @__PURE__ */ __name$C(function(f) {
      return typeof f === "function";
    }, "isCallable");
    RepairManager.prototype.addAction = function(criterion, period, zoneSize) {
      this._actions.push({
        criterion,
        period,
        zoneSize
      });
    };
    RepairManager.prototype.repairZone = function(x, y, zoneSize) {
      const centre = this._map.getTileValue(x, y);
      let tileValue = centre - zoneSize - 2;
      for (let yy = -1; yy < zoneSize - 1; yy++) {
        for (let xx = -1; xx < zoneSize - 1; xx++) {
          tileValue++;
          const current = this._map.getTile(x + xx, y + yy);
          if (current.isZone() || current.isAnimated())
            continue;
          const currentValue = current.getValue();
          if (currentValue < RUBBLE || currentValue >= ROADBASE) {
            this._map.setTile(x + xx, y + yy, tileValue, CONDBIT | BURNBIT);
          }
        }
      }
    };
    RepairManager.prototype.checkTile = function(x, y, cityTime) {
      for (let i = 0, l = this._actions.length; i < l; i++) {
        const current = this._actions[i];
        const period = current.period;
        if ((cityTime & period) !== 0)
          continue;
        const tile = this._map.getTile(x, y);
        const tileValue = tile.getValue();
        const callable = isCallable(current.criterion);
        if (callable && current.criterion.call(null, tile)) {
          this.repairZone(x, y, current.zoneSize);
        } else if (!callable && current.criterion === tileValue) {
          this.repairZone(x, y, current.zoneSize);
        }
      }
    };

    var __defProp$B = Object.defineProperty;
    var __name$B = (target, value) => __defProp$B(target, "name", { value, configurable: true });
    const openBridge = /* @__PURE__ */ __name$B(function(map, origX, origY, xDelta, yDelta, oldTiles, newTiles) {
      for (let i = 0; i < 7; i++) {
        const x = origX + xDelta[i];
        const y = origY + yDelta[i];
        if (map.testBounds(x, y)) {
          if (map.getTileValue(x, y) === (oldTiles[i] & BIT_MASK)) {
            map.setTileValue(x, y, newTiles[i]);
          }
        }
      }
    }, "openBridge");
    const closeBridge = /* @__PURE__ */ __name$B(function(map, origX, origY, xDelta, yDelta, oldTiles, newTiles) {
      for (let i = 0; i < 7; i++) {
        const x = origX + xDelta[i];
        const y = origY + yDelta[i];
        if (map.testBounds(x, y)) {
          const tileValue = map.getTileValue(x, y);
          if (tileValue === CHANNEL || (tileValue & 15) === (oldTiles[i] & 15)) {
            map.setTileValue(x, y, newTiles[i]);
          }
        }
      }
    }, "closeBridge");
    const verticalDeltaX = [0, 1, 0, 0, 0, 0, 1];
    const verticalDeltaY = [-2, -2, -1, 0, 1, 2, 2];
    const openVertical = [
      VBRDG0 | BULLBIT,
      VBRDG1 | BULLBIT,
      RIVER,
      BRWV | BULLBIT,
      RIVER,
      VBRDG2 | BULLBIT,
      VBRDG3 | BULLBIT
    ];
    const closeVertical = [
      VBRIDGE | BULLBIT,
      RIVER,
      VBRIDGE | BULLBIT,
      VBRIDGE | BULLBIT,
      VBRIDGE | BULLBIT,
      VBRIDGE | BULLBIT,
      RIVER
    ];
    const horizontalDeltaX = [-2, 2, -2, -1, 0, 1, 2];
    const horizontalDeltaY = [-1, -1, 0, 0, 0, 0, 0];
    const openHorizontal = [
      HBRDG1 | BULLBIT,
      HBRDG3 | BULLBIT,
      HBRDG0 | BULLBIT,
      RIVER,
      BRWH | BULLBIT,
      RIVER,
      HBRDG2 | BULLBIT
    ];
    const closeHorizontal = [
      RIVER,
      RIVER,
      HBRIDGE | BULLBIT,
      HBRIDGE | BULLBIT,
      HBRIDGE | BULLBIT,
      HBRIDGE | BULLBIT,
      HBRIDGE | BULLBIT
    ];
    const doBridge = /* @__PURE__ */ __name$B(function(map, x, y, currentTile, simData) {
      if (currentTile === BRWV) {
        if (getChance(3) && simData.spriteManager.getBoatDistance(x, y) > 340) {
          closeBridge(
            map,
            x,
            y,
            verticalDeltaX,
            verticalDeltaY,
            openVertical,
            closeVertical
          );
        }
        return true;
      }
      if (currentTile == BRWH) {
        if (getChance(3) && simData.spriteManager.getBoatDistance(x, y) > 340) {
          closeBridge(
            map,
            x,
            y,
            horizontalDeltaX,
            horizontalDeltaY,
            openHorizontal,
            closeHorizontal
          );
        }
        return true;
      }
      if (simData.spriteManager.getBoatDistance(x, y) < 300 || getChance(7)) {
        if (currentTile & 1) {
          if (x < map.width - 1) {
            if (map.getTileValue(x + 1, y) === CHANNEL) {
              openBridge(
                map,
                x,
                y,
                verticalDeltaX,
                verticalDeltaY,
                closeVertical,
                openVertical
              );
              return true;
            }
          }
          return false;
        } else {
          if (y > 0) {
            if (map.getTileValue(x, y - 1) === CHANNEL) {
              openBridge(
                map,
                x,
                y,
                horizontalDeltaX,
                horizontalDeltaY,
                closeHorizontal,
                openHorizontal
              );
              return true;
            }
          }
        }
      }
      return false;
    }, "doBridge");
    const densityTable = [
      ROADBASE,
      LTRFBASE,
      HTRFBASE
    ];
    const roadFound = /* @__PURE__ */ __name$B(function(map, x, y, simData) {
      simData.census.roadTotal += 1;
      let currentTile = map.getTile(x, y);
      const tileValue = currentTile.getValue();
      if (simData.budget.shouldDegradeRoad()) {
        if (getChance(511)) {
          currentTile = map.getTile(x, y);
          if (!currentTile.isConductive()) {
            if (simData.budget.roadEffect < (getRandom16() & 31)) {
              currentTile.getValue();
              if ((tileValue & 15) < 2 || (tileValue & 15) === 15) {
                map.setTile(x, y, RIVER, 0);
              } else
                map.setTo(x, y, TileUtils.randomRubble());
              return;
            }
          }
        }
      }
      if (!currentTile.isCombustible()) {
        simData.census.roadTotal += 4;
        if (doBridge(map, x, y, tileValue, simData))
          return;
      }
      let density = 0;
      if (tileValue < LTRFBASE) {
        density = 0;
      } else if (tileValue < HTRFBASE) {
        density = 1;
      } else {
        simData.census.roadTotal += 1;
        density = 2;
      }
      let currentDensity = simData.blockMaps.trafficDensityMap.worldGet(x, y) >> 6;
      if (currentDensity > 1)
        currentDensity -= 1;
      if (currentDensity === density)
        return;
      const newValue = (tileValue - ROADBASE & 15) + densityTable[currentDensity];
      let newFlags = currentTile.getFlags() & ~ANIMBIT;
      if (currentDensity > 0)
        newFlags |= ANIMBIT;
      map.setTo(x, y, new Tile(newValue, newFlags));
    }, "roadFound");
    const Road = {
      registerHandlers: function(mapScanner, repairManager) {
        mapScanner.addAction(TileUtils.isRoad, roadFound);
      }
    };

    var __defProp$A = Object.defineProperty;
    var __name$A = (target, value) => __defProp$A(target, "name", { value, configurable: true });
    const init$1 = /* @__PURE__ */ __name$A(function(type, map, spriteManager, x, y) {
      this.type = type;
      this.map = map;
      this.spriteManager = spriteManager;
      let pixX = x;
      let pixY = y;
      let worldX = x >> 4;
      let worldY = y >> 4;
      Object.defineProperty(this, "x", {
        configurable: false,
        enumerable: true,
        set: function(val) {
          pixX = val;
          worldX = val >> 4;
        },
        get: function() {
          return pixX;
        }
      });
      Object.defineProperty(this, "y", {
        configurable: false,
        enumerable: true,
        set: function(val) {
          pixY = val;
          worldY = val >> 4;
        },
        get: function() {
          return pixY;
        }
      });
      Object.defineProperty(this, "worldX", {
        configurable: false,
        enumerable: true,
        set: function(val) {
          worldX = val;
          pixX = val << 4;
        },
        get: function() {
          return worldX;
        }
      });
      Object.defineProperty(this, "worldY", {
        configurable: false,
        enumerable: true,
        set: function(val) {
          worldY = val;
          pixY = val << 4;
        },
        get: function() {
          return worldY;
        }
      });
      this.origX = 0;
      this.origY = 0;
      this.destX = 0;
      this.destY = 0;
      this.count = 0;
      this.soundCount = 0;
      this.dir = 0;
      this.newDir = 0;
      this.step = 0;
      this.flag = 0;
      this.turn = 0;
      this.accel = 0;
      this.speed = 100;
    }, "init");
    const getFileName = /* @__PURE__ */ __name$A(function() {
      return ["obj", this.type, "-", this.frame - 1].join("");
    }, "getFileName");
    const spriteNotInBounds = /* @__PURE__ */ __name$A(function() {
      const x = this.worldX;
      const y = this.worldY;
      return x < 0 || y < 0 || x >= this.map.width || y >= this.map.height;
    }, "spriteNotInBounds");
    const base = {
      init: init$1,
      getFileName,
      spriteNotInBounds
    };
    const BaseSprite = /* @__PURE__ */ __name$A(function(spriteConstructor) {
      spriteConstructor.prototype = Object.create(base);
      EventEmitter(spriteConstructor);
    }, "BaseSprite");

    var __defProp$z = Object.defineProperty;
    var __name$z = (target, value) => __defProp$z(target, "name", { value, configurable: true });
    function AirplaneSprite(map, spriteManager, x, y) {
      this.init(SPRITE_AIRPLANE, map, spriteManager, x, y);
      this.width = 48;
      this.height = 48;
      this.xOffset = -24;
      this.yOffset = -24;
      if (x > SpriteUtils.worldToPix(map.width - 20)) {
        this.destX = this.x - 200;
        this.frame = 7;
      } else {
        this.destX = this.x + 200;
        this.frame = 11;
      }
      this.destY = this.y;
    }
    __name$z(AirplaneSprite, "AirplaneSprite");
    BaseSprite(AirplaneSprite);
    const xDelta$5 = [0, 0, 6, 8, 6, 0, -6, -8, -6, 8, 8, 8];
    const yDelta$5 = [0, -8, -6, 0, 6, 8, 6, 0, -6, 0, 0, 0];
    AirplaneSprite.prototype.move = function(spriteCycle, disasterManager, blockMaps) {
      let frame = this.frame;
      if (spriteCycle % 5 === 0) {
        if (frame > 8) {
          frame--;
          if (frame < 9) {
            frame = 3;
          }
          this.frame = frame;
        } else {
          const d = SpriteUtils.getDir(this.x, this.y, this.destX, this.destY);
          frame = SpriteUtils.turnTo(frame, d);
          this.frame = frame;
        }
      }
      const absDist = SpriteUtils.absoluteDistance(
        this.x,
        this.y,
        this.destX,
        this.destY
      );
      if (absDist < 50) {
        this.destX = getRandom(SpriteUtils.worldToPix(this.map.width)) + 8;
        this.destY = getRandom(SpriteUtils.worldToPix(this.map.height)) + 8;
      }
      if (disasterManager.enableDisasters) {
        let explode = false;
        const spriteList = this.spriteManager.getSpriteList();
        for (let i = 0; i < spriteList.length; i++) {
          const s = spriteList[i];
          if (s.frame === 0 || s === this)
            continue;
          if ((s.type === SPRITE_HELICOPTER || s.type === SPRITE_AIRPLANE) && SpriteUtils.checkSpriteCollision(this, s)) {
            s.explodeSprite();
            explode = true;
          }
        }
        if (explode)
          this.explodeSprite();
      }
      this.x += xDelta$5[frame];
      this.y += yDelta$5[frame];
      if (this.spriteNotInBounds())
        this.frame = 0;
    };
    AirplaneSprite.prototype.explodeSprite = function() {
      this.frame = 0;
      this.spriteManager.makeExplosionAt(this.x, this.y);
      this._emitEvent(PLANE_CRASHED, {
        showable: true,
        x: this.worldX,
        y: this.worldY
      });
    };
    Object.defineProperties(AirplaneSprite, {
      ID: MiscUtils.makeConstantDescriptor(3),
      width: MiscUtils.makeConstantDescriptor(48),
      frames: MiscUtils.makeConstantDescriptor(11)
    });

    var __defProp$y = Object.defineProperty;
    var __name$y = (target, value) => __defProp$y(target, "name", { value, configurable: true });
    function BoatSprite(map, spriteManager, x, y) {
      this.init(SPRITE_SHIP, map, spriteManager, x, y);
      this.width = 48;
      this.height = 48;
      this.xOffset = -24;
      this.yOffset = -24;
      if (x < SpriteUtils.worldToPix(4))
        this.frame = 3;
      else if (x >= SpriteUtils.worldToPix(map.width - 4))
        this.frame = 7;
      else if (y < SpriteUtils.worldToPix(4))
        this.frame = 5;
      else if (y >= SpriteUtils.worldToPix(map.height - 4))
        this.frame = 1;
      else
        this.frame = 3;
      this.newDir = this.frame;
      this.dir = 10;
      this.count = 1;
    }
    __name$y(BoatSprite, "BoatSprite");
    BaseSprite(BoatSprite);
    const oppositeAndUnderwater = /* @__PURE__ */ __name$y(function(tileValue, oldDir, newDir) {
      let opposite = oldDir + 4;
      if (opposite > 8)
        opposite -= 8;
      if (newDir !== opposite)
        return false;
      if (tileValue === POWERBASE || tileValue === POWERBASE + 1 || tileValue === RAILBASE || tileValue === RAILBASE + 1) {
        return true;
      }
      return false;
    }, "oppositeAndUnderwater");
    const tileDeltaX$1 = [0, 0, 1, 1, 1, 0, -1, -1, -1];
    const tileDeltaY$1 = [0, -1, -1, 0, 1, 1, 1, 0, -1];
    const xDelta$4 = [0, 0, 2, 2, 2, 0, -2, -2, -2];
    const yDelta$4 = [0, -2, -2, 0, 2, 2, 2, 0, -2];
    const tileWhiteList = [
      RIVER,
      CHANNEL,
      POWERBASE,
      POWERBASE + 1,
      RAILBASE,
      RAILBASE + 1,
      BRWH,
      BRWV
    ];
    const CANTMOVE$1 = 10;
    BoatSprite.prototype.move = function(spriteCycle, disasterManager, blockMaps) {
      let tile = RIVER;
      let frame, x, y;
      if (this.soundCount > 0)
        this.soundCount--;
      if (this.soundCount === 0) {
        if ((getRandom16() & 3) === 1) {
          this._emitEvent(SOUND_HONKHONK);
        }
        this.soundCount = 200;
      }
      if (this.count > 0)
        this.count--;
      if (this.count === 0) {
        this.count = 9;
        if (this.frame !== this.newDir) {
          this.frame = SpriteUtils.turnTo(this.frame, this.newDir);
          return;
        }
        const startDir = getRandom16() & 7;
        let dir = startDir;
        for (; dir < startDir + 8; dir++) {
          frame = (dir & 7) + 1;
          if (frame === this.dir)
            continue;
          x = this.worldX + tileDeltaX$1[frame];
          y = this.worldY + tileDeltaY$1[frame];
          if (this.map.testBounds(x, y)) {
            tile = this.map.getTileValue(x, y);
            if (tile === CHANNEL || tile === BRWH || tile === BRWV || oppositeAndUnderwater(tile, this.dir, frame)) {
              this.newDir = frame;
              this.frame = SpriteUtils.turnTo(this.frame, this.newDir);
              this.dir = frame + 4;
              if (this.dir > 8)
                this.dir -= 8;
              break;
            }
          }
        }
        if (dir === startDir + 8) {
          this.dir = CANTMOVE$1;
          this.newDir = (getRandom16() & 7) + 1;
        }
      } else {
        frame = this.frame;
        if (frame === this.newDir) {
          this.x += xDelta$4[frame];
          this.y += yDelta$4[frame];
        }
      }
      if (this.spriteNotInBounds()) {
        this.frame = 0;
        return;
      }
      for (let i = 0; i < 8; i++) {
        if (tile === tileWhiteList[i]) {
          break;
        }
        if (i === 7) {
          this.explodeSprite();
          SpriteUtils.destroyMapTile(
            this.spriteManager,
            this.map,
            blockMaps,
            this.x,
            this.y
          );
        }
      }
    };
    BoatSprite.prototype.explodeSprite = function() {
      this.frame = 0;
      this.spriteManager.makeExplosionAt(this.x, this.y);
      this._emitEvent(SHIP_CRASHED, {
        showable: true,
        x: this.worldX,
        y: this.worldY
      });
    };
    Object.defineProperties(BoatSprite, {
      ID: MiscUtils.makeConstantDescriptor(4),
      width: MiscUtils.makeConstantDescriptor(48),
      frames: MiscUtils.makeConstantDescriptor(8)
    });

    var __defProp$x = Object.defineProperty;
    var __name$x = (target, value) => __defProp$x(target, "name", { value, configurable: true });
    function CopterSprite(map, spriteManager, x, y) {
      this.init(SPRITE_HELICOPTER, map, spriteManager, x, y);
      this.width = 32;
      this.height = 32;
      this.xOffset = -16;
      this.yOffset = -16;
      this.frame = 5;
      this.count = 1500;
      this.destX = getRandom(SpriteUtils.worldToPix(map.width)) + 8;
      this.destY = getRandom(SpriteUtils.worldToPix(map.height)) + 8;
      this.origX = x;
      this.origY = y;
    }
    __name$x(CopterSprite, "CopterSprite");
    BaseSprite(CopterSprite);
    const xDelta$3 = [0, 0, 3, 5, 3, 0, -3, -5, -3];
    const yDelta$3 = [0, -5, -3, 0, 3, 5, 3, 0, -3];
    CopterSprite.prototype.move = function(spriteCycle, disasterManager, blockMaps) {
      if (this.soundCount > 0)
        this.soundCount--;
      if (this.count > 0)
        this.count--;
      if (this.count === 0) {
        let s = this.spriteManager.getSprite(SPRITE_MONSTER);
        if (s !== null) {
          this.destX = s.x;
          this.destY = s.y;
        } else {
          s = this.spriteManager.getSprite(SPRITE_TORNADO);
          if (s !== null) {
            this.destX = s.x;
            this.destY = s.y;
          } else {
            this.destX = this.origX;
            this.destY = this.origY;
          }
        }
        const absDist = SpriteUtils.absoluteDistance(
          this.x,
          this.y,
          this.origX,
          this.origY
        );
        if (absDist < 30) {
          this.frame = 0;
          return;
        }
      }
      if (this.soundCount === 0) {
        const x = this.worldX;
        const y = this.worldY;
        if (x >= 0 && x < this.map.width && y >= 0 && y < this.map.height) {
          if (blockMaps.trafficDensityMap.worldGet(x, y) > 170 && (getRandom16() & 7) === 0) {
            this._emitEvent(HEAVY_TRAFFIC, { x, y });
            this._emitEvent(SOUND_HEAVY_TRAFFIC);
            this.soundCount = 200;
          }
        }
      }
      let frame = this.frame;
      if ((spriteCycle & 3) === 0) {
        const dir = SpriteUtils.getDir(this.x, this.y, this.destX, this.destY);
        frame = SpriteUtils.turnTo(frame, dir);
        this.frame = frame;
      }
      this.x += xDelta$3[frame];
      this.y += yDelta$3[frame];
    };
    CopterSprite.prototype.explodeSprite = function() {
      this.frame = 0;
      this.spriteManager.makeExplosionAt(this.x, this.y);
      this._emitEvent(HELICOPTER_CRASHED, { x: this.worldX, y: this.worldY });
    };
    Object.defineProperties(CopterSprite, {
      ID: MiscUtils.makeConstantDescriptor(2),
      width: MiscUtils.makeConstantDescriptor(32),
      frames: MiscUtils.makeConstantDescriptor(8)
    });

    var __defProp$w = Object.defineProperty;
    var __name$w = (target, value) => __defProp$w(target, "name", { value, configurable: true });
    function ExplosionSprite(map, spriteManager, x, y) {
      this.init(SPRITE_EXPLOSION, map, spriteManager, x, y);
      this.width = 48;
      this.height = 48;
      this.xOffset = -24;
      this.yOffset = -24;
      this.frame = 1;
    }
    __name$w(ExplosionSprite, "ExplosionSprite");
    BaseSprite(ExplosionSprite);
    ExplosionSprite.prototype.startFire = function(x, y) {
      x = this.worldX;
      y = this.worldY;
      if (!this.map.testBounds(x, y))
        return;
      var tile = this.map.getTile(x, y);
      var tileValue = tile.getValue();
      if (!tile.isCombustible() && tileValue !== DIRT)
        return;
      if (tile.isZone())
        return;
      this.map.setTo(x, y, TileUtils.randomFire());
    };
    ExplosionSprite.prototype.move = function(spriteCycle, disasterManager, blockMaps) {
      if ((spriteCycle & 1) === 0) {
        if (this.frame === 1) {
          var explosionX = this.worldX;
          var explosionY = this.worldY;
          this._emitEvent(SOUND_EXPLOSIONHIGH);
          this._emitEvent(EXPLOSION_REPORTED, { x: explosionX, y: explosionY });
        }
        this.frame++;
      }
      if (this.frame > 6) {
        this.frame = 0;
        this.startFire(this.x, this.y);
        this.startFire(this.x - 16, this.y - 16);
        this.startFire(this.x + 16, this.y + 16);
        this.startFire(this.x - 16, this.y + 16);
        this.startFire(this.x + 16, this.y + 16);
      }
    };
    Object.defineProperties(ExplosionSprite, {
      ID: MiscUtils.makeConstantDescriptor(7),
      width: MiscUtils.makeConstantDescriptor(48),
      frames: MiscUtils.makeConstantDescriptor(6)
    });

    var __defProp$v = Object.defineProperty;
    var __name$v = (target, value) => __defProp$v(target, "name", { value, configurable: true });
    function MonsterSprite(map, spriteManager, x, y) {
      this.init(SPRITE_MONSTER, map, spriteManager, x, y);
      this.width = 48;
      this.height = 48;
      this.xOffset = -24;
      this.yOffset = -24;
      if (x > SpriteUtils.worldToPix(map.width) / 2) {
        if (y > SpriteUtils.worldToPix(map.height) / 2)
          this.frame = 10;
        else
          this.frame = 7;
      } else if (y > SpriteUtils.worldToPix(map.height) / 2) {
        this.frame = 1;
      } else {
        this.frame = 4;
      }
      this.flag = 0;
      this.count = 1e3;
      this.destX = SpriteUtils.worldToPix(map.pollutionMaxX);
      this.destY = SpriteUtils.worldToPix(map.pollutionMaxY);
      this.origX = this.x;
      this.origY = this.y;
      this._seenLand = false;
    }
    __name$v(MonsterSprite, "MonsterSprite");
    BaseSprite(MonsterSprite);
    const xDelta$2 = [2, 2, -2, -2, 0];
    const yDelta$2 = [-2, 2, 2, -2, 0];
    const cardinals1 = [0, 1, 2, 3];
    const cardinals2 = [1, 2, 3, 0];
    const diagonals1 = [2, 5, 8, 11];
    const diagonals2 = [11, 2, 5, 8];
    MonsterSprite.prototype.move = function(spriteCycle, disasterManager, blockMaps) {
      if (this.soundCount > 0)
        this.soundCount--;
      let currentDir = Math.floor((this.frame - 1) / 3);
      let frame, dir;
      if (currentDir < 4) {
        frame = (this.frame - 1) % 3;
        if (frame === 2)
          this.step = 0;
        if (frame === 0)
          this.step = 1;
        if (this.step)
          frame++;
        else
          frame--;
        const absDist = SpriteUtils.absoluteDistance(
          this.x,
          this.y,
          this.destX,
          this.destY
        );
        if (absDist < 60) {
          if (this.flag === 0) {
            this.flag = 1;
            this.destX = this.origX;
            this.destY = this.origY;
          } else {
            this.frame = 0;
            this._emitEvent(SPRITE_DYING);
            return;
          }
        }
        dir = SpriteUtils.getDir(this.x, this.y, this.destX, this.destY);
        dir = Math.floor((dir - 1) / 2);
        if (dir !== currentDir && getChance(10)) {
          if (getRandom16() & 1)
            frame = cardinals1[currentDir];
          else
            frame = cardinals2[currentDir];
          currentDir = 4;
          if (!this.soundCount) {
            this._emitEvent(SOUND_MONSTER);
            this.soundCount = 50 + getRandom(100);
          }
        }
      } else {
        currentDir = 4;
        dir = this.frame;
        frame = dir - 13 & 3;
        if (!(getRandom16() & 3)) {
          if (getRandom16() & 1)
            frame = diagonals1[frame];
          else
            frame = diagonals2[frame];
          currentDir = Math.floor((frame - 1) / 3);
          frame = (frame - 1) % 3;
        }
      }
      frame = currentDir * 3 + frame + 1;
      if (frame > 16)
        frame = 16;
      this.frame = frame;
      this.x += xDelta$2[currentDir];
      this.y += yDelta$2[currentDir];
      if (this.count > 0)
        this.count--;
      const tileValue = SpriteUtils.getTileValue(this.map, this.x, this.y);
      if (tileValue === -1 || tileValue === RIVER && this.count < 500) {
        this.frame = 0;
      }
      if (tileValue === DIRT || tileValue > WATER_HIGH)
        this._seenLand = true;
      const spriteList = this.spriteManager.getSpriteList();
      for (let i = 0; i < spriteList.length; i++) {
        const s = spriteList[i];
        if (s.frame !== 0 && (s.type === SPRITE_AIRPLANE || s.type === SPRITE_HELICOPTER || s.type === SPRITE_SHIP || s.type === SPRITE_TRAIN) && SpriteUtils.checkSpriteCollision(this, s)) {
          s.explodeSprite();
        }
      }
      if (this.frame === 0)
        this._emitEvent(SPRITE_DYING);
      SpriteUtils.destroyMapTile(
        this.spriteManager,
        this.map,
        blockMaps,
        this.x,
        this.y
      );
      this._emitEvent(SPRITE_MOVED, { x: this.worldX, y: this.worldY });
    };
    Object.defineProperties(MonsterSprite, {
      ID: MiscUtils.makeConstantDescriptor(5),
      width: MiscUtils.makeConstantDescriptor(48),
      frames: MiscUtils.makeConstantDescriptor(16)
    });

    var __defProp$u = Object.defineProperty;
    var __name$u = (target, value) => __defProp$u(target, "name", { value, configurable: true });
    function TornadoSprite(map, spriteManager, x, y) {
      this.init(SpriteConstants.SPRITE_TORNADO, map, spriteManager, x, y);
      this.width = 48;
      this.height = 48;
      this.xOffset = -24;
      this.yOffset = -40;
      this.frame = 1;
      this.count = 200;
    }
    __name$u(TornadoSprite, "TornadoSprite");
    BaseSprite(TornadoSprite);
    const xDelta$1 = [2, 3, 2, 0, -2, -3];
    const yDelta$1 = [-2, 0, 2, 3, 2, 0];
    TornadoSprite.prototype.move = function(spriteCycle, disasterManager, blockMaps) {
      let frame = this.frame;
      if (frame === 2) {
        if (this.flag)
          frame = 3;
        else
          frame = 1;
      } else {
        if (frame === 1)
          this.flag = 1;
        else
          this.flag = 0;
        frame = 2;
      }
      if (this.count > 0)
        this.count--;
      this.frame = frame;
      const spriteList = this.spriteManager.getSpriteList();
      for (let i = 0; i < spriteList.length; i++) {
        const s = spriteList[i];
        if (s.frame !== 0 && (s.type === SpriteConstants.SPRITE_AIRPLANE || s.type === SpriteConstants.SPRITE_HELICOPTER || s.type === SpriteConstants.SPRITE_SHIP || s.type === SpriteConstants.SPRITE_TRAIN) && SpriteUtils.checkSpriteCollision(this, s)) {
          s.explodeSprite();
        }
      }
      frame = getRandom(5);
      this.x += xDelta$1[frame];
      this.y += yDelta$1[frame];
      if (this.spriteNotInBounds())
        this.frame = 0;
      if (this.count !== 0 && getRandom(500) === 0)
        this.frame = 0;
      if (this.frame === 0)
        this._emitEvent(SPRITE_DYING);
      SpriteUtils.destroyMapTile(
        this.spriteManager,
        this.map,
        blockMaps,
        this.x,
        this.y
      );
      this._emitEvent(SPRITE_MOVED, { x: this.worldX, y: this.worldY });
    };
    Object.defineProperties(TornadoSprite, {
      ID: MiscUtils.makeConstantDescriptor(6),
      width: MiscUtils.makeConstantDescriptor(48),
      frames: MiscUtils.makeConstantDescriptor(3)
    });

    var __defProp$t = Object.defineProperty;
    var __name$t = (target, value) => __defProp$t(target, "name", { value, configurable: true });
    function TrainSprite(map, spriteManager, x, y) {
      this.init(SPRITE_TRAIN, map, spriteManager, x, y);
      this.width = 32;
      this.height = 32;
      this.xOffset = -16;
      this.yOffset = -16;
      this.frame = 1;
      this.dir = 4;
    }
    __name$t(TrainSprite, "TrainSprite");
    BaseSprite(TrainSprite);
    const tileDeltaX = [0, 16, 0, -16];
    const tileDeltaY = [-16, 0, 16, 0];
    const xDelta = [0, 4, 0, -4, 0];
    const yDelta = [-4, 0, 4, 0, 0];
    const TrainPic2 = [1, 2, 1, 2, 5];
    const NWSE = 3;
    const NESW = 4;
    const UNDERWATER = 5;
    const WEST = 3;
    const CANTMOVE = 4;
    TrainSprite.prototype.move = function(spriteCycle, disasterManager, blockMaps) {
      if (this.frame === NWSE || this.frame === NESW) {
        this.frame = TrainPic2[this.dir];
      }
      this.x += xDelta[this.dir];
      this.y += yDelta[this.dir];
      if ((spriteCycle & 3) === 0) {
        const dir = getRandom16() & 3;
        for (let i = dir; i < dir + 4; i++) {
          const dir2 = i & 3;
          if (this.dir !== CANTMOVE) {
            if (dir2 === (this.dir + 2 & 3))
              continue;
          }
          const tileValue = SpriteUtils.getTileValue(
            this.map,
            this.x + tileDeltaX[dir2],
            this.y + tileDeltaY[dir2]
          );
          if (tileValue >= RAILBASE && tileValue <= LASTRAIL || tileValue === RAILVPOWERH || tileValue === RAILHPOWERV) {
            if (this.dir !== dir2 && this.dir !== CANTMOVE) {
              if (this.dir + dir2 === WEST)
                this.frame = NWSE;
              else
                this.frame = NESW;
            } else {
              this.frame = TrainPic2[dir2];
            }
            if (tileValue === HRAIL || tileValue === VRAIL) {
              this.frame = UNDERWATER;
            }
            this.dir = dir2;
            return;
          }
        }
        if (this.dir === CANTMOVE) {
          this.frame = 0;
          return;
        }
        this.dir = CANTMOVE;
      }
    };
    TrainSprite.prototype.explodeSprite = function() {
      this.frame = 0;
      this.spriteManager.makeExplosionAt(this.x, this.y);
      this._emitEvent(TRAIN_CRASHED, {
        showable: true,
        x: this.worldX,
        y: this.worldY
      });
    };
    Object.defineProperties(TrainSprite, {
      ID: MiscUtils.makeConstantDescriptor(1),
      width: MiscUtils.makeConstantDescriptor(32),
      frames: MiscUtils.makeConstantDescriptor(5)
    });

    const SpriteManager = EventEmitter(function(map) {
      this.spriteList = [];
      this.map = map;
      this.spriteCycle = 0;
    });
    SpriteManager.prototype.getSprite = function(type) {
      const filteredList = this.spriteList.filter(function(s) {
        return s.frame !== 0 && s.type === type;
      });
      if (filteredList.length === 0)
        return null;
      return filteredList[0];
    };
    SpriteManager.prototype.getSpriteList = function() {
      return this.spriteList.slice();
    };
    SpriteManager.prototype.getSpritesInView = function(startX, startY, pixelWidth, pixelHeight) {
      startX = SpriteUtils.worldToPix(startX);
      startY = SpriteUtils.worldToPix(startY);
      const lastX = startX + pixelWidth;
      const lastY = startY + pixelHeight;
      return this.spriteList.filter(function(s) {
        const spriteLeft = s.x + s.xOffset;
        const spriteTop = s.y + s.yOffset;
        const spriteRight = s.x + s.xOffset + s.width;
        const spriteBottom = s.y + s.yOffset + s.width;
        const leftInBounds = spriteLeft >= startX && spriteLeft < lastX;
        const rightInBounds = spriteRight >= startX && spriteRight < lastX;
        const topInBounds = spriteTop >= startY && spriteTop < lastY;
        const bottomInBounds = spriteBottom >= startY && spriteBottom < lastY;
        return (leftInBounds || rightInBounds) && (topInBounds || bottomInBounds);
      });
    };
    SpriteManager.prototype.moveObjects = function(simData) {
      const disasterManager = simData.disasterManager;
      const blockMaps = simData.blockMaps;
      this.spriteCycle += 1;
      const list = this.spriteList.slice();
      for (let i = 0, l = list.length; i < l; i++) {
        const sprite = list[i];
        if (sprite.frame === 0)
          continue;
        sprite.move(this.spriteCycle, disasterManager, blockMaps);
      }
      this.pruneDeadSprites();
    };
    SpriteManager.prototype.makeSprite = function(type, x, y) {
      const newSprite = new constructors[type](this.map, this, x, y);
      for (let i = 0, l = CRASHES.length; i < l; i++) {
        newSprite.addEventListener(
          CRASHES[i],
          MiscUtils.reflectEvent.bind(this, CRASHES[i])
        );
      }
      if (type == SPRITE_HELICOPTER) {
        newSprite.addEventListener(
          HEAVY_TRAFFIC,
          MiscUtils.reflectEvent.bind(this, HEAVY_TRAFFIC)
        );
      }
      this.spriteList.push(newSprite);
      return newSprite;
    };
    SpriteManager.prototype.makeTornado = function() {
      let sprite = this.getSprite(SPRITE_TORNADO);
      if (sprite !== null) {
        sprite.count = 200;
        this._emitEvent(TORNADO_SIGHTED, {
          trackable: true,
          x: sprite.worldX,
          y: sprite.worldY,
          sprite
        });
        return;
      }
      const x = getRandom(SpriteUtils.worldToPix(this.map.width) - 800) + 400;
      const y = getRandom(SpriteUtils.worldToPix(this.map.height) - 200) + 100;
      sprite = this.makeSprite(SPRITE_TORNADO, x, y);
      this._emitEvent(TORNADO_SIGHTED, {
        trackable: true,
        x: sprite.worldX,
        y: sprite.worldY,
        sprite
      });
    };
    SpriteManager.prototype.makeExplosion = function(x, y) {
      if (this.map.testBounds(x, y)) {
        this.makeExplosionAt(SpriteUtils.worldToPix(x), SpriteUtils.worldToPix(y));
      }
    };
    SpriteManager.prototype.makeExplosionAt = function(x, y) {
      this.makeSprite(SPRITE_EXPLOSION, x, y);
    };
    SpriteManager.prototype.generatePlane = function(x, y) {
      if (this.getSprite(SPRITE_AIRPLANE) !== null)
        return;
      this.makeSprite(
        SPRITE_AIRPLANE,
        SpriteUtils.worldToPix(x),
        SpriteUtils.worldToPix(y)
      );
    };
    SpriteManager.prototype.generateTrain = function(census, x, y) {
      if (census.totalPop > 10 && this.getSprite(SPRITE_TRAIN) === null && getRandom(25) === 0) {
        this.makeSprite(
          SPRITE_TRAIN,
          SpriteUtils.worldToPix(x) + 8,
          SpriteUtils.worldToPix(y) + 8
        );
      }
    };
    SpriteManager.prototype.generateShip = function() {
      let x, y;
      if (getChance(3)) {
        for (x = 4; x < this.map.width - 2; x++) {
          if (this.map.getTileValue(x, 0) === CHANNEL) {
            this.makeShipHere(x, 0);
            return;
          }
        }
      }
      if (getChance(3)) {
        for (y = 1; y < this.map.height - 2; y++) {
          if (this.map.getTileValue(0, y) === CHANNEL) {
            this.makeShipHere(0, y);
            return;
          }
        }
      }
      if (getChance(3)) {
        for (x = 4; x < this.map.width - 2; x++) {
          if (this.map.getTileValue(x, this.map.height - 1) === CHANNEL) {
            this.makeShipHere(x, this.map.height - 1);
            return;
          }
        }
      }
      if (getChance(3)) {
        for (y = 1; y < this.map.height - 2; y++) {
          if (this.map.getTileValue(this.map.width - 1, y) === CHANNEL) {
            this.makeShipHere(this.map.width - 1, y);
            return;
          }
        }
      }
    };
    SpriteManager.prototype.getBoatDistance = function(x, y) {
      let dist = 99999;
      const pixelX = SpriteUtils.worldToPix(x) + 8;
      const pixelY = SpriteUtils.worldToPix(y) + 8;
      for (let i = 0, l = this.spriteList.length; i < l; i++) {
        const sprite = this.spriteList[i];
        if (sprite.type === SPRITE_SHIP && sprite.frame !== 0) {
          const sprDist = Math.abs(sprite.x - pixelX) + Math.abs(sprite.y - pixelY);
          dist = Math.min(dist, sprDist);
        }
      }
      return dist;
    };
    SpriteManager.prototype.makeShipHere = function(x, y) {
      this.makeSprite(
        SPRITE_SHIP,
        SpriteUtils.worldToPix(x),
        SpriteUtils.worldToPix(y)
      );
    };
    SpriteManager.prototype.generateCopter = function(x, y) {
      if (this.getSprite(SPRITE_HELICOPTER) !== null)
        return;
      this.makeSprite(
        SPRITE_HELICOPTER,
        SpriteUtils.worldToPix(x),
        SpriteUtils.worldToPix(y)
      );
    };
    SpriteManager.prototype.makeMonsterAt = function(x, y) {
      const sprite = this.makeSprite(
        SPRITE_MONSTER,
        SpriteUtils.worldToPix(x),
        SpriteUtils.worldToPix(y)
      );
      this._emitEvent(MONSTER_SIGHTED, {
        trackable: true,
        x,
        y,
        sprite
      });
    };
    SpriteManager.prototype.makeMonster = function() {
      const sprite = this.getSprite(SPRITE_MONSTER);
      if (sprite !== null) {
        sprite.soundCount = 1;
        sprite.count = 1e3;
        sprite.destX = SpriteUtils.worldToPix(this.map.pollutionMaxX);
        sprite.destY = SpriteUtils.worldToPix(this.map.pollutionMaxY);
      }
      let done = 0;
      for (let i = 0; i < 300; i++) {
        const x = getRandom(this.map.width - 20) + 10;
        const y = getRandom(this.map.height - 10) + 5;
        const tile = this.map.getTile(x, y);
        if (tile.getValue() === RIVER) {
          this.makeMonsterAt(x, y);
          done = 1;
          break;
        }
      }
      if (done === 0)
        this.makeMonsterAt(60, 50);
    };
    SpriteManager.prototype.pruneDeadSprites = function(type) {
      this.spriteList = this.spriteList.filter(function(s) {
        return s.frame !== 0;
      });
    };
    var constructors = {};
    constructors[SPRITE_TRAIN] = TrainSprite;
    constructors[SPRITE_SHIP] = BoatSprite;
    constructors[SPRITE_MONSTER] = MonsterSprite;
    constructors[SPRITE_HELICOPTER] = CopterSprite;
    constructors[SPRITE_AIRPLANE] = AirplaneSprite;
    constructors[SPRITE_TORNADO] = TornadoSprite;
    constructors[SPRITE_EXPLOSION] = ExplosionSprite;

    var __defProp$s = Object.defineProperty;
    var __name$s = (target, value) => __defProp$s(target, "name", { value, configurable: true });
    const emptyStadiumFound = /* @__PURE__ */ __name$s(function(map, x, y, simData) {
      simData.census.stadiumPop += 1;
      if (map.getTile(x, y).isPowered()) {
        if ((simData.cityTime + x + y & 31) === 0) {
          map.putZone(x, y, FULLSTADIUM, 4);
          map.addTileFlags(x, y, POWERBIT);
          map.setTile(x + 1, y, FOOTBALLGAME1, ANIMBIT);
          map.setTile(x + 1, y + 1, FOOTBALLGAME2, ANIMBIT);
        }
      }
    }, "emptyStadiumFound");
    const fullStadiumFound = /* @__PURE__ */ __name$s(function(map, x, y, simData) {
      simData.census.stadiumPop += 1;
      const isPowered = map.getTile(x, y).isPowered();
      if ((simData.cityTime + x + y & 7) === 0) {
        map.putZone(x, y, STADIUM, 4);
        if (isPowered)
          map.addTileFlags(x, y, POWERBIT);
      }
    }, "fullStadiumFound");
    const Stadium = {
      registerHandlers: function(mapScanner, repairManager) {
        mapScanner.addAction(STADIUM, emptyStadiumFound);
        mapScanner.addAction(FULLSTADIUM, fullStadiumFound);
        repairManager.addAction(STADIUM, 15, 4);
      }
    };

    var __defProp$r = Object.defineProperty;
    var __name$r = (target, value) => __defProp$r(target, "name", { value, configurable: true });
    const railFound = /* @__PURE__ */ __name$r(function(map, x, y, simData) {
      simData.census.railTotal += 1;
      simData.spriteManager.generateTrain(simData.census, x, y);
      if (simData.budget.shouldDegradeRoad()) {
        if (getChance(511)) {
          const currentTile = map.getTile(x, y);
          if (currentTile.isConductive())
            return;
          if (simData.budget.roadEffect < (getRandom16() & 31)) {
            const mapValue = currentTile.getValue();
            if (mapValue < RAILBASE + 2) {
              map.setTile(x, y, RIVER, 0);
            } else
              map.setTo(x, y, TileUtils.randomRubble());
          }
        }
      }
    }, "railFound");
    const airportFound = /* @__PURE__ */ __name$r(function(map, x, y, simData) {
      simData.census.airportPop += 1;
      const tile = map.getTile(x, y);
      if (tile.isPowered()) {
        if (map.getTileValue(x + 1, y - 1) === RADAR) {
          map.setTile(x + 1, y - 1, RADAR0, CONDBIT | ANIMBIT | BURNBIT);
        }
        if (getRandom(5) === 0) {
          simData.spriteManager.generatePlane(x, y);
          return;
        }
        if (getRandom(12) === 0)
          simData.spriteManager.generateCopter(x, y);
      } else {
        map.setTile(x + 1, y - 1, RADAR, CONDBIT | BURNBIT);
      }
    }, "airportFound");
    const portFound = /* @__PURE__ */ __name$r(function(map, x, y, simData) {
      simData.census.seaportPop += 1;
      const tile = map.getTile(x, y);
      if (tile.isPowered() && simData.spriteManager.getSprite(SPRITE_SHIP) === null) {
        simData.spriteManager.generateShip();
      }
    }, "portFound");
    const Transport = {
      registerHandlers: function(mapScanner, repairManager) {
        mapScanner.addAction(TileUtils.isRail, railFound);
        mapScanner.addAction(PORT, portFound);
        mapScanner.addAction(AIRPORT, airportFound);
        repairManager.addAction(PORT, 15, 4);
        repairManager.addAction(AIRPORT, 7, 6);
      }
    };

    const Valves = EventEmitter(function() {
      this.resValve = 0;
      this.comValve = 0;
      this.indValve = 0;
      this.resCap = false;
      this.comCap = false;
      this.indCap = false;
    });
    const RES_VALVE_RANGE = 2e3;
    const COM_VALVE_RANGE = 1500;
    const IND_VALVE_RANGE = 1500;
    const taxTable = [
      200,
      150,
      120,
      100,
      80,
      50,
      30,
      0,
      -10,
      -40,
      -100,
      -150,
      -200,
      -250,
      -300,
      -350,
      -400,
      -450,
      -500,
      -550,
      -600
    ];
    const extMarketParamTable = [1.2, 1.1, 0.98];
    Valves.prototype.save = function(saveData) {
      saveData.resValve = this.resValve;
      saveData.comValve = this.comValve;
      saveData.indValve = this.indValve;
    };
    Valves.prototype.load = function(saveData) {
      this.resValve = saveData.resValve;
      this.comValve = saveData.comValve;
      this.indValve = saveData.indValve;
      this._emitEvent(VALVES_UPDATED);
    };
    Valves.prototype.setValves = function(gameLevel, census, budget) {
      const resPopDenom = 8;
      const birthRate = 0.02;
      const labourBaseMax = 1.3;
      const internalMarketDenom = 3.7;
      const projectedIndPopMin = 5;
      const resRatioDefault = 1.3;
      const resRatioMax = 2;
      const comRatioMax = 2;
      const indRatioMax = 2;
      const taxMax = 20;
      const taxTableScale = 600;
      let employment, labourBase;
      const normalizedResPop = census.resPop / resPopDenom;
      census.totalPop = Math.round(normalizedResPop + census.comPop + census.indPop);
      if (census.resPop > 0) {
        employment = (census.comHist10[1] + census.indHist10[1]) / normalizedResPop;
      } else
        employment = 1;
      const migration = normalizedResPop * (employment - 1);
      const births = normalizedResPop * birthRate;
      const projectedResPop = normalizedResPop + migration + births;
      labourBase = census.comHist10[1] + census.indHist10[1];
      if (labourBase > 0)
        labourBase = census.resHist10[1] / labourBase;
      else
        labourBase = 1;
      labourBase = MiscUtils.clamp(labourBase, 0, labourBaseMax);
      const internalMarket = (normalizedResPop + census.comPop + census.indPop) / internalMarketDenom;
      const projectedComPop = internalMarket * labourBase;
      let projectedIndPop = census.indPop * labourBase * extMarketParamTable[gameLevel];
      projectedIndPop = Math.max(projectedIndPop, projectedIndPopMin);
      let resRatio;
      if (normalizedResPop > 0)
        resRatio = projectedResPop / normalizedResPop;
      else
        resRatio = resRatioDefault;
      let comRatio;
      if (census.comPop > 0)
        comRatio = projectedComPop / census.comPop;
      else
        comRatio = projectedComPop;
      let indRatio;
      if (census.indPop > 0)
        indRatio = projectedIndPop / census.indPop;
      else
        indRatio = projectedIndPop;
      resRatio = Math.min(resRatio, resRatioMax);
      comRatio = Math.min(comRatio, comRatioMax);
      indRatio = Math.min(indRatio, indRatioMax);
      const z = Math.min(budget.cityTax + gameLevel, taxMax);
      resRatio = (resRatio - 1) * taxTableScale + taxTable[z];
      comRatio = (comRatio - 1) * taxTableScale + taxTable[z];
      indRatio = (indRatio - 1) * taxTableScale + taxTable[z];
      this.resValve = MiscUtils.clamp(
        this.resValve + Math.round(resRatio),
        -RES_VALVE_RANGE,
        RES_VALVE_RANGE
      );
      this.comValve = MiscUtils.clamp(
        this.comValve + Math.round(comRatio),
        -COM_VALVE_RANGE,
        COM_VALVE_RANGE
      );
      this.indValve = MiscUtils.clamp(
        this.indValve + Math.round(indRatio),
        -IND_VALVE_RANGE,
        IND_VALVE_RANGE
      );
      if (this.resCap && this.resValve > 0)
        this.resValve = 0;
      if (this.comCap && this.comValve > 0)
        this.comValve = 0;
      if (this.indCap && this.indValve > 0)
        this.indValve = 0;
      this._emitEvent(VALVES_UPDATED);
    };

    var __defProp$q = Object.defineProperty;
    var __name$q = (target, value) => __defProp$q(target, "name", { value, configurable: true });
    const Simulation = EventEmitter(function(gameMap, gameLevel, speed, savedGame) {
      this.reset(gameMap, gameLevel, speed);
      Commercial.registerHandlers(this._mapScanner, this._repairManager);
      EmergencyServices.registerHandlers(this._mapScanner, this._repairManager);
      Industrial.registerHandlers(this._mapScanner, this._repairManager);
      MiscTiles.registerHandlers(this._mapScanner, this._repairManager);
      Road.registerHandlers(this._mapScanner, this._repairManager);
      Residential.registerHandlers(this._mapScanner, this._repairManager);
      Stadium.registerHandlers(this._mapScanner, this._repairManager);
      Transport.registerHandlers(this._mapScanner, this._repairManager);
      if (savedGame) {
        this.load(savedGame);
      }
      this.init();
    });
    Simulation.prototype.reset = function(gameMap, gameLevel = Simulation.LEVEL_EASY, speed = Simulation.SPEED_MED) {
      this._map = gameMap;
      this.setLevel(gameLevel);
      this.setSpeed(speed);
      this._phaseCycle = 0;
      this._simCycle = 0;
      this._cityTime = 0;
      this._cityPopLast = 0;
      this._messageLast = REACHED_VILLAGE;
      this._startingYear = 1;
      this._lastTickTime = -1;
      this._cityYearLast = -1;
      this._cityMonthLast = -1;
      this._lastPowerMessage = null;
      this.evaluation = new Evaluation(this._gameLevel);
      this._valves = new Valves();
      this.budget = new Budget();
      this._census = new Census();
      this._powerManager = new PowerManager(this._map);
      this.spriteManager = new SpriteManager(this._map);
      this._mapScanner = new MapScanner(this._map);
      this._repairManager = new RepairManager(this._map);
      this._traffic = new Traffic(this._map, this.spriteManager);
      this.disasterManager = new DisasterManager(
        this._map,
        this.spriteManager,
        this._gameLevel
      );
      this.blockMaps = {
        cityCentreDistScoreMap: new BlockMap(this._map.width, this._map.height, 8),
        crimeRateMap: new BlockMap(this._map.width, this._map.height, 2),
        fireStationMap: new BlockMap(this._map.width, this._map.height, 8),
        fireStationEffectMap: new BlockMap(this._map.width, this._map.height, 8),
        landValueMap: new BlockMap(this._map.width, this._map.height, 2),
        policeStationMap: new BlockMap(this._map.width, this._map.height, 8),
        policeStationEffectMap: new BlockMap(this._map.width, this._map.height, 8),
        pollutionDensityMap: new BlockMap(this._map.width, this._map.height, 2),
        populationDensityMap: new BlockMap(this._map.width, this._map.height, 2),
        rateOfGrowthMap: new BlockMap(this._map.width, this._map.height, 8),
        terrainDensityMap: new BlockMap(this._map.width, this._map.height, 4),
        trafficDensityMap: new BlockMap(this._map.width, this._map.height, 2),
        tempMap1: new BlockMap(this._map.width, this._map.height, 2),
        tempMap2: new BlockMap(this._map.width, this._map.height, 2),
        tempMap3: new BlockMap(this._map.width, this._map.height, 4)
      };
      this.budget.setFunds(999999999);
      this._census.totalPop = 1;
      this._clearCensus();
      const evaluationEvents = [
        "CLASSIFICATION_UPDATED",
        "POPULATION_UPDATED",
        "SCORE_UPDATED"
      ].map(function(m) {
        return Messages[m];
      });
      for (var i = 0, l = evaluationEvents.length; i < l; i++) {
        this.evaluation.addEventListener(
          evaluationEvents[i],
          MiscUtils.reflectEvent.bind(this, evaluationEvents[i])
        );
      }
      this._powerManager.addEventListener(
        NOT_ENOUGH_POWER,
        function(e) {
          const d = new Date();
          if (this._lastPowerMessage === null || d - this._lastPowerMessage > 1e3 * 60 * 2) {
            this._emitEvent(FRONT_END_MESSAGE, {
              subject: NOT_ENOUGH_POWER
            });
            this._lastPowerMessage = d;
          }
        }.bind(this)
      );
      this.budget.addEventListener(
        FUNDS_CHANGED,
        MiscUtils.reflectEvent.bind(this, FUNDS_CHANGED)
      );
      this.budget.addEventListener(
        BUDGET_NEEDED,
        MiscUtils.reflectEvent.bind(this, BUDGET_NEEDED)
      );
      this.budget.addEventListener(
        NO_MONEY,
        this._wrapMessage.bind(this, NO_MONEY)
      );
      this._valves.addEventListener(
        VALVES_UPDATED,
        this._onValveChange.bind(this)
      );
      for (i = 0, l = DISASTER_MESSAGES.length; i < l; i++) {
        this.spriteManager.addEventListener(
          DISASTER_MESSAGES[i],
          this._wrapMessage.bind(this, DISASTER_MESSAGES[i])
        );
        this.disasterManager.addEventListener(
          DISASTER_MESSAGES[i],
          this._wrapMessage.bind(this, DISASTER_MESSAGES[i])
        );
      }
      for (i = 0, l = CRASHES.length; i < l; i++) {
        this.spriteManager.addEventListener(
          CRASHES[i],
          this._wrapMessage.bind(this, CRASHES[i])
        );
      }
      this.spriteManager.addEventListener(
        HEAVY_TRAFFIC,
        this._wrapMessage.bind(this, HEAVY_TRAFFIC)
      );
      this._powerManager.registerHandlers(this._mapScanner, this._repairManager);
    };
    Simulation.prototype.setLevel = function(l) {
      if (l !== Simulation.LEVEL_EASY && l !== Simulation.LEVEL_MED && l !== Simulation.LEVEL_HARD) {
        throw new Error("Invalid level!");
      }
      this._gameLevel = l;
    };
    Simulation.prototype.setSpeed = function(s) {
      if (s !== Simulation.SPEED_PAUSED && s !== Simulation.SPEED_SLOW && s !== Simulation.SPEED_MED && s !== Simulation.SPEED_FAST) {
        throw new Error("Invalid speed!");
      }
      this._speed = s;
    };
    Simulation.prototype.isPaused = function() {
      return this._speed === Simulation.SPEED_PAUSED;
    };
    const saveProps = ["_cityTime", "_speed", "_gameLevel"];
    Simulation.prototype.save = function(saveData) {
      for (let i = 0, l = saveProps.length; i < l; i++) {
        saveData[saveProps[i]] = this[saveProps[i]];
      }
      this._map.save(saveData);
      this.evaluation.save(saveData);
      this._valves.save(saveData);
      this.budget.save(saveData);
      this._census.save(saveData);
    };
    Simulation.prototype.load = function(saveData) {
      for (let i = 0, l = saveProps.length; i < l; i++) {
        this[saveProps[i]] = saveData[saveProps[i]] || this[saveProps[i]];
      }
      this._map.load(saveData);
      this.evaluation.load(saveData);
      this._valves.load(saveData);
      this.budget.load(saveData);
      this._census.load(saveData);
    };
    Simulation.prototype.simTick = function() {
      this._simFrame();
      this._updateTime();
    };
    Simulation.prototype._simFrame = function() {
      if (this.budget.awaitingValues)
        return;
      let threshold = 100;
      switch (this._speed) {
        case Simulation.SPEED_PAUSED:
          return;
        case Simulation.SPEED_SLOW:
          break;
        case Simulation.SPEED_MED:
          threshold = 50;
          break;
        case Simulation.SPEED_FAST:
          threshold = 10;
          break;
        default:
          console.warn("Unexpected speed (" + this._speed + "): defaulting to slow");
      }
      const d = new Date().getTime();
      if (d - this._lastTickTime < threshold)
        return;
      const simData = this._constructSimData();
      this._simulate(simData);
      this._lastTickTime = new Date().getTime();
    };
    Simulation.prototype._clearCensus = function() {
      this._census.clearCensus();
      this._powerManager.clearPowerStack();
      this.blockMaps.fireStationMap.clear();
      this.blockMaps.policeStationMap.clear();
    };
    Simulation.prototype._constructSimData = function() {
      return {
        blockMaps: this.blockMaps,
        budget: this.budget,
        census: this._census,
        cityTime: this._cityTime,
        disasterManager: this.disasterManager,
        gameLevel: this._gameLevel,
        repairManager: this._repairManager,
        powerManager: this._powerManager,
        simulator: this,
        spriteManager: this.spriteManager,
        trafficManager: this._traffic,
        valves: this._valves
      };
    };
    Simulation.prototype.init = function() {
      const simData = this._constructSimData();
      this._mapScanner.mapScan(0, this._map.width, simData);
      this._powerManager.doPowerScan(this._census);
      BlockMapUtils.pollutionTerrainLandValueScan(
        this._map,
        this._census,
        this.blockMaps
      );
      BlockMapUtils.crimeScan(this._census, this.blockMaps);
      BlockMapUtils.populationDensityScan(this._map, this.blockMaps);
      BlockMapUtils.fireAnalysis(this.blockMaps);
    };
    const speedPowerScan = [2, 4, 5];
    const speedPollutionTerrainLandValueScan = [2, 7, 17];
    const speedCrimeScan = [1, 8, 18];
    const speedPopulationDensityScan = [1, 9, 19];
    const speedFireAnalysis = [1, 10, 20];
    const CENSUS_FREQUENCY_10 = 4;
    const CENSUS_FREQUENCY_120 = CENSUS_FREQUENCY_10 * 10;
    const TAX_FREQUENCY = 48;
    const simulate = /* @__PURE__ */ __name$q(function(simData) {
      this._phaseCycle &= 15;
      const speedIndex = this._speed - 1;
      switch (this._phaseCycle) {
        case 0:
          if (++this._simCycle > 1023)
            this._simCycle = 0;
          this._cityTime++;
          if ((this._simCycle & 1) === 0) {
            this._valves.setValves(this._gameLevel, this._census, this.budget);
          }
          this._clearCensus();
          break;
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
          this._mapScanner.mapScan(
            (this._phaseCycle - 1) * this._map.width / 8,
            this._phaseCycle * this._map.width / 8,
            simData
          );
          break;
        case 9:
          if (this._cityTime % CENSUS_FREQUENCY_10 === 0) {
            this._census.take10Census(this.budget);
          }
          if (this._cityTime % CENSUS_FREQUENCY_120 === 0) {
            this._census.take120Census(this.budget);
          }
          if (this._cityTime % TAX_FREQUENCY === 0) {
            this.budget.collectTax(this._gameLevel, this._census);
            this.evaluation.cityEvaluation(simData);
          }
          break;
        case 10:
          if (this._simCycle % 5 === 0) {
            BlockMapUtils.neutraliseRateOfGrowthMap(simData.blockMaps);
          }
          BlockMapUtils.neutraliseTrafficMap(this.blockMaps);
          this._sendMessages();
          break;
        case 11:
          if (this._simCycle % speedPowerScan[speedIndex] === 0) {
            this._powerManager.doPowerScan(this._census);
          }
          break;
        case 12:
          if (this._simCycle % speedPollutionTerrainLandValueScan[speedIndex] === 0) {
            BlockMapUtils.pollutionTerrainLandValueScan(
              this._map,
              this._census,
              this.blockMaps
            );
          }
          break;
        case 13:
          if (this._simCycle % speedCrimeScan[speedIndex] === 0) {
            BlockMapUtils.crimeScan(this._census, this.blockMaps);
          }
          break;
        case 14:
          if (this._simCycle % speedPopulationDensityScan[speedIndex] === 0) {
            BlockMapUtils.populationDensityScan(this._map, this.blockMaps);
          }
          break;
        case 15:
          if (this._simCycle % speedFireAnalysis[speedIndex] === 0) {
            BlockMapUtils.fireAnalysis(this.blockMaps);
          }
          this.disasterManager.doDisasters(this._census);
          break;
      }
      this._phaseCycle = this._phaseCycle + 1 & 15;
    }, "simulate");
    Simulation.prototype._simulate = function(simData) {
      this.evaluation.cityEvaluation(simData);
      this._simulate = simulate;
      this._simulate(simData);
    };
    Simulation.prototype._wrapMessage = function(message, data) {
      this._emitEvent(FRONT_END_MESSAGE, { subject: message, data });
    };
    Simulation.prototype._sendMessages = function() {
      this._checkGrowth();
      const totalZonePop = this._census.resZonePop + this._census.comZonePop + this._census.indZonePop;
      const powerPop = this._census.nuclearPowerPop + this._census.coalPowerPop;
      switch (this._cityTime & 63) {
        case 1:
          if (Math.floor(totalZonePop / 4) >= this._census.resZonePop) {
            this._emitEvent(FRONT_END_MESSAGE, {
              subject: NEED_MORE_RESIDENTIAL
            });
          }
          break;
        case 5:
          if (Math.floor(totalZonePop / 8) >= this._census.comZonePop) {
            this._emitEvent(FRONT_END_MESSAGE, {
              subject: NEED_MORE_COMMERCIAL
            });
          }
          break;
        case 10:
          if (Math.floor(totalZonePop / 8) >= this._census.indZonePop) {
            this._emitEvent(FRONT_END_MESSAGE, {
              subject: NEED_MORE_INDUSTRIAL
            });
          }
          break;
        case 14:
          if (totalZonePop > 10 && totalZonePop * 2 > this._census.roadTotal) {
            this._emitEvent(FRONT_END_MESSAGE, {
              subject: NEED_MORE_ROADS
            });
          }
          break;
        case 18:
          if (totalZonePop > 50 && totalZonePop > this._census.railTotal) {
            this._emitEvent(FRONT_END_MESSAGE, {
              subject: NEED_MORE_RAILS
            });
          }
          break;
        case 22:
          if (totalZonePop > 10 && powerPop === 0) {
            this._emitEvent(FRONT_END_MESSAGE, {
              subject: NEED_ELECTRICITY
            });
          }
          break;
        case 26:
          if (this._census.resPop > 500 && this._census.stadiumPop === 0) {
            this._emitEvent(FRONT_END_MESSAGE, {
              subject: NEED_STADIUM
            });
            this._valves.resCap = true;
          } else {
            this._valves.resCap = false;
          }
          break;
        case 28:
          if (this._census.indPop > 70 && this._census.seaportPop === 0) {
            this._emitEvent(FRONT_END_MESSAGE, {
              subject: NEED_SEAPORT
            });
            this._valves.indCap = true;
          } else {
            this._valves.indCap = false;
          }
          break;
        case 30:
          if (this._census.comPop > 100 && this._census.airportPop === 0) {
            this._emitEvent(FRONT_END_MESSAGE, {
              subject: NEED_AIRPORT
            });
            this._valves.comCap = true;
          } else {
            this._valves.comCap = false;
          }
          break;
        case 32:
          var zoneCount = this._census.unpoweredZoneCount + this._census.poweredZoneCount;
          if (zoneCount > 0) {
            if (this._census.poweredZoneCount / zoneCount < 0.7 && powerPop > 0) {
              const d = new Date();
              if (this._lastPowerMessage === null || d - this._lastPowerMessage > 1e3 * 60 * 2) {
                this._emitEvent(FRONT_END_MESSAGE, {
                  subject: BLACKOUTS_REPORTED
                });
                this._lastPowerMessage = d;
              }
            }
          }
          break;
        case 35:
          if (this._census.pollutionAverage > 60) {
            this._emitEvent(FRONT_END_MESSAGE, {
              subject: HIGH_POLLUTION,
              data: { x: this._map.pollutionMaxX, y: this._map.pollutionMaxY }
            });
          }
          break;
        case 42:
          if (this._census.crimeAverage > 100) {
            this._emitEvent(FRONT_END_MESSAGE, {
              subject: HIGH_CRIME
            });
          }
          break;
        case 45:
          if (this._census.totalPop > 60 && this._census.fireStationPop === 0) {
            this._emitEvent(FRONT_END_MESSAGE, {
              subject: NEED_FIRE_STATION
            });
          }
          break;
        case 48:
          if (this._census.totalPop > 60 && this._census.policeStationPop === 0) {
            this._emitEvent(FRONT_END_MESSAGE, {
              subject: NEED_POLICE_STATION
            });
          }
          break;
        case 51:
          if (this.budget.cityTax > 12) {
            this._emitEvent(FRONT_END_MESSAGE, {
              subject: TAX_TOO_HIGH
            });
          }
          break;
        case 54:
          if (this.budget.roadEffect < Math.floor(5 * this.budget.MAX_ROAD_EFFECT / 8) && this._census.roadTotal > 30) {
            this._emitEvent(FRONT_END_MESSAGE, {
              subject: ROAD_NEEDS_FUNDING
            });
          }
          break;
        case 57:
          if (this.budget.fireEffect < Math.floor(7 * this.budget.MAX_FIRE_STATION_EFFECT / 10) && this._census.totalPop > 20) {
            this._emitEvent(FRONT_END_MESSAGE, {
              subject: FIRE_STATION_NEEDS_FUNDING
            });
          }
          break;
        case 60:
          if (this.budget.policeEffect < Math.floor(7 * this.budget.MAX_POLICE_STATION_EFFECT / 10) && this._census.totalPop > 20) {
            this._emitEvent(FRONT_END_MESSAGE, {
              subject: POLICE_NEEDS_FUNDING
            });
          }
          break;
        case 63:
          if (this._census.trafficAverage > 60) {
            this._emitEvent(FRONT_END_MESSAGE, {
              subject: TRAFFIC_JAMS
            });
          }
          break;
      }
    };
    Simulation.prototype._checkGrowth = function() {
      if ((this._cityTime & 3) !== 0)
        return;
      let message = "";
      const cityPop = this.evaluation.getPopulation(this._census);
      if (cityPop !== this._cityPopLast) {
        const lastClass = this.evaluation.getCityClass(this._cityPopLast);
        const newClass = this.evaluation.getCityClass(cityPop);
        if (lastClass !== newClass) {
          switch (newClass) {
            case Evaluation.CC_VILLAGE:
              break;
            case Evaluation.CC_TOWN:
              message = REACHED_TOWN;
              break;
            case Evaluation.CC_CITY:
              message = REACHED_CITY;
              break;
            case Evaluation.CC_CAPITAL:
              message = REACHED_CAPITAL;
              break;
            case Evaluation.CC_METROPOLIS:
              message = REACHED_METROPOLIS;
              break;
            case Evaluation.CC_MEGALOPOLIS:
              message = REACHED_MEGALOPOLIS;
              break;
          }
        }
      }
      if (message !== "" && message !== this._messageLast) {
        this._emitEvent(FRONT_END_MESSAGE, { subject: message });
        this._messageLast = message;
      }
      this._cityPopLast = cityPop;
    };
    Simulation.prototype._onValveChange = function() {
      this._resLast = this._valves.resValve;
      this._comLast = this._valves.comValve;
      this._indLast = this._valves.indValve;
      this._emitEvent(VALVES_UPDATED, {
        residential: this._valves.resValve,
        commercial: this._valves.comValve,
        industrial: this._valves.indValve
      });
    };
    Simulation.prototype.getDate = function() {
      const year = Math.floor(this._cityTime / 48) + this._startingYear;
      const month = Math.floor(this._cityTime % 48) >> 2;
      return { month, year };
    };
    Simulation.prototype._setYear = function(year) {
      if (year < this._startingYear)
        year = this._startingYear;
      year = year - this._startingYear - this._cityTime / 48;
      this._cityTime += year * 48;
      this._updateTime();
    };
    Simulation.prototype._updateTime = function() {
      const megalinium = 1e6;
      const cityYear = Math.floor(this._cityTime / 48) + this._startingYear;
      const cityMonth = Math.floor(this._cityTime % 48) >> 2;
      if (cityYear >= megalinium) {
        this.setYear(startingYear);
        return;
      }
      if (this._cityYearLast !== cityYear || this._cityMonthLast !== cityMonth) {
        this._cityYearLast = cityYear;
        this._cityMonthLast = cityMonth;
        this._emitEvent(DATE_UPDATED, { month: cityMonth, year: cityYear });
      }
    };
    Object.defineProperties(Simulation, {
      LEVEL_EASY: MiscUtils.makeConstantDescriptor(0),
      LEVEL_MED: MiscUtils.makeConstantDescriptor(1),
      LEVEL_HARD: MiscUtils.makeConstantDescriptor(2),
      SPEED_PAUSED: MiscUtils.makeConstantDescriptor(0),
      SPEED_SLOW: MiscUtils.makeConstantDescriptor(1),
      SPEED_MED: MiscUtils.makeConstantDescriptor(2),
      SPEED_FAST: MiscUtils.makeConstantDescriptor(3)
    });

    var __defProp$p = Object.defineProperty;
    var __name$p = (target, value) => __defProp$p(target, "name", { value, configurable: true });
    const getSavedGame = /* @__PURE__ */ __name$p(function() {
      let savedGame = window.localStorage.getItem(this.KEY);
      if (savedGame !== null) {
        savedGame = JSON.parse(savedGame);
        if (savedGame.version !== this.CURRENT_VERSION) {
          this.transitionOldSave(savedGame);
        }
        savedGame.isSavedGame = true;
      }
      return savedGame;
    }, "getSavedGame");
    const saveGame = /* @__PURE__ */ __name$p(function(gameData) {
      gameData.version = this.CURRENT_VERSION;
      gameData = JSON.stringify(gameData);
      window.localStorage.setItem(this.KEY, gameData);
    }, "saveGame");
    const clear$1 = /* @__PURE__ */ __name$p(function() {
      window.localStorage.removeItem(this.KEY);
    }, "clear");
    const transitionOldSave = /* @__PURE__ */ __name$p(function(savedGame) {
      switch (savedGame.version) {
        case 1:
          savedGame.everClicked = false;
        case 2:
          savedGame.pollutionMaxX = Math.floor(savedGame.width / 2);
          savedGame.pollutionMaxY = Math.floor(savedGame.height / 2);
          savedGame.cityCentreX = Math.floor(savedGame.width / 2);
          savedGame.cityCentreY = Math.floor(savedGame.height / 2);
          break;
        default:
          throw new Error("Unknown save version!");
      }
    }, "transitionOldSave");
    const Storage = {
      getSavedGame,
      saveGame,
      clear: clear$1,
      transitionOldSave
    };
    Object.defineProperty(
      Storage,
      "CURRENT_VERSION",
      MiscUtils.makeConstantDescriptor(3)
    );
    Object.defineProperty(
      Storage,
      "KEY",
      MiscUtils.makeConstantDescriptor("micropolisJSGame")
    );
    Object.defineProperty(
      Storage,
      "canStore",
      MiscUtils.makeConstantDescriptor(window.localStorage !== void 0)
    );

    var __defProp$o = Object.defineProperty;
    var __name$o = (target, value) => __defProp$o(target, "name", { value, configurable: true });
    function WorldEffects(map) {
      this._map = map;
      this._data = {};
    }
    __name$o(WorldEffects, "WorldEffects");
    const toKey$1 = /* @__PURE__ */ __name$o(function(x, y) {
      return [x, y].join(",");
    }, "toKey");
    const fromKey = /* @__PURE__ */ __name$o(function(k) {
      k = k.split(",");
      return {
        x: k[0] - 0,
        y: k[1] - 0,
        toString: function() {
          return "World effect coord: (" + k[0] + ", " + k[1] + ")";
        }
      };
    }, "fromKey");
    WorldEffects.prototype.clear = function() {
      this._data = [];
    };
    WorldEffects.prototype.getTile = function(x, y) {
      const key = toKey$1(x, y);
      let tile = this._data[key];
      if (tile === void 0)
        tile = this._map.getTile(x, y);
      return tile;
    };
    WorldEffects.prototype.getTileValue = function(x, y) {
      return this.getTile(x, y).getValue();
    };
    WorldEffects.prototype.setTile = function(x, y, value, flags) {
      if (flags !== void 0 && value instanceof Tile) {
        throw new Error("Flags supplied with already defined tile");
      }
      if (!this._map.testBounds(x, y)) {
        throw new Error(
          "WorldEffects setTile called with invalid bounds " + x + ", " + y
        );
      }
      if (flags === void 0 && !(value instanceof Tile))
        value = new Tile(value);
      else if (flags !== void 0)
        value = new Tile(value, flags);
      const key = toKey$1(x, y);
      this._data[key] = value;
    };
    WorldEffects.prototype.apply = function() {
      const keys = Object.keys(this._data);
      for (let i = 0, l = keys.length; i < l; i++) {
        const coords = fromKey(keys[i]);
        this._map.setTo(coords, this._data[keys[i]]);
      }
    };

    var __defProp$n = Object.defineProperty;
    var __name$n = (target, value) => __defProp$n(target, "name", { value, configurable: true });
    const init = /* @__PURE__ */ __name$n(function(cost, map, shouldAutoBulldoze, isDraggable) {
      isDraggable = isDraggable || false;
      Object.defineProperty(
        this,
        "toolCost",
        MiscUtils.makeConstantDescriptor(cost)
      );
      this.result = null;
      this.isDraggable = isDraggable;
      this._shouldAutoBulldoze = shouldAutoBulldoze;
      this._map = map;
      this._worldEffects = new WorldEffects(map);
      this._applicationCost = 0;
    }, "init");
    const clear = /* @__PURE__ */ __name$n(function() {
      this._applicationCost = 0;
      this._worldEffects.clear();
    }, "clear");
    const addCost = /* @__PURE__ */ __name$n(function(cost) {
      this._applicationCost += cost;
    }, "addCost");
    const doAutoBulldoze = /* @__PURE__ */ __name$n(function(x, y) {
      let tile = this._worldEffects.getTile(x, y);
      if (tile.isBulldozable()) {
        tile = TileUtils.normalizeRoad(tile.getValue());
        if (tile >= TINYEXP && tile <= LASTTINYEXP || tile < HBRIDGE && tile !== DIRT) {
          this.addCost(1);
          this._worldEffects.setTile(x, y, DIRT);
        }
      }
    }, "doAutoBulldoze");
    const apply = /* @__PURE__ */ __name$n(function(budget) {
      this._worldEffects.apply();
      budget.spend(this._applicationCost);
      this.clear();
    }, "apply");
    const modifyIfEnoughFunding = /* @__PURE__ */ __name$n(function(budget) {
      if (this.result !== this.TOOLRESULT_OK) {
        this.clear();
        return false;
      }
      if (budget.totalFunds < this._applicationCost) {
        this.result = this.TOOLRESULT_NO_MONEY;
        this.clear();
        return false;
      }
      apply.call(this, budget);
      this.clear();
      return true;
    }, "modifyIfEnoughFunding");
    const TOOLRESULT_OK = 0;
    const TOOLRESULT_FAILED = 1;
    const TOOLRESULT_NO_MONEY = 2;
    const TOOLRESULT_NEEDS_BULLDOZE = 3;
    const BaseToolConstructor = {
      addCost,
      autoBulldoze: true,
      bulldozerCost: 1,
      clear,
      doAutoBulldoze,
      init,
      modifyIfEnoughFunding,
      TOOLRESULT_OK,
      TOOLRESULT_FAILED,
      TOOLRESULT_NO_MONEY,
      TOOLRESULT_NEEDS_BULLDOZE
    };
    const BaseTool = {
      makeTool: makeTool$3,
      setAutoBulldoze: function(value) {
        BaseToolConstructor.autoBulldoze = value;
      },
      getAutoBulldoze: function() {
        return BaseToolConstructor.autoBulldoze;
      },
      save,
      load
    };
    function save(saveData) {
      saveData.autoBulldoze = BaseToolConstructor.autoBulldoze;
    }
    __name$n(save, "save");
    function load(saveData) {
      BaseTool.autoBulldoze = saveData.autoBulldoze;
    }
    __name$n(load, "load");
    function makeTool$3(toolConstructor) {
      toolConstructor.prototype = Object.create(BaseToolConstructor);
      return toolConstructor;
    }
    __name$n(makeTool$3, "makeTool");

    var __defProp$m = Object.defineProperty;
    var __name$m = (target, value) => __defProp$m(target, "name", { value, configurable: true });
    const ModalWindow = /* @__PURE__ */ __name$m(function(constructorFunction, focusID) {
      focusID = focusID ? MiscUtils.normaliseDOMid(focusID) : null;
      const newConstructor = /* @__PURE__ */ __name$m(function(opacityLayerID, windowID) {
        this._opacityLayer = MiscUtils.normaliseDOMid(opacityLayerID);
        this._windowID = MiscUtils.normaliseDOMid(windowID);
        constructorFunction.call(this);
      }, "newConstructor");
      newConstructor.prototype._toggleDisplay = function() {
        let opacityLayer = $(this._opacityLayer);
        opacityLayer = opacityLayer.length === 0 ? null : opacityLayer;
        if (opacityLayer === null) {
          throw new Error("Node " + this._opacityLayer + " not found");
        }
        let modalWindow = $(this._windowID);
        modalWindow = modalWindow.length === 0 ? null : modalWindow;
        if (modalWindow === null) {
          throw new Error("Node " + this._windowID + " not found");
        }
        opacityLayer.toggle();
        modalWindow.toggle();
        if (focusID !== null)
          $(focusID).focus();
        else
          $(this._windowID + " input[type=submit]").focus();
      };
      return EventEmitter(newConstructor);
    }, "ModalWindow");

    var __defProp$l = Object.defineProperty;
    var __name$l = (target, value) => __defProp$l(target, "name", { value, configurable: true });
    const dataKeys = [
      "roadMaintenanceBudget",
      "fireMaintenanceBudget",
      "policeMaintenanceBudget"
    ];
    const spendKeys = ["roadRate", "fireRate", "policeRate"];
    const budgetResetID = "#budgetReset";
    const budgetCancelID = "#budgetCancel";
    const budgetFormID = "#budgetForm";
    const setSpendRangeText = /* @__PURE__ */ __name$l(function(element, percentage, totalSpend) {
      const labelID = element + "Label";
      const cash = Math.floor(totalSpend * (percentage / 100));
      const text = [percentage, "% of $", totalSpend, " = $", cash].join("");
      $(MiscUtils.normaliseDOMid(labelID)).text(text);
    }, "setSpendRangeText");
    const onFundingUpdate = /* @__PURE__ */ __name$l(function(elementID, e) {
      const element = $(MiscUtils.normaliseDOMid(elementID))[0];
      const percentage = element.value - 0;
      const dataSource = element.getAttribute("data-source");
      setSpendRangeText(elementID, percentage, this[dataSource]);
    }, "onFundingUpdate");
    const onTaxUpdate = /* @__PURE__ */ __name$l(function(e) {
      const elem = $("#taxRateLabel")[0];
      const sourceElem = $("#taxRate")[0];
      $(elem).text(["Tax rate: ", sourceElem.value, "%"].join(""));
    }, "onTaxUpdate");
    const resetItems = /* @__PURE__ */ __name$l(function(e) {
      for (let i = 0; i < spendKeys.length; i++) {
        const original = this["original" + spendKeys[i]];
        $(MiscUtils.normaliseDOMid(spendKeys[i]))[0].value = original;
        setSpendRangeText(spendKeys[i], original, this[dataKeys[i]]);
      }
      $("#taxRate")[0].value = this.originaltaxRate;
      onTaxUpdate();
      e.preventDefault();
    }, "resetItems");
    const cancel$4 = /* @__PURE__ */ __name$l(function(e) {
      e.preventDefault();
      this.close({ cancelled: true });
    }, "cancel");
    const submit$9 = /* @__PURE__ */ __name$l(function(e) {
      e.preventDefault();
      const roadPercent = $("#roadRate")[0].value;
      const firePercent = $("#fireRate")[0].value;
      const policePercent = $("#policeRate")[0].value;
      const taxPercent = $("#taxRate")[0].value;
      const data = {
        cancelled: false,
        roadPercent,
        firePercent,
        policePercent,
        taxPercent,
        e,
        original: e.type
      };
      this.close(data);
    }, "submit");
    const BudgetWindow = ModalWindow(function() {
      $(budgetCancelID).on("click", cancel$4.bind(this));
      $(budgetResetID).on("click", resetItems.bind(this));
      $(budgetFormID).on("submit", submit$9.bind(this));
    });
    BudgetWindow.prototype.close = function(data) {
      data = data || { cancelled: true };
      this._emitEvent(BUDGET_WINDOW_CLOSED, data);
      this._toggleDisplay();
    };
    BudgetWindow.prototype.open = function(budgetData) {
      let i, elem;
      for (i = 0; i < dataKeys.length; i++) {
        if (budgetData[dataKeys[i]] === void 0) {
          throw new Error("Missing budget data (" + dataKeys[i] + ")");
        }
        this[dataKeys[i]] = budgetData[dataKeys[i]];
      }
      for (i = 0; i < spendKeys.length; i++) {
        if (budgetData[spendKeys[i]] === void 0) {
          throw new Error("Missing budget data (" + spendKeys[i] + ")");
        }
        elem = spendKeys[i];
        this["original" + elem] = budgetData[elem];
        setSpendRangeText(elem, budgetData[spendKeys[i]], this[dataKeys[i]]);
        elem = $(MiscUtils.normaliseDOMid(elem));
        elem.on("change", onFundingUpdate.bind(this, spendKeys[i]));
        elem = elem[0];
        elem.value = budgetData[spendKeys[i]];
      }
      if (budgetData.taxRate === void 0) {
        throw new Error("Missing budget data (taxRate)");
      }
      this.originalTaxRate = budgetData.taxRate;
      elem = $("#taxRate");
      elem.on("change", onTaxUpdate);
      elem = elem[0];
      elem.value = budgetData.taxRate;
      onTaxUpdate();
      const previousFunds = budgetData.totalFunds;
      if (previousFunds === void 0) {
        throw new Error("Missing budget data (previousFunds)");
      }
      const taxesCollected = budgetData.taxesCollected;
      if (taxesCollected === void 0) {
        throw new Error("Missing budget data (taxesCollected)");
      }
      const cashFlow = taxesCollected - this.roadMaintenanceBudget - this.fireMaintenanceBudget - this.policeMaintenanceBudget;
      const currentFunds = previousFunds + cashFlow;
      $("#taxesCollected").text("$" + taxesCollected);
      $("#cashFlow").text((cashFlow < 0 ? "-$" : "$") + cashFlow);
      $("#previousFunds").text((previousFunds < 0 ? "-$" : "$") + previousFunds);
      $("#currentFunds").text("$" + currentFunds);
      this._toggleDisplay();
    };

    var __defProp$k = Object.defineProperty;
    var __name$k = (target, value) => __defProp$k(target, "name", { value, configurable: true });
    const DebugWindow = ModalWindow(function() {
      $(debugCancelID).on("click", cancel$3.bind(this));
      $(debugFormID).on("submit", submit$8.bind(this));
    });
    var debugCancelID = "#debugCancel";
    var debugFormID = "#debugForm";
    DebugWindow.prototype.close = function(actions) {
      actions = actions || [];
      this._emitEvent(DEBUG_WINDOW_CLOSED, actions);
      this._toggleDisplay();
    };
    var cancel$3 = /* @__PURE__ */ __name$k(function(e) {
      e.preventDefault();
      this.close([]);
    }, "cancel");
    var submit$8 = /* @__PURE__ */ __name$k(function(e) {
      e.preventDefault();
      const actions = [];
      const shouldAdd = $(".debugAdd:checked").val();
      if (shouldAdd === "true") {
        actions.push({ action: DebugWindow.ADD_FUNDS, data: {} });
      }
      this.close(actions);
    }, "submit");
    DebugWindow.prototype.open = function() {
      this._toggleDisplay();
    };
    const defineAction$2 = function() {
      let uid = 0;
      return function(name) {
        Object.defineProperty(
          DebugWindow,
          name,
          MiscUtils.makeConstantDescriptor(uid)
        );
        uid += 1;
      };
    }();
    defineAction$2("ADD_FUNDS");

    var __defProp$j = Object.defineProperty;
    var __name$j = (target, value) => __defProp$j(target, "name", { value, configurable: true });
    var disasterSelectID = "#disasterSelect";
    var disasterCancelID = "#disasterCancel";
    var disasterFormID = "#disasterForm";
    var DisasterWindow = ModalWindow(function() {
      $(disasterFormID).on("submit", submit$7.bind(this));
      $(disasterCancelID).on("click", cancel$2.bind(this));
    }, disasterSelectID);
    DisasterWindow.prototype.close = function(disaster) {
      disaster = disaster || DisasterWindow.DISASTER_NONE;
      this._toggleDisplay();
      this._emitEvent(DISASTER_WINDOW_CLOSED, disaster);
    };
    var cancel$2 = /* @__PURE__ */ __name$j(function(e) {
      e.preventDefault();
      this.close();
    }, "cancel");
    var submit$7 = /* @__PURE__ */ __name$j(function(e) {
      e.preventDefault();
      var requestedDisaster = $(disasterSelectID)[0].value;
      this.close(requestedDisaster);
    }, "submit");
    DisasterWindow.prototype.open = function() {
      $("#disasterNone").attr("value", DisasterWindow.DISASTER_NONE);
      $("#disasterMonster").attr("value", DisasterWindow.DISASTER_MONSTER);
      $("#disasterFire").attr("value", DisasterWindow.DISASTER_FIRE);
      $("#disasterFlood").attr("value", DisasterWindow.DISASTER_FLOOD);
      $("#disasterCrash").attr("value", DisasterWindow.DISASTER_CRASH);
      $("#disasterMeltdown").attr("value", DisasterWindow.DISASTER_MELTDOWN);
      $("#disasterTornado").attr("value", DisasterWindow.DISASTER_TORNADO);
      this._toggleDisplay();
    };
    Object.defineProperties(DisasterWindow, {
      DISASTER_NONE: MiscUtils.makeConstantDescriptor("None"),
      DISASTER_MONSTER: MiscUtils.makeConstantDescriptor("Monster"),
      DISASTER_FIRE: MiscUtils.makeConstantDescriptor("Fire"),
      DISASTER_FLOOD: MiscUtils.makeConstantDescriptor("Flood"),
      DISASTER_CRASH: MiscUtils.makeConstantDescriptor("Crash"),
      DISASTER_MELTDOWN: MiscUtils.makeConstantDescriptor("Meltdown"),
      DISASTER_TORNADO: MiscUtils.makeConstantDescriptor("Tornado")
    });

    const densityStrings = ["Low", "Medium", "High", "Very High"];
    const landValueStrings = ["Slum", "Lower Class", "Middle Class", "High"];
    const crimeStrings = ["Safe", "Light", "Moderate", "Dangerous"];
    const pollutionStrings = ["None", "Moderate", "Heavy", "Very Heavy"];
    const rateStrings = ["Declining", "Stable", "Slow Growth", "Fast Growth"];
    const zoneTypes = [
      "Clear",
      "Water",
      "Trees",
      "Rubble",
      "Flood",
      "Radioactive Waste",
      "Fire",
      "Road",
      "Power",
      "Rail",
      "Residential",
      "Commercial",
      "Industrial",
      "Seaport",
      "Airport",
      "Coal Power",
      "Fire Department",
      "Police Department",
      "Stadium",
      "Nuclear Power",
      "Draw Bridge",
      "Radar Dish",
      "Fountain",
      "Industrial",
      "Steelers 38  Bears 3",
      "Draw Bridge",
      "Ur 238"
    ];
    const gameLevel = {};
    gameLevel["" + Simulation.LEVEL_EASY] = "Easy";
    gameLevel["" + Simulation.LEVEL_MED] = "Medium";
    gameLevel["" + Simulation.LEVEL_HARD] = "Hard";
    const cityClass = {};
    cityClass[Evaluation.CC_VILLAGE] = "VILLAGE";
    cityClass[Evaluation.CC_TOWN] = "TOWN";
    cityClass[Evaluation.CC_CITY] = "CITY";
    cityClass[Evaluation.CC_CAPITAL] = "CAPITAL";
    cityClass[Evaluation.CC_METROPOLIS] = "METROPOLIS";
    cityClass[Evaluation.CC_MEGALOPOLIS] = "MEGALOPOLIS";
    const problems = {};
    problems[Evaluation.CRIME] = "Crime";
    problems[Evaluation.POLLUTION] = "Pollution";
    problems[Evaluation.HOUSING] = "Housing";
    problems[Evaluation.TAXES] = "Taxes";
    problems[Evaluation.TRAFFIC] = "Traffic";
    problems[Evaluation.UNEMPLOYMENT] = "Unemployment";
    problems[Evaluation.FIRE] = "Fire";
    const months = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ];
    const toolMessages = {
      noMoney: "Insufficient funds to build that",
      needsDoze: "Area must be bulldozed first"
    };
    const neutralMessages = {};
    neutralMessages[FIRE_STATION_NEEDS_FUNDING] = true;
    neutralMessages[NEED_AIRPORT] = true;
    neutralMessages[NEED_FIRE_STATION] = true;
    neutralMessages[NEED_ELECTRICITY] = true;
    neutralMessages[NEED_MORE_INDUSTRIAL] = true;
    neutralMessages[NEED_MORE_COMMERCIAL] = true;
    neutralMessages[NEED_MORE_RESIDENTIAL] = true;
    neutralMessages[NEED_MORE_RAILS] = true;
    neutralMessages[NEED_MORE_ROADS] = true;
    neutralMessages[NEED_POLICE_STATION] = true;
    neutralMessages[NEED_SEAPORT] = true;
    neutralMessages[NEED_STADIUM] = true;
    neutralMessages[ROAD_NEEDS_FUNDING] = true;
    neutralMessages[POLICE_NEEDS_FUNDING] = true;
    neutralMessages[WELCOME] = true;
    const badMessages = {};
    badMessages[BLACKOUTS_REPORTED] = true;
    badMessages[EARTHQUAKE] = true;
    badMessages[EXPLOSION_REPORTED] = true;
    badMessages[FLOODING_REPORTED] = true;
    badMessages[FIRE_REPORTED] = true;
    badMessages[HEAVY_TRAFFIC] = true;
    badMessages[HELICOPTER_CRASHED] = true;
    badMessages[HIGH_CRIME] = true;
    badMessages[HIGH_POLLUTION] = true;
    badMessages[MONSTER_SIGHTED] = true;
    badMessages[NO_MONEY] = true;
    badMessages[NOT_ENOUGH_POWER] = true;
    badMessages[NUCLEAR_MELTDOWN] = true;
    badMessages[PLANE_CRASHED] = true;
    badMessages[SHIP_CRASHED] = true;
    badMessages[TAX_TOO_HIGH] = true;
    badMessages[TORNADO_SIGHTED] = true;
    badMessages[TRAFFIC_JAMS] = true;
    badMessages[TRAIN_CRASHED] = true;
    const goodMessages = {};
    goodMessages[REACHED_CAPITAL] = true;
    goodMessages[REACHED_CITY] = true;
    goodMessages[REACHED_MEGALOPOLIS] = true;
    goodMessages[REACHED_METROPOLIS] = true;
    goodMessages[REACHED_TOWN] = true;
    const messageText = {};
    messageText[FIRE_STATION_NEEDS_FUNDING] = "Fire departments need funding";
    messageText[NEED_AIRPORT] = "Commerce requires an Airport";
    messageText[NEED_FIRE_STATION] = "Citizens demand a Fire Department";
    messageText[NEED_ELECTRICITY] = "Build a Power Plant";
    messageText[NEED_MORE_INDUSTRIAL] = "More industrial zones needed";
    messageText[NEED_MORE_COMMERCIAL] = "More commercial zones needed";
    messageText[NEED_MORE_RESIDENTIAL] = "More residential zones needed";
    messageText[NEED_MORE_RAILS] = "Inadequate rail system";
    messageText[NEED_MORE_ROADS] = "More roads required";
    messageText[NEED_POLICE_STATION] = "Citizens demand a Police Department";
    messageText[NEED_SEAPORT] = "Industry requires a Sea Port";
    messageText[NEED_STADIUM] = "Residents demand a Stadium";
    messageText[ROAD_NEEDS_FUNDING] = "Roads deteriorating, due to lack of funds";
    messageText[POLICE_NEEDS_FUNDING] = "Police departments need funding";
    messageText[WELCOME] = "Welcome to micropolisJS";
    messageText[BLACKOUTS_REPORTED] = "Brownouts, build another Power Plant";
    messageText[EARTHQUAKE] = "Major earthquake reported !!";
    messageText[EXPLOSION_REPORTED] = "Explosion detected ";
    messageText[FLOODING_REPORTED] = "Flooding reported !";
    messageText[FIRE_REPORTED] = "Fire reported ";
    messageText[HEAVY_TRAFFIC] = "Heavy traffic reported";
    messageText[HELICOPTER_CRASHED] = "A helicopter crashed ";
    messageText[HIGH_CRIME] = "Crime very high";
    messageText[HIGH_POLLUTION] = "Pollution very high";
    messageText[MONSTER_SIGHTED] = "A Monster has been sighted !";
    messageText[NO_MONEY] = "YOUR CITY HAS GONE BROKE";
    messageText[NOT_ENOUGH_POWER] = "Blackouts reported: insufficient power capacity";
    messageText[NUCLEAR_MELTDOWN] = "A Nuclear Meltdown has occurred !!";
    messageText[PLANE_CRASHED] = "A plane has crashed ";
    messageText[SHIP_CRASHED] = "Shipwreck reported ";
    messageText[TAX_TOO_HIGH] = "Citizens upset. The tax rate is too high";
    messageText[TORNADO_SIGHTED] = "Tornado reported !";
    messageText[TRAFFIC_JAMS] = "Frequent traffic jams reported";
    messageText[TRAIN_CRASHED] = "A train crashed ";
    messageText[REACHED_CAPITAL] = "Population has reached 50,000";
    messageText[REACHED_CITY] = "Population has reached 10,000";
    messageText[REACHED_MEGALOPOLIS] = "Population has reached 500,000";
    messageText[REACHED_METROPOLIS] = "Population has reached 100,000";
    messageText[REACHED_TOWN] = "Population has reached 2,000";
    const Text = {
      badMessages,
      cityClass,
      crimeStrings,
      densityStrings,
      gameLevel,
      goodMessages,
      landValueStrings,
      messageText,
      months,
      neutralMessages,
      problems,
      pollutionStrings,
      rateStrings,
      toolMessages,
      zoneTypes
    };

    var __defProp$i = Object.defineProperty;
    var __name$i = (target, value) => __defProp$i(target, "name", { value, configurable: true });
    const evaluationFormID = "#evalButtons";
    const submit$6 = /* @__PURE__ */ __name$i(function(e) {
      e.preventDefault();
      this.close();
    }, "submit");
    const EvaluationWindow = ModalWindow(function() {
      $(evaluationFormID).on("submit", submit$6.bind(this));
    });
    EvaluationWindow.prototype.close = function() {
      this._emitEvent(EVAL_WINDOW_CLOSED);
      this._toggleDisplay();
    };
    EvaluationWindow.prototype._populateWindow = function(evaluation) {
      $("#evalYes").text(evaluation.cityYes);
      $("#evalNo").text(100 - evaluation.cityYes);
      for (let i = 0; i < 4; i++) {
        const problemNo = evaluation.getProblemNumber(i);
        if (problemNo !== null) {
          const text = Text.problems[problemNo];
          $("#evalProb" + (i + 1)).text(text);
          $("#evalProb" + (i + 1)).show();
        } else {
          $("#evalProb" + (i + 1)).hide();
        }
      }
      $("#evalPopulation").text(evaluation.cityPop);
      $("#evalMigration").text(evaluation.cityPopDelta);
      $("#evalValue").text(evaluation.cityAssessedValue);
      $("#evalLevel").text(Text.gameLevel[evaluation.gameLevel]);
      $("#evalClass").text(Text.cityClass[evaluation.cityClass]);
      $("#evalScore").text(evaluation.cityScore);
      $("#evalScoreDelta").text(evaluation.cityScoreDelta);
    };
    EvaluationWindow.prototype.open = function(evaluation) {
      this._populateWindow(evaluation);
      this._toggleDisplay();
    };

    var __defProp$h = Object.defineProperty;
    var __name$h = (target, value) => __defProp$h(target, "name", { value, configurable: true });
    function TileHistory() {
      this.clear();
    }
    __name$h(TileHistory, "TileHistory");
    const toKey = /* @__PURE__ */ __name$h(function(x, y) {
      return [x, y].join(",");
    }, "toKey");
    TileHistory.prototype.clear = function() {
      this.data = {};
    };
    TileHistory.prototype.getTile = function(x, y) {
      const key = toKey(x, y);
      return this.data[key];
    };
    TileHistory.prototype.setTile = function(x, y, value) {
      const key = toKey(x, y);
      this.data[key] = value;
    };

    var __defProp$g = Object.defineProperty;
    var __name$g = (target, value) => __defProp$g(target, "name", { value, configurable: true });
    class AnimationManager {
      constructor(map, animationPeriod, blinkPeriod) {
        animationPeriod = animationPeriod || 220;
        blinkPeriod = blinkPeriod || 600;
        this._map = map;
        this.animationPeriod = animationPeriod;
        this.lastAnimation = new Date(1970, 1, 1);
        this.lastBlink = new Date(1970, 1, 1);
        this.blinkPeriod = blinkPeriod;
        this.shouldBlink = false;
        this._lastPainted = null;
        this._currentPainted = null;
        this._data = [];
        this.initArray();
        this.registerAnimations();
      }
      initArray() {
        for (let i = 0; i < TILE_COUNT; i++)
          this._data[i] = i;
      }
      inSequence(tileValue, lastValue) {
        const seen = [tileValue];
        let current = this._data[tileValue];
        while (seen.indexOf(current) === -1) {
          if (current === lastValue)
            return true;
          seen.push(current);
          current = this._data[current];
        }
        return false;
      }
      getTiles(tileValues, offsetX, offsetY, xBound, yBound, isPaused) {
        isPaused = isPaused || false;
        let shouldChangeAnimation = false;
        const d = new Date();
        let shouldBlink = this.shouldBlink;
        if (d - this.lastBlink > this.blinkPeriod) {
          shouldBlink = this.shouldBlink = !this.shouldBlink;
          this.lastBlink = d;
        }
        if (!isPaused) {
          if (d - this.lastAnimation > this.animationPeriod) {
            shouldChangeAnimation = true;
            this.lastAnimation = d;
          }
        }
        const newPainted = this._currentPainted === null ? new TileHistory() : this._currentPainted;
        for (let y = 0; y < yBound; y++) {
          for (let x = 0; x < xBound; x++) {
            const mapX = x + offsetX;
            const mapY = y + offsetY;
            const index = y * xBound + x;
            if (mapX < 0 || mapX >= this._map.width || mapY < 0 || mapY >= this._map.height) {
              continue;
            }
            const tile = tileValues[index];
            if (tile === TILE_INVALID)
              continue;
            if (shouldBlink && tile & ZONEBIT && !(tile & POWERBIT)) {
              tileValues[index] = LIGHTNINGBOLT;
              continue;
            }
            if (!(tile & ANIMBIT)) {
              tileValues[index] = tile & BIT_MASK;
              continue;
            }
            const tileValue = tile & BIT_MASK;
            let newTile = TILE_INVALID;
            var last;
            if (this._lastPainted)
              last = this._lastPainted.getTile(x, y);
            if (shouldChangeAnimation) {
              if (last && this.inSequence(tileValue, last)) {
                if (last === LASTTINYEXP) {
                  this._map.setTo(mapX, mapY, TileUtils.randomRubble());
                  newTile = this._map.getTileValue(mapX, mapY);
                } else {
                  newTile = this._data[last];
                }
              } else {
                newTile = this._data[tileValue];
              }
            } else {
              if (last && this.inSequence(tileValue, last))
                newTile = last;
            }
            if (newTile === TILE_INVALID) {
              tileValues[index] = tileValue;
              continue;
            }
            tileValues[index] = newTile;
            newPainted.setTile(x, y, newTile);
          }
        }
        const temp = this._lastPainted;
        this._lastPainted = newPainted;
        if (temp !== null)
          temp.clear();
        this._currentPainted = temp;
      }
      registerSingleAnimation(arr) {
        for (let i = 1; i < arr.length; i++)
          this._data[arr[i - 1]] = arr[i];
      }
      registerAnimations() {
        this.registerSingleAnimation([56, 57, 58, 59, 60, 61, 62, 63, 56]);
        this.registerSingleAnimation([80, 128, 112, 96, 80]);
        this.registerSingleAnimation([81, 129, 113, 97, 81]);
        this.registerSingleAnimation([82, 130, 114, 98, 82]);
        this.registerSingleAnimation([83, 131, 115, 99, 83]);
        this.registerSingleAnimation([84, 132, 116, 100, 84]);
        this.registerSingleAnimation([85, 133, 117, 101, 85]);
        this.registerSingleAnimation([86, 134, 118, 102, 86]);
        this.registerSingleAnimation([87, 135, 119, 103, 87]);
        this.registerSingleAnimation([88, 136, 120, 104, 88]);
        this.registerSingleAnimation([89, 137, 121, 105, 89]);
        this.registerSingleAnimation([90, 138, 122, 106, 90]);
        this.registerSingleAnimation([91, 139, 123, 107, 91]);
        this.registerSingleAnimation([92, 140, 124, 108, 92]);
        this.registerSingleAnimation([93, 141, 125, 109, 93]);
        this.registerSingleAnimation([94, 142, 126, 110, 94]);
        this.registerSingleAnimation([95, 143, 127, 111, 95]);
        this.registerSingleAnimation([144, 192, 176, 160, 144]);
        this.registerSingleAnimation([145, 193, 177, 161, 145]);
        this.registerSingleAnimation([146, 194, 178, 162, 146]);
        this.registerSingleAnimation([147, 195, 179, 163, 147]);
        this.registerSingleAnimation([148, 196, 180, 164, 148]);
        this.registerSingleAnimation([149, 197, 181, 165, 149]);
        this.registerSingleAnimation([150, 198, 182, 166, 150]);
        this.registerSingleAnimation([151, 199, 183, 167, 151]);
        this.registerSingleAnimation([152, 200, 184, 168, 152]);
        this.registerSingleAnimation([153, 201, 185, 169, 153]);
        this.registerSingleAnimation([154, 202, 186, 170, 154]);
        this.registerSingleAnimation([155, 203, 187, 171, 155]);
        this.registerSingleAnimation([156, 204, 188, 172, 156]);
        this.registerSingleAnimation([157, 205, 189, 173, 157]);
        this.registerSingleAnimation([158, 206, 190, 174, 158]);
        this.registerSingleAnimation([159, 207, 191, 175, 159]);
        this.registerSingleAnimation([
          621,
          852,
          853,
          854,
          855,
          856,
          857,
          858,
          859,
          852
        ]);
        this.registerSingleAnimation([641, 884, 885, 886, 887, 884]);
        this.registerSingleAnimation([644, 888, 889, 890, 891, 888]);
        this.registerSingleAnimation([649, 892, 893, 894, 895, 892]);
        this.registerSingleAnimation([650, 896, 897, 898, 899, 896]);
        this.registerSingleAnimation([676, 900, 901, 902, 903, 900]);
        this.registerSingleAnimation([677, 904, 905, 906, 907, 904]);
        this.registerSingleAnimation([686, 908, 909, 910, 911, 908]);
        this.registerSingleAnimation([689, 912, 913, 914, 915, 912]);
        this.registerSingleAnimation([747, 916, 917, 918, 919, 916]);
        this.registerSingleAnimation([748, 920, 921, 922, 923, 920]);
        this.registerSingleAnimation([751, 924, 925, 926, 927, 924]);
        this.registerSingleAnimation([752, 928, 929, 930, 931, 928]);
        this.registerSingleAnimation([820, 952, 953, 954, 955, 952]);
        this.registerSingleAnimation([832, 833, 834, 835, 836, 837, 838, 839, 832]);
        this.registerSingleAnimation([840, 841, 842, 843, 840]);
        this.registerSingleAnimation([844, 845, 846, 847, 848, 849, 850, 851, 844]);
        this.registerSingleAnimation([860, 861, 862, 863, 864, 865, 866, 867]);
        this.registerSingleAnimation([932, 933, 934, 935, 936, 937, 938, 939, 932]);
        this.registerSingleAnimation([940, 941, 942, 943, 944, 945, 946, 947, 940]);
      }
    }
    __name$g(AnimationManager, "AnimationManager");

    const MouseBox = {
      draw: function(c, pos, width, height, options) {
        const lineWidth = options.lineWidth || 3;
        const strokeStyle = options.colour || "yellow";
        const shouldOutline = "outline" in options && options.outline === true || false;
        let startModifier = -1;
        let endModifier = 1;
        if (!shouldOutline) {
          startModifier = 1;
          endModifier = -1;
        }
        const startX = pos.x + startModifier * lineWidth / 2;
        width = width + endModifier * lineWidth;
        const startY = pos.y + startModifier * lineWidth / 2;
        height = height + endModifier * lineWidth;
        const ctx = c.getContext("2d");
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = strokeStyle;
        ctx.strokeRect(startX, startY, width, height);
      }
    };

    var __defProp$f = Object.defineProperty;
    var __name$f = (target, value) => __defProp$f(target, "name", { value, configurable: true });
    const _GameCanvas = class {
      constructor(id, parentNode, zoomRatio = 1.4) {
        if (arguments.length < 1) {
          throw new Error("Attempt to construct a GameCanvas with no parameters");
        }
        if (parentNode === void 0) {
          parentNode = id;
          id = _GameCanvas.DEFAULT_ID;
        }
        if (typeof parentNode === "string") {
          const orig = parentNode;
          parentNode = $(MiscUtils.normaliseDOMid(parentNode));
          parentNode = parentNode.length === 0 ? null : parentNode[0];
          if (parentNode === null)
            throw new Error("Node " + orig + " not found");
        }
        this.parentNode = parentNode;
        this.zoomRatio = zoomRatio;
        this._canvas = document.createElement("canvas");
        this._canvas.id = id;
        this.ctx = this._canvas.getContext("2d");
        const rect = parentNode.getBoundingClientRect();
        this._canvas.width = rect.width;
        this._canvas.height = rect.height;
        this._canvas.style.margin = "0";
        this._canvas.style.padding = "0";
        this._canvas.style.transform = `scale(${zoomRatio})`;
        this._canvas.style.imageRendering = "pixelated";
        this._pendingTileSet = null;
        const current = document.getElementById(id);
        if (current !== null) {
          if (current.parentNode === parentNode) {
            parentNode.replaceChild(this._canvas, current);
          } else
            throw new Error("ID " + id + " already exists in document!");
        } else
          parentNode.appendChild(this._canvas);
        this.ready = false;
      }
      init(map, tileSet, spriteSheet, animationManager) {
        if (arguments.length < 3) {
          throw new Error(
            "GameCanvas constructor called with too few arguments " + [].toString.apply(arguments)
          );
        }
        if (!tileSet.isValid)
          throw new Error("TileSet not ready!");
        this._spriteSheet = spriteSheet;
        this._tileSet = tileSet;
        const w = this._tileSet.tileWidth;
        this._map = map;
        this.animationManager = animationManager || new AnimationManager(map);
        if (this._canvas.width < w || this._canvas.height < w) {
          throw new Error("Canvas too small!");
        }
        this._allowScrolling = true;
        this.reset();
        const onResize = function(e2) {
          this._pendingDimensionChange = true;
        }.bind(this);
        window.addEventListener("resize", onResize, false);
      }
      reset(map) {
        if (map)
          this._map = map;
        this._lastPaintedTiles = null;
        this._currentPaintedTiles = [];
        this._lastPaintedWidth = -1;
        this._lastPaintedHeight = -1;
        this._lastCanvasWidth = -1;
        this._lastCanvasHeight = -1;
        this._lastCanvasData = null;
        this._calculateDimensions();
        this._pendingDimensionChange = false;
        this.ready = true;
        this.centreOn(
          Math.floor(this._map.width / 2),
          Math.floor(this._map.height / 2)
        );
        this.paint(null, null);
      }
      setZoom(zoomRatio) {
        this.zoomRatio = zoomRatio;
        this._canvas.style.transform = `scale(${zoomRatio})`;
        this.reset();
      }
      zoomIn() {
        let zoomRatio = this.zoomRatio;
        if (zoomRatio >= 1.7)
          return;
        zoomRatio += 0.2;
        this.setZoom(zoomRatio);
      }
      zoomOut() {
        let zoomRatio = this.zoomRatio;
        if (zoomRatio <= 1.1)
          return;
        zoomRatio -= 0.2;
        this.setZoom(zoomRatio);
      }
      _calculateDimensions(force) {
        force = force || false;
        const canvasWidth = this.canvasWidth = this._canvas.parentNode.clientWidth;
        const canvasHeight = this.canvasHeight = this._canvas.parentNode.clientHeight;
        if (canvasHeight === this._lastCanvasHeight && canvasWidth === this._lastCanvasWidth && !force) {
          return;
        }
        this._canvas.width = canvasWidth;
        this._canvas.height = canvasHeight;
        const w = this._tileSet.tileWidth;
        this._wholeTilesInViewX = Math.floor(canvasWidth / w);
        this._wholeTilesInViewY = Math.floor(canvasHeight / w);
        this._totalTilesInViewX = Math.ceil(canvasWidth / w);
        this._totalTilesInViewY = Math.ceil(canvasHeight / w);
        if (this._allowScrolling) {
          this.minX = 0;
          this.maxX = this._map.width - 1 - Math.ceil(Math.floor(canvasWidth / w) / 2) - Math.floor(Math.floor(canvasWidth / (w * this.zoomRatio)) / 2);
          this.minY = 0;
          this.maxY = this._map.height - 1 - Math.ceil(Math.floor(canvasHeight / w) / 2) - Math.floor(Math.floor(canvasHeight / (w * this.zoomRatio)) / 2);
        } else {
          this.minX = 0;
          this.minY = 0;
          this.maxX = this._map.width - this._totalTilesInViewX;
          this.maxY = this._map.height - this._totalTilesInViewY;
        }
        this._pendingDimensionChange = true;
      }
      disallowOffMap() {
        this._allowScrolling = false;
        this._lastPaintedTiles = null;
        this._calculateDimensions(true);
      }
      moveNorth() {
        if (!this.ready)
          return;
        if (this._originY > this.minY)
          this._originY--;
      }
      moveEast() {
        if (!this.ready)
          return;
        if (this._originX < this.maxX)
          this._originX++;
      }
      moveSouth() {
        if (!this.ready)
          return;
        if (this._originY < this.maxY)
          this._originY++;
      }
      moveWest() {
        if (!this.ready)
          return;
        if (this._originX > this.minX)
          this._originX--;
      }
      moveTo(x, y) {
        if (arguments.length < 1) {
          throw new Error("GameCanvas moveTo called with no arguments");
        }
        if (!this.ready)
          return;
        if (x < this.minX || x > this.maxX || y < this.minY || y > this.maxY) {
          throw new Error("Coordinates out of bounds");
        }
        this._originX = x;
        this._originY = y;
      }
      centreOn(x, y) {
        if (arguments.length < 1) {
          throw new Error("GameCanvas centreOn called with no arguments");
        }
        if (!this.ready)
          throw new Error("Not ready!");
        if (y === void 0) {
          y = x.y;
          x = x.x;
        }
        let originX = Math.floor(x) - Math.ceil(this._wholeTilesInViewX / 2);
        let originY = Math.floor(y) - Math.ceil(this._wholeTilesInViewY / 2);
        if (originX > this.maxX)
          originX = this.maxX;
        if (originX < this.minX)
          originX = this.minX;
        if (originY > this.maxY)
          originY = this.maxY;
        if (originY < this.minY)
          originY = this.minY;
        this._originX = originX;
        this._originY = originY;
      }
      getTileOrigin() {
        const e2 = new Error("Not ready!");
        if (!this.ready)
          throw e2;
        return { x: this._originX, y: this._originY };
      }
      getMaxTile() {
        const e2 = new Error("Not ready!");
        if (!this.ready)
          throw e2;
        return {
          x: this._originX + this._totalTilesInViewX - 1,
          y: this._originY + this._totalTilesInViewY - 1
        };
      }
      canvasCoordinateToTileOffset(x, y) {
        if (arguments.length < 2) {
          throw new Error(
            "GameCanvas canvasCoordinateToTileOffset called with too few arguments " + [].toString.apply(arguments)
          );
        }
        if (!this.ready)
          throw new Error("Not ready!");
        return {
          x: Math.floor(x / this._tileSet.tileWidth / this.zoomRatio),
          y: Math.floor(y / this._tileSet.tileWidth / this.zoomRatio)
        };
      }
      canvasCoordinateToTileCoordinate(x, y) {
        if (arguments.length < 2) {
          throw new Error(
            "GameCanvas canvasCoordinateToTileCoordinate called with too few arguments " + [].toString.apply(arguments)
          );
        }
        if (!this.ready)
          throw new Error("Not ready!");
        const relativeWidth = this.canvasWidth * this.zoomRatio;
        const relativeHeight = this.canvasHeight * this.zoomRatio;
        if (x >= relativeWidth || y >= relativeHeight)
          return null;
        const tileX = this._originX + Math.floor(x / this._tileSet.tileWidth / this.zoomRatio);
        const tileY = this._originY + Math.floor(y / this._tileSet.tileWidth / this.zoomRatio);
        return {
          x: tileX,
          y: tileY
        };
      }
      canvasCoordinateToPosition(x, y) {
        if (arguments.length < 2) {
          throw new Error(
            "GameCanvas canvasCoordinateToPosition called with too few arguments " + [].toString.apply(arguments)
          );
        }
        if (!this.ready)
          throw new Error("Not ready!");
        const relativeWidth = this.canvasWidth * this.zoomRatio;
        const relativeHeight = this.canvasHeight * this.zoomRatio;
        if (x >= relativeWidth || y >= relativeHeight)
          return null;
        x = this._originX + Math.floor(x / this._tileSet.tileWidth / this.zoomRatio);
        y = this._originY + Math.floor(y / this._tileSet.tileWidth / this.zoomRatio);
        if (x < 0 || x >= this._map.width || y < 0 || y >= this._map.height) {
          return null;
        }
        return new Position(x, y);
      }
      positionToCanvasCoordinate(p) {
        if (arguments.length < 1) {
          throw new Error(
            "GameCanvas positionToCanvasCoordinate called with too few arguments " + [].toString.apply(arguments)
          );
        }
        return this.tileToCanvasCoordinate(p);
      }
      tileToCanvasCoordinate(x, y) {
        if (arguments.length < 1) {
          throw new Error(
            "GameCanvas tileToCanvasCoordinate  called with too few arguments " + [].toString.apply(arguments)
          );
        }
        if (!this.ready)
          throw new Error("Not ready!");
        if (y === void 0) {
          y = x.y;
          x = x.x;
        }
        if (x === void 0 || y === void 0 || x < this.minX || y < this.minY || x > this.maxX + this._totalTilesInViewX - 1 || y > this.maxY + this._totalTilesInViewY - 1) {
          throw e;
        }
        if (x < this._originX || x >= this._originX + this._totalTilesInViewX || y < this._originY || y >= this._originY + this._totalTilesInViewY) {
          return null;
        }
        return {
          x: (x - this._originX) * this._tileSet.tileWidth * this.zoomRatio,
          y: (y - this._originY) * this._tileSet.tileWidth * this.zoomRatio
        };
      }
      changeTileSet(tileSet) {
        if (!this.ready)
          throw new Error("Not ready!");
        if (!tileSet.isValid)
          throw new Error("new tileset not loaded");
        this._pendingTileSet = tileSet;
      }
      _screenshot(onlyVisible) {
        if (onlyVisible)
          return this._canvas.toDataURL();
        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = this._map.width * this._tileSet.tileWidth;
        tempCanvas.height = this._map.height * this._tileSet.tileWidth;
        for (let x = 0; x < this._map.width; x++) {
          for (let y = 0; y < this._map.height; y++) {
            this._paintOne(this.ctx, this._map.getTileValue(x, y), x, y);
          }
        }
        return tempCanvas.toDataURL();
      }
      screenshotMap() {
        return this._screenshot(false);
      }
      screenshotVisible() {
        return this._screenshot(true);
      }
      shoogle() {
      }
      _processSprites(ctx, spriteList) {
        const spriteDamage = [];
        const tileWidth = this._tileSet.tileWidth;
        for (let i = 0, l = spriteList.length; i < l; i++) {
          const sprite = spriteList[i];
          try {
            ctx.drawImage(
              this._spriteSheet,
              (sprite.frame - 1) * 48,
              (sprite.type - 1) * 48,
              sprite.width,
              sprite.width,
              sprite.x + sprite.xOffset - this._originX * 16,
              sprite.y + sprite.yOffset - this._originY * 16,
              sprite.width,
              sprite.width
            );
          } catch (e2) {
            console.warn(
              "Failed to draw sprite " + sprite.type + " frame " + sprite.frame + " at " + sprite.x + ", " + sprite.y
            );
            continue;
          }
          spriteDamage.push({
            x: Math.floor(
              (sprite.x + sprite.xOffset - this._originX * 16) / tileWidth
            ),
            xBound: Math.ceil(
              (sprite.x + sprite.xOffset + sprite.width - this._originX * 16) / tileWidth
            ),
            y: Math.floor(
              (sprite.y + sprite.yOffset - this._originY * 16) / tileWidth
            ),
            yBound: Math.ceil(
              (sprite.y + sprite.yOffset + sprite.height - this._originY * 16) / tileWidth
            )
          });
        }
        return spriteDamage;
      }
      _processMouse(mouse) {
        const damage = { x: 0, xBound: 0, y: 0, yBound: 0 };
        if (mouse.width === 0 || mouse.height === 0)
          return;
        let mouseX = mouse.x;
        let mouseY = mouse.y;
        const mouseWidth = mouse.width;
        const mouseHeight = mouse.height;
        const options = { colour: mouse.colour, outline: true };
        if (mouseWidth > 2)
          mouseX -= 1;
        if (mouseHeight > 2)
          mouseY -= 1;
        const offMap = this._originX + mouseX < 0 && this._originX + mouseX + mouseWidth <= 0 || this._originY + mouseY < 0 && this._originY + mouseY + mouseHeight <= 0 || this._originX + mouseX >= this._map.width || this._originY + mouseY >= this._map.height;
        if (offMap) {
          damage.x = damage.xBound = mouseX;
          damage.y = damage.yBound = mouseY;
          return damage;
        }
        const pos = {
          x: mouseX * this._tileSet.tileWidth,
          y: mouseY * this._tileSet.tileWidth
        };
        const width = mouseWidth * this._tileSet.tileWidth;
        const height = mouseHeight * this._tileSet.tileWidth;
        MouseBox.draw(this._canvas, pos, width, height, options);
        damage.x = mouseX - 1;
        damage.xBound = mouseX + mouseWidth + 2;
        damage.y = mouseY - 1;
        damage.yBound = mouseY + mouseWidth + 2;
        return damage;
      }
      _paintVoid(ctx, x, y) {
        const w = this._tileSet.tileWidth;
        ctx.fillStyle = "black";
        ctx.fillRect(x * w, y * w, w, w);
      }
      _paintOne(ctx, tileVal, x, y) {
        if (tileVal === TILE_INVALID) {
          this._paintVoid(ctx, x, y);
          return;
        }
        const src = this._tileSet[tileVal];
        try {
          ctx.drawImage(
            src,
            x * this._tileSet.tileWidth,
            y * this._tileSet.tileWidth
          );
        } catch (e2) {
          const mapX = this._originX + x;
          const mapY = this._originY + y;
          throw new Error(
            "Failed to draw tile " + tileVal + " at " + x + ", " + y + " (map " + mapX + ", " + mapY + " tile " + (this._map.testBounds(mapX, mapY) ? this._map.getTileValue(mapX, mapY) : "?? (Out of bounds)") + ")"
          );
        }
      }
      _paintTiles(ctx, paintData) {
        let x, y, index;
        const lastPaintedTiles = this._lastPaintedTiles;
        const width = this._totalTilesInViewX;
        const height = this._totalTilesInViewY;
        if (lastPaintedTiles !== null) {
          const xBound = Math.min(this._lastPaintedWidth, width);
          const yBound = Math.min(this._lastPaintedHeight, height);
          for (y = 0; y < yBound; y++) {
            for (x = 0; x < xBound; x++) {
              index = y * xBound + x;
              if (lastPaintedTiles[index] === paintData[index])
                continue;
              this._paintOne(ctx, paintData[index], x, y);
            }
          }
          if (width > this._lastPaintedWidth) {
            for (y = 0; y < height; y++) {
              for (x = this._lastPaintedWidth; x < width; x++) {
                index = y * width + x;
                this._paintOne(ctx, paintData[index], x, y);
              }
            }
          }
          if (height > this._lastPaintedHeight) {
            for (y = this._lastPaintedHeight; y < height; y++) {
              for (x = 0; x < width; x++) {
                index = y * width + x;
                this._paintOne(ctx, paintData[index], x, y);
              }
            }
          }
        } else {
          for (y = 0; y < height; y++) {
            for (x = 0; x < width; x++) {
              index = y * width + x;
              this._paintOne(ctx, paintData[index], x, y);
            }
          }
        }
        this._lastPaintedWidth = width;
        this._lastPaintedHeight = height;
        const temp = this._lastPaintedTiles;
        this._lastPaintedTiles = paintData;
        this._currentPaintedTiles = temp;
      }
      paint(mouse, sprites, isPaused) {
        let i, l, x, y, damaged, xBound, yBound, index;
        if (!this.ready) {
          return;
        }
        let lastPaintedTiles = this._lastPaintedTiles;
        if (this._pendingDimensionChange || this._pendingTileSet) {
          this._calculateDimensions();
          this._pendingDimensionChange = false;
          if (this._pendingTileSet !== null)
            this._tileSet = this._pendingTileSet;
          if (this._pendingTileSet || this.canvasWidth !== this._lastCanvasWidth || this.canvasHeight !== this._lastCanvasHeight) {
            this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
            for (y = 0, l = lastPaintedTiles !== null ? lastPaintedTiles.length : 0; y < l; y++) {
              lastPaintedTiles[y] = -2;
            }
          }
          this._pendingTileSet = null;
        }
        const paintWidth = this._totalTilesInViewX;
        const paintHeight = this._totalTilesInViewY;
        const tileValues = this._map.getTileValuesForPainting(
          this._originX,
          this._originY,
          paintWidth,
          paintHeight,
          this._currentPaintedTiles
        );
        this.animationManager.getTiles(
          tileValues,
          this._originX,
          this._originY,
          paintWidth,
          paintHeight,
          isPaused
        );
        this._paintTiles(this.ctx, tileValues);
        lastPaintedTiles = this._lastPaintedTiles;
        this._lastCanvasWidth = this.canvasWidth;
        this._lastCanvasHeight = this.canvasHeight;
        if (!mouse && !sprites) {
          return;
        }
        if (mouse) {
          damaged = this._processMouse(mouse);
          for (y = Math.max(0, damaged.y), yBound = Math.min(paintHeight, damaged.yBound); y < yBound; y++) {
            for (x = Math.max(0, damaged.x), xBound = Math.min(paintWidth, damaged.xBound); x < xBound; x++) {
              index = [y * paintWidth + x];
              lastPaintedTiles[index] = -2;
            }
          }
        }
        if (sprites) {
          damaged = this._processSprites(this.ctx, sprites);
          for (i = 0, l = damaged.length; i < l; i++) {
            const damagedArea = damaged[i];
            for (y = Math.max(0, damagedArea.y), yBound = Math.min(damagedArea.yBound, paintHeight); y < yBound; y++) {
              for (x = Math.max(0, damagedArea.x), xBound = Math.min(damagedArea.xBound, paintWidth); x < xBound; x++) {
                index = [y * paintWidth + x];
                this._lastPaintedTiles[index] = -2;
              }
            }
          }
        }
      }
    };
    let GameCanvas = _GameCanvas;
    __name$f(GameCanvas, "GameCanvas");
    GameCanvas.DEFAULT_ID = "microcity-canvas";

    var __defProp$e = Object.defineProperty;
    var __name$e = (target, value) => __defProp$e(target, "name", { value, configurable: true });
    const InfoBar = /* @__PURE__ */ __name$e(function(classification, population, score, funds, date, name) {
      const classificationSelector = MiscUtils.normaliseDOMid(classification);
      const populationSelector = MiscUtils.normaliseDOMid(population);
      const scoreSelector = MiscUtils.normaliseDOMid(score);
      const fundsSelector = MiscUtils.normaliseDOMid(funds);
      const dateSelector = MiscUtils.normaliseDOMid(date);
      const nameSelector = MiscUtils.normaliseDOMid(name);
      const $classificationSelector = $(classificationSelector);
      const $populationSelector = $(populationSelector);
      const $scoreSelector = $(scoreSelector);
      const $fundsSelector = $(fundsSelector);
      const $dateSelector = $(dateSelector);
      const $nameSelector = $(nameSelector);
      return function(dataSource, initialValues) {
        $classificationSelector.text(initialValues.classification);
        $populationSelector.text(initialValues.population);
        $scoreSelector.text(initialValues.score);
        $fundsSelector.text(initialValues.funds);
        $dateSelector.text(
          [Text.months[initialValues.date.month], initialValues.date.year].join(" ")
        );
        $nameSelector.text(initialValues.name);
        dataSource.addEventListener(
          CLASSIFICATION_UPDATED,
          function(classification2) {
            $classificationSelector.text(classification2);
          }
        );
        dataSource.addEventListener(
          POPULATION_UPDATED,
          function(population2) {
            $populationSelector.text(population2);
          }
        );
        dataSource.addEventListener(SCORE_UPDATED, function(score2) {
          $scoreSelector.text(score2);
        });
        dataSource.addEventListener(FUNDS_CHANGED, function(funds2) {
          $fundsSelector.text(funds2);
        });
        dataSource.addEventListener(DATE_UPDATED, function(date2) {
          $dateSelector.text(
            `Year ${date2.year} ${Text.months[date2.month]}`
          );
        });
      };
    }, "InfoBar");

    var __defProp$d = Object.defineProperty;
    var __name$d = (target, value) => __defProp$d(target, "name", { value, configurable: true });
    const RoadTable = [
      ROADS,
      ROADS2,
      ROADS,
      ROADS3,
      ROADS2,
      ROADS2,
      ROADS4,
      ROADS8,
      ROADS,
      ROADS6,
      ROADS,
      ROADS7,
      ROADS5,
      ROADS10,
      ROADS9,
      INTERSECTION
    ];
    const RailTable = [
      LHRAIL,
      LVRAIL,
      LHRAIL,
      LVRAIL2,
      LVRAIL,
      LVRAIL,
      LVRAIL3,
      LVRAIL7,
      LHRAIL,
      LVRAIL5,
      LHRAIL,
      LVRAIL6,
      LVRAIL4,
      LVRAIL9,
      LVRAIL8,
      LVRAIL10
    ];
    const WireTable = [
      LHPOWER,
      LVPOWER,
      LHPOWER,
      LVPOWER2,
      LVPOWER,
      LVPOWER,
      LVPOWER3,
      LVPOWER7,
      LHPOWER,
      LVPOWER5,
      LHPOWER,
      LVPOWER6,
      LVPOWER4,
      LVPOWER9,
      LVPOWER8,
      LVPOWER10
    ];
    const fixSingle = /* @__PURE__ */ __name$d(function(x, y) {
      let adjTile = 0;
      let tile = this._worldEffects.getTile(x, y);
      tile = TileUtils.normalizeRoad(tile);
      if (tile >= ROADS && tile <= INTERSECTION) {
        if (y > 0) {
          tile = this._worldEffects.getTileValue(x, y - 1);
          tile = TileUtils.normalizeRoad(tile);
          if ((tile === HRAILROAD || tile >= ROADBASE && tile <= VROADPOWER) && tile !== HROADPOWER && tile !== VRAILROAD && tile !== ROADBASE) {
            adjTile |= 1;
          }
        }
        if (x < this._map.width - 1) {
          tile = this._worldEffects.getTileValue(x + 1, y);
          tile = TileUtils.normalizeRoad(tile);
          if ((tile === VRAILROAD || tile >= ROADBASE && tile <= VROADPOWER) && tile !== VROADPOWER && tile !== HRAILROAD && tile !== VBRIDGE) {
            adjTile |= 2;
          }
        }
        if (y < this._map.height - 1) {
          tile = this._worldEffects.getTileValue(x, y + 1);
          tile = TileUtils.normalizeRoad(tile);
          if ((tile === HRAILROAD || tile >= ROADBASE && tile <= VROADPOWER) && tile !== HROADPOWER && tile !== VRAILROAD && tile !== ROADBASE) {
            adjTile |= 4;
          }
        }
        if (x > 0) {
          tile = this._worldEffects.getTileValue(x - 1, y);
          tile = TileUtils.normalizeRoad(tile);
          if ((tile === VRAILROAD || tile >= ROADBASE && tile <= VROADPOWER) && tile !== VROADPOWER && tile !== HRAILROAD && tile !== VBRIDGE) {
            adjTile |= 8;
          }
        }
        this._worldEffects.setTile(x, y, RoadTable[adjTile], BULLBIT | BURNBIT);
        return;
      }
      if (tile >= LHRAIL && tile <= LVRAIL10) {
        if (y > 0) {
          tile = this._worldEffects.getTileValue(x, y - 1);
          tile = TileUtils.normalizeRoad(tile);
          if (tile >= RAILHPOWERV && tile <= VRAILROAD && tile !== RAILHPOWERV && tile !== HRAILROAD && tile !== HRAIL) {
            adjTile |= 1;
          }
        }
        if (x < this._map.width - 1) {
          tile = this._worldEffects.getTileValue(x + 1, y);
          tile = TileUtils.normalizeRoad(tile);
          if (tile >= RAILHPOWERV && tile <= VRAILROAD && tile !== RAILVPOWERH && tile !== VRAILROAD && tile !== VRAIL) {
            adjTile |= 2;
          }
        }
        if (y < this._map.height - 1) {
          tile = this._worldEffects.getTileValue(x, y + 1);
          tile = TileUtils.normalizeRoad(tile);
          if (tile >= RAILHPOWERV && tile <= VRAILROAD && tile !== RAILHPOWERV && tile !== HRAILROAD && tile !== HRAIL) {
            adjTile |= 4;
          }
        }
        if (x > 0) {
          tile = this._worldEffects.getTileValue(x - 1, y);
          tile = TileUtils.normalizeRoad(tile);
          if (tile >= RAILHPOWERV && tile <= VRAILROAD && tile !== RAILVPOWERH && tile !== VRAILROAD && tile !== VRAIL) {
            adjTile |= 8;
          }
        }
        this._worldEffects.setTile(x, y, RailTable[adjTile], BULLBIT | BURNBIT);
        return;
      }
      if (tile >= LHPOWER && tile <= LVPOWER10) {
        if (y > 0) {
          tile = this._worldEffects.getTile(x, y - 1);
          if (tile.isConductive()) {
            tile = tile.getValue();
            tile = TileUtils.normalizeRoad(tile);
            if (tile !== VPOWER && tile !== VROADPOWER && tile !== RAILVPOWERH) {
              adjTile |= 1;
            }
          }
        }
        if (x < this._map.width - 1) {
          tile = this._worldEffects.getTile(x + 1, y);
          if (tile.isConductive()) {
            tile = tile.getValue();
            tile = TileUtils.normalizeRoad(tile);
            if (tile !== HPOWER && tile !== HROADPOWER && tile !== RAILHPOWERV) {
              adjTile |= 2;
            }
          }
        }
        if (y < this._map.height - 1) {
          tile = this._worldEffects.getTile(x, y + 1);
          if (tile.isConductive()) {
            tile = tile.getValue();
            tile = TileUtils.normalizeRoad(tile);
            if (tile !== VPOWER && tile !== VROADPOWER && tile !== RAILVPOWERH) {
              adjTile |= 4;
            }
          }
        }
        if (x > 0) {
          tile = this._worldEffects.getTile(x - 1, y);
          if (tile.isConductive()) {
            tile = tile.getValue();
            tile = TileUtils.normalizeRoad(tile);
            if (tile !== HPOWER && tile !== HROADPOWER && tile !== RAILHPOWERV) {
              adjTile |= 8;
            }
          }
        }
        this._worldEffects.setTile(x, y, WireTable[adjTile], BLBNCNBIT);
      }
    }, "fixSingle");
    const checkZoneConnections = /* @__PURE__ */ __name$d(function(x, y) {
      this.fixSingle(x, y);
      if (y > 0)
        this.fixSingle(x, y - 1);
      if (x < this._map.width - 1)
        this.fixSingle(x + 1, y);
      if (y < this._map.height - 1)
        this.fixSingle(x, y + 1);
      if (x > 0)
        this.fixSingle(x - 1, y);
    }, "checkZoneConnections");
    const checkBorder = /* @__PURE__ */ __name$d(function(x, y, size) {
      x = x - 1;
      y = y - 1;
      let i;
      for (i = 0; i < size; i++)
        this.fixZone(x + i, y - 1);
      for (i = 0; i < size; i++)
        this.fixZone(x - 1, y + i);
      for (i = 0; i < size; i++)
        this.fixZone(x + i, y + size);
      for (i = 0; i < size; i++)
        this.fixZone(x + size, y + i);
    }, "checkBorder");
    const Connector = /* @__PURE__ */ __name$d(function(toolConstructor) {
      toolConstructor.prototype.checkZoneConnections = checkZoneConnections;
      toolConstructor.prototype.fixSingle = fixSingle;
      toolConstructor.prototype.checkBorder = checkBorder;
      return toolConstructor;
    }, "Connector");

    var __defProp$c = Object.defineProperty;
    var __name$c = (target, value) => __defProp$c(target, "name", { value, configurable: true });
    const makeTool$2 = BaseTool.makeTool;
    const ConnectingTool = /* @__PURE__ */ __name$c(function(toolConstructor) {
      return Connector(makeTool$2(toolConstructor));
    }, "ConnectingTool");

    const BuildingTool = ConnectingTool(function(cost, centreTile, map, size, animated) {
      this.init(cost, map, false);
      this.centreTile = centreTile;
      this.size = size;
      this.animated = animated;
    });
    BuildingTool.prototype.putBuilding = function(leftX, topY) {
      let posX, posY, tileValue, tileFlags;
      let baseTile = this.centreTile - this.size - 1;
      for (let dy = 0; dy < this.size; dy++) {
        posY = topY + dy;
        for (let dx = 0; dx < this.size; dx++) {
          posX = leftX + dx;
          tileValue = baseTile;
          tileFlags = BNCNBIT;
          if (dx === 1) {
            if (dy === 1)
              tileFlags |= ZONEBIT;
            else if (dy === 2 && this.animated)
              tileFlags |= ANIMBIT;
          }
          this._worldEffects.setTile(posX, posY, tileValue, tileFlags);
          baseTile++;
        }
      }
    };
    BuildingTool.prototype.prepareBuildingSite = function(leftX, topY) {
      if (leftX < 0 || leftX + this.size > this._map.width) {
        return this.TOOLRESULT_FAILED;
      }
      if (topY < 0 || topY + this.size > this._map.height) {
        return this.TOOLRESULT_FAILED;
      }
      let posX, posY, tileValue;
      for (let dy = 0; dy < this.size; dy++) {
        posY = topY + dy;
        for (let dx = 0; dx < this.size; dx++) {
          posX = leftX + dx;
          tileValue = this._worldEffects.getTileValue(posX, posY);
          if (tileValue === DIRT)
            continue;
          if (!this.autoBulldoze) {
            return this.TOOLRESULT_NEEDS_BULLDOZE;
          }
          if (!TileUtils.canBulldoze(tileValue)) {
            return this.TOOLRESULT_NEEDS_BULLDOZE;
          }
          this._worldEffects.setTile(posX, posY, DIRT);
          this.addCost(this.bulldozerCost);
        }
      }
      return this.TOOLRESULT_OK;
    };
    BuildingTool.prototype.buildBuilding = function(x, y) {
      x--;
      y--;
      const prepareResult = this.prepareBuildingSite(x, y);
      if (prepareResult !== this.TOOLRESULT_OK)
        return prepareResult;
      this.addCost(this.toolCost);
      this.putBuilding(x, y);
      this.checkBorder(x, y);
      return this.TOOLRESULT_OK;
    };
    BuildingTool.prototype.doTool = function(x, y, blockMaps) {
      this.result = this.buildBuilding(x, y);
    };

    const BulldozerTool = EventEmitter(
      ConnectingTool(function(map) {
        this.init(10, map, true, true);
      })
    );
    BulldozerTool.prototype.putRubble = function(x, y, size) {
      for (let xx = x; xx < x + size; xx++) {
        for (let yy = y; yy < y + size; yy++) {
          if (this._map.testBounds(xx, yy)) {
            const tile = this._worldEffects.getTileValue(xx, yy);
            if (tile != RADTILE && tile != DIRT) {
              this._worldEffects.setTile(
                xx,
                yy,
                TINYEXP + getRandom(2),
                ANIMBIT | BULLBIT
              );
            }
          }
        }
      }
    };
    BulldozerTool.prototype.layDoze = function(x, y) {
      let tile = this._worldEffects.getTile(x, y);
      if (!tile.isBulldozable())
        return this.TOOLRESULT_FAILED;
      tile = tile.getValue();
      tile = TileUtils.normalizeRoad(tile);
      switch (tile) {
        case HBRIDGE:
        case VBRIDGE:
        case BRWV:
        case BRWH:
        case HBRDG0:
        case HBRDG1:
        case HBRDG2:
        case HBRDG3:
        case VBRDG0:
        case VBRDG1:
        case VBRDG2:
        case VBRDG3:
        case HPOWER:
        case VPOWER:
        case HRAIL:
        case VRAIL:
          this._worldEffects.setTile(x, y, RIVER);
          break;
        default:
          this._worldEffects.setTile(x, y, DIRT);
          break;
      }
      this.addCost(1);
      return this.TOOLRESULT_OK;
    };
    BulldozerTool.prototype.doTool = function(x, y, blockMaps) {
      if (!this._map.testBounds(x, y))
        this.result = this.TOOLRESULT_FAILED;
      const tile = this._worldEffects.getTile(x, y);
      const tileValue = tile.getValue();
      let zoneSize = 0;
      let deltaX;
      let deltaY;
      if (tile.isZone()) {
        zoneSize = ZoneUtils.checkZoneSize(tileValue);
        deltaX = 0;
        deltaY = 0;
      } else {
        const result = ZoneUtils.checkBigZone(tileValue);
        zoneSize = result.zoneSize;
        deltaX = result.deltaX;
        deltaY = result.deltaY;
      }
      if (zoneSize > 0) {
        this.addCost(this.bulldozerCost);
        const centerX = x + deltaX;
        const centerY = y + deltaY;
        switch (zoneSize) {
          case 3:
            this._emitEvent(SOUND_EXPLOSIONHIGH);
            this.putRubble(centerX - 1, centerY - 1, 3);
            break;
          case 4:
            this._emitEvent(SOUND_EXPLOSIONLOW);
            this.putRubble(centerX - 1, centerY - 1, 4);
            break;
          case 6:
            this._emitEvent(SOUND_EXPLOSIONHIGH);
            this._emitEvent(SOUND_EXPLOSIONLOW);
            this.putRubble(centerX - 1, centerY - 1, 6);
            break;
        }
        this.result = this.TOOLRESULT_OK;
      } else {
        let toolResult;
        if (tileValue === RIVER || tileValue === REDGE || tileValue === CHANNEL) {
          toolResult = this.layDoze(x, y);
          if (tileValue !== this._worldEffects.getTileValue(x, y))
            this.addCost(5);
        } else {
          toolResult = this.layDoze(x, y);
          this.checkZoneConnections(x, y);
        }
        this.result = toolResult;
      }
    };

    const makeTool$1 = BaseTool.makeTool;
    const ParkTool = makeTool$1(function(map) {
      this.init(10, map, true, true);
    });
    ParkTool.prototype.doTool = function(x, y, blockMaps) {
      this.doAutoBulldoze(x, y);
      if (this._worldEffects.getTileValue(x, y) !== DIRT) {
        this.result = this.TOOLRESULT_NEEDS_BULLDOZE;
        return;
      }
      const value = getRandom(4);
      let tileFlags = BURNBIT | BULLBIT;
      let tileValue;
      if (value === 4) {
        tileValue = FOUNTAIN;
        tileFlags |= ANIMBIT;
      } else {
        tileValue = value + WOODS2;
      }
      this._worldEffects.setTile(x, y, tileValue, tileFlags);
      this.addCost(10);
      this.result = this.TOOLRESULT_OK;
    };

    const RailTool = ConnectingTool(function(map) {
      this.init(20, map, true, true);
    });
    RailTool.prototype.layRail = function(x, y) {
      this.doAutoBulldoze(x, y);
      let tile = this._worldEffects.getTileValue(x, y);
      tile = TileUtils.normalizeRoad(tile);
      let cost = this.toolCost;
      switch (tile) {
        case DIRT:
          this._worldEffects.setTile(x, y, LHRAIL, BULLBIT | BURNBIT);
          break;
        case RIVER:
        case REDGE:
        case CHANNEL:
          cost = 100;
          if (x < this._map.width - 1) {
            tile = this._worldEffects.getTileValue(x + 1, y);
            tile = TileUtils.normalizeRoad(tile);
            if (tile == RAILHPOWERV || tile == HRAIL || tile >= LHRAIL && tile <= HRAILROAD) {
              this._worldEffects.setTile(x, y, HRAIL, BULLBIT);
              break;
            }
          }
          if (x > 0) {
            tile = this._worldEffects.getTileValue(x - 1, y);
            tile = TileUtils.normalizeRoad(tile);
            if (tile == RAILHPOWERV || tile == HRAIL || tile > VRAIL && tile < VRAILROAD) {
              this._worldEffects.setTile(x, y, HRAIL, BULLBIT);
              break;
            }
          }
          if (y < this._map.height - 1) {
            tile = this._worldEffects.getTileValue(x, y + 1);
            tile = TileUtils.normalizeRoad(tile);
            if (tile == RAILVPOWERH || tile == VRAILROAD || tile > HRAIL && tile < HRAILROAD) {
              this._worldEffects.setTile(x, y, VRAIL, BULLBIT);
              break;
            }
          }
          if (y > 0) {
            tile = this._worldEffects.getTileValue(x, y - 1);
            tile = TileUtils.normalizeRoad(tile);
            if (tile == RAILVPOWERH || tile == VRAILROAD || tile > HRAIL && tile < HRAILROAD) {
              this._worldEffects.setTile(x, y, VRAIL, BULLBIT);
              break;
            }
          }
          return this.TOOLRESULT_FAILED;
        case LHPOWER:
          this._worldEffects.setTile(
            x,
            y,
            RAILVPOWERH,
            CONDBIT | BURNBIT | BULLBIT
          );
          break;
        case LVPOWER:
          this._worldEffects.setTile(
            x,
            y,
            RAILHPOWERV,
            CONDBIT | BURNBIT | BULLBIT
          );
          break;
        case ROADS:
          this._worldEffects.setTile(x, y, VRAILROAD, BURNBIT | BULLBIT);
          break;
        case ROADS2:
          this._worldEffects.setTile(x, y, HRAILROAD, BURNBIT | BULLBIT);
          break;
        default:
          return this.TOOLRESULT_FAILED;
      }
      this.addCost(cost);
      this.checkZoneConnections(x, y);
      return this.TOOLRESULT_OK;
    };
    RailTool.prototype.doTool = function(x, y, blockMaps) {
      this.result = this.layRail(x, y);
    };

    const RoadTool = ConnectingTool(function(map) {
      this.init(10, map, true, true);
    });
    RoadTool.prototype.layRoad = function(x, y) {
      this.doAutoBulldoze(x, y);
      let tile = this._worldEffects.getTileValue(x, y);
      let cost = this.toolCost;
      switch (tile) {
        case DIRT:
          this._worldEffects.setTile(x, y, ROADS, BULLBIT | BURNBIT);
          break;
        case RIVER:
        case REDGE:
        case CHANNEL:
          cost = 50;
          if (x < this._map.width - 1) {
            tile = this._worldEffects.getTileValue(x + 1, y);
            tile = TileUtils.normalizeRoad(tile);
            if (tile === VRAILROAD || tile === HBRIDGE || tile >= ROADS && tile <= HROADPOWER) {
              this._worldEffects.setTile(x, y, HBRIDGE, BULLBIT);
              break;
            }
          }
          if (x > 0) {
            tile = this._worldEffects.getTileValue(x - 1, y);
            tile = TileUtils.normalizeRoad(tile);
            if (tile === VRAILROAD || tile === HBRIDGE || tile >= ROADS && tile <= INTERSECTION) {
              this._worldEffects.setTile(x, y, HBRIDGE, BULLBIT);
              break;
            }
          }
          if (y < this._map.height - 1) {
            tile = this._worldEffects.getTileValue(x, y + 1);
            tile = TileUtils.normalizeRoad(tile);
            if (tile === HRAILROAD || tile === VROADPOWER || tile >= VBRIDGE && tile <= INTERSECTION) {
              this._worldEffects.setTile(x, y, VBRIDGE, BULLBIT);
              break;
            }
          }
          if (y > 0) {
            tile = this._worldEffects.getTileValue(x, y - 1);
            tile = TileUtils.normalizeRoad(tile);
            if (tile === HRAILROAD || tile === VROADPOWER || tile >= VBRIDGE && tile <= INTERSECTION) {
              this._worldEffects.setTile(x, y, VBRIDGE, BULLBIT);
              break;
            }
          }
          return this.TOOLRESULT_FAILED;
        case LHPOWER:
          this._worldEffects.setTile(
            x,
            y,
            VROADPOWER,
            CONDBIT | BURNBIT | BULLBIT
          );
          break;
        case LVPOWER:
          this._worldEffects.setTile(
            x,
            y,
            HROADPOWER,
            CONDBIT | BURNBIT | BULLBIT
          );
          break;
        case LHRAIL:
          this._worldEffects.setTile(x, y, HRAILROAD, BURNBIT | BULLBIT);
          break;
        case LVRAIL:
          this._worldEffects.setTile(x, y, VRAILROAD, BURNBIT | BULLBIT);
          break;
        default:
          return this.TOOLRESULT_FAILED;
      }
      this.addCost(cost);
      this.checkZoneConnections(x, y);
      return this.TOOLRESULT_OK;
    };
    RoadTool.prototype.doTool = function(x, y, blockMaps) {
      this.result = this.layRoad(x, y);
    };

    const makeTool = BaseTool.makeTool;
    const QueryTool = EventEmitter(
      makeTool(function(map) {
        this.init(0, map, false, false);
      })
    );
    QueryTool.prototype.classifyPopulationDensity = function(x, y, blockMaps) {
      let density = blockMaps.populationDensityMap.worldGet(x, y);
      density = density >> 6;
      density = density & 3;
      $("#queryDensity").text(Text.densityStrings[density]);
    };
    QueryTool.prototype.classifyLandValue = function(x, y, blockMaps) {
      const landValue = blockMaps.landValueMap.worldGet(x, y);
      let i = 0;
      if (landValue >= 150)
        i = 3;
      else if (landValue >= 80)
        i = 2;
      else if (landValue >= 30)
        i = 1;
      const text = Text.landValueStrings[i];
      $("#queryLandValue").text(text);
    };
    QueryTool.prototype.classifyCrime = function(x, y, blockMaps) {
      let crime = blockMaps.crimeRateMap.worldGet(x, y);
      crime = crime >> 6;
      crime = crime & 3;
      $("#queryCrime").text(Text.crimeStrings[crime]);
    };
    QueryTool.prototype.classifyPollution = function(x, y, blockMaps) {
      let pollution = blockMaps.pollutionDensityMap.worldGet(x, y);
      pollution = pollution >> 6;
      pollution = pollution & 3;
      $("#queryPollution").text(Text.pollutionStrings[pollution]);
    };
    QueryTool.prototype.classifyRateOfGrowth = function(x, y, blockMaps) {
      let rate = blockMaps.rateOfGrowthMap.worldGet(x, y);
      rate = rate >> 6;
      rate = rate & 3;
      $("#queryRate").text(Text.rateStrings[rate]);
    };
    QueryTool.prototype.classifyDebug = function(x, y, blockMaps) {
      return;
    };
    QueryTool.prototype.classifyZone = function(x, y) {
      const baseTiles = [
        DIRT,
        RIVER,
        TREEBASE,
        RUBBLE,
        FLOOD,
        RADTILE,
        FIRE,
        ROADBASE,
        POWERBASE,
        RAILBASE,
        RESBASE,
        COMBASE,
        INDBASE,
        PORTBASE,
        AIRPORTBASE,
        COALBASE,
        FIRESTBASE,
        POLICESTBASE,
        STADIUMBASE,
        NUCLEARBASE,
        HBRDG0,
        RADAR0,
        FOUNTAIN,
        INDBASE2,
        FOOTBALLGAME1,
        VBRDG0,
        952
      ];
      let tileValue = this._map.getTileValue(x, y);
      if (tileValue >= COALSMOKE1 && tileValue < FOOTBALLGAME1) {
        tileValue = COALBASE;
      }
      let index, l;
      for (index = 0, l = baseTiles.length - 1; index < l; index++) {
        if (tileValue < baseTiles[index + 1])
          break;
      }
      $("#queryZoneType").text(Text.zoneTypes[index]);
    };
    QueryTool.prototype.doTool = function(x, y, blockMaps) {
      let text = "Position (" + x + ", " + y + ")";
      text += " TileValue: " + this._map.getTileValue(x, y);
      this.classifyZone(x, y);
      this.classifyPopulationDensity(x, y, blockMaps);
      this.classifyLandValue(x, y, blockMaps);
      this.classifyCrime(x, y, blockMaps);
      this.classifyPollution(x, y, blockMaps);
      this.classifyRateOfGrowth(x, y, blockMaps);
      this.classifyDebug(x, y, blockMaps);
      this._emitEvent(QUERY_WINDOW_NEEDED);
      this.result = this.TOOLRESULT_OK;
    };

    const WireTool = ConnectingTool(function(map) {
      this.init(5, map, true, true);
    });
    WireTool.prototype.layWire = function(x, y) {
      this.doAutoBulldoze(x, y);
      let cost = this.toolCost;
      let tile = this._worldEffects.getTileValue(x, y);
      tile = TileUtils.normalizeRoad(tile);
      switch (tile) {
        case DIRT:
          this._worldEffects.setTile(
            x,
            y,
            LHPOWER,
            CONDBIT | BURNBIT | BULLBIT
          );
          break;
        case RIVER:
        case REDGE:
        case CHANNEL:
          cost = 25;
          if (x < this._map.width - 1) {
            tile = this._worldEffects.getTile(x + 1, y);
            if (tile.isConductive()) {
              tile = tile.getValue();
              tile = TileUtils.normalizeRoad(tile);
              if (tile != HROADPOWER && tile != RAILHPOWERV && tile != HPOWER) {
                this._worldEffects.setTile(
                  x,
                  y,
                  VPOWER,
                  CONDBIT | BULLBIT
                );
                break;
              }
            }
          }
          if (x > 0) {
            tile = this._worldEffects.getTile(x - 1, y);
            if (tile.isConductive()) {
              tile = tile.getValue();
              tile = TileUtils.normalizeRoad(tile);
              if (tile != HROADPOWER && tile != RAILHPOWERV && tile != HPOWER) {
                this._worldEffects.setTile(
                  x,
                  y,
                  VPOWER,
                  CONDBIT | BULLBIT
                );
                break;
              }
            }
          }
          if (y < this._map.height - 1) {
            tile = this._worldEffects.getTile(x, y + 1);
            if (tile.isConductive()) {
              tile = tile.getValue();
              tile = TileUtils.normalizeRoad(tile);
              if (tile != VROADPOWER && tile != RAILVPOWERH && tile != VPOWER) {
                this._worldEffects.setTile(
                  x,
                  y,
                  HPOWER,
                  CONDBIT | BULLBIT
                );
                break;
              }
            }
          }
          if (y > 0) {
            tile = this._worldEffects.getTile(x, y - 1);
            if (tile.isConductive()) {
              tile = tile.getValue();
              tile = TileUtils.normalizeRoad(tile);
              if (tile != VROADPOWER && tile != RAILVPOWERH && tile != VPOWER) {
                this._worldEffects.setTile(
                  x,
                  y,
                  HPOWER,
                  CONDBIT | BULLBIT
                );
                break;
              }
            }
          }
          return this.TOOLRESULT_FAILED;
        case ROADS:
          this._worldEffects.setTile(
            x,
            y,
            HROADPOWER,
            CONDBIT | BURNBIT | BULLBIT
          );
          break;
        case ROADS2:
          this._worldEffects.setTile(
            x,
            y,
            VROADPOWER,
            CONDBIT | BURNBIT | BULLBIT
          );
          break;
        case LHRAIL:
          this._worldEffects.setTile(
            x,
            y,
            RAILHPOWERV,
            CONDBIT | BURNBIT | BULLBIT
          );
          break;
        case LVRAIL:
          this._worldEffects.setTile(
            x,
            y,
            RAILVPOWERH,
            CONDBIT | BURNBIT | BULLBIT
          );
          break;
        default:
          return this.TOOLRESULT_FAILED;
      }
      this.addCost(cost);
      this.checkZoneConnections(x, y);
      return this.TOOLRESULT_OK;
    };
    WireTool.prototype.doTool = function(x, y, blockMaps) {
      this.result = this.layWire(x, y);
    };

    var __defProp$b = Object.defineProperty;
    var __name$b = (target, value) => __defProp$b(target, "name", { value, configurable: true });
    function GameTools(map) {
      const tools = EventEmitter({
        airport: new BuildingTool(1e4, AIRPORT, map, 6, false),
        bulldozer: new BulldozerTool(map),
        coal: new BuildingTool(3e3, POWERPLANT, map, 4, false),
        commercial: new BuildingTool(100, COMCLR, map, 3, false),
        fire: new BuildingTool(500, FIRESTATION, map, 3, false),
        industrial: new BuildingTool(100, INDCLR, map, 3, false),
        nuclear: new BuildingTool(5e3, NUCLEAR, map, 4, true),
        park: new ParkTool(map),
        police: new BuildingTool(500, POLICESTATION, map, 3, false),
        port: new BuildingTool(3e3, PORT, map, 4, false),
        rail: new RailTool(map),
        residential: new BuildingTool(100, FREEZ, map, 3, false),
        road: new RoadTool(map),
        query: new QueryTool(map),
        stadium: new BuildingTool(5e3, STADIUM, map, 4, false),
        wire: new WireTool(map)
      });
      tools.query.addEventListener(
        QUERY_WINDOW_NEEDED,
        MiscUtils.reflectEvent.bind(tools, QUERY_WINDOW_NEEDED)
      );
      return tools;
    }
    __name$b(GameTools, "GameTools");

    var __defProp$a = Object.defineProperty;
    var __name$a = (target, value) => __defProp$a(target, "name", { value, configurable: true });
    const canvasID = "#" + GameCanvas.DEFAULT_ID;
    const InputStatus = EventEmitter(function(map, tileWidth) {
      this.gameTools = GameTools(map);
      this.gameTools.addEventListener(
        QUERY_WINDOW_NEEDED,
        MiscUtils.reflectEvent.bind(this, QUERY_WINDOW_NEEDED)
      );
      this.canvasID = MiscUtils.normaliseDOMid(canvasID);
      this._tileWidth = tileWidth;
      this.up = false;
      this.down = false;
      this.left = false;
      this.right = false;
      this.escape = false;
      this.mouseX = -1;
      this.mouseY = -1;
      this._dragging = false;
      this._lastdragX = -1;
      this._lastdragY = -1;
      this.toolName = null;
      this.currentTool = null;
      this.toolWidth = 0;
      this.toolColour = "";
      this.$canvas = $(this.canvasID);
      $(document).keydown(keyDownHandler.bind(this));
      $(document).keyup(keyUpHandler.bind(this));
      this.getRelativeCoordinates = getRelativeCoordinates.bind(this);
      this.$canvas.on("mouseenter", mouseEnterHandler.bind(this));
      this.$canvas.on("mouseleave", mouseLeaveHandler.bind(this));
      this.mouseDownHandler = mouseDownHandler.bind(this);
      this.mouseMoveHandler = mouseMoveHandler.bind(this);
      this.mouseUpHandler = mouseUpHandler.bind(this);
      this.canvasClickHandler = canvasClickHandler.bind(this);
      $(".toolButton").click(toolButtonHandler.bind(this));
      $("#budgetRequest").click(budgetHandler.bind(this));
      $("#evalRequest").click(evalHandler.bind(this));
      $("#disasterRequest").click(disasterHandler.bind(this));
      $("#pauseRequest").click(this.speedChangeHandler.bind(this));
      $("#screenshotRequest").click(screenshotHandler.bind(this));
      $("#settingsRequest").click(settingsHandler.bind(this));
      $("#saveRequest").click(saveHandler.bind(this));
      $("#debugRequest").click(debugHandler.bind(this));
    });
    function keyDownHandler(e) {
      let handled = false;
      switch (e.keyCode) {
        case 38:
        case 87:
          this.up = true;
          handled = true;
          break;
        case 40:
        case 83:
          this.down = true;
          handled = true;
          break;
        case 39:
        case 68:
          this.right = true;
          handled = true;
          break;
        case 37:
        case 65:
          this.left = true;
          handled = true;
          break;
        case 27:
          this.escape = true;
          handled = true;
      }
      if (handled)
        e.preventDefault();
    }
    __name$a(keyDownHandler, "keyDownHandler");
    function keyUpHandler(e) {
      switch (e.keyCode) {
        case 38:
        case 87:
          this.up = false;
          break;
        case 40:
        case 83:
          this.down = false;
          break;
        case 39:
        case 68:
          this.right = false;
          break;
        case 37:
        case 65:
          this.left = false;
          break;
        case 27:
          this.escape = false;
      }
    }
    __name$a(keyUpHandler, "keyUpHandler");
    function getRelativeCoordinates(e) {
      const cRect = document.querySelector(this.canvasID).getBoundingClientRect();
      return { x: e.clientX - cRect.left, y: e.clientY - cRect.top };
    }
    __name$a(getRelativeCoordinates, "getRelativeCoordinates");
    function mouseEnterHandler(e) {
      if (this.currentTool == null)
        return;
      this.$canvas.on("mousemove", this.mouseMoveHandler);
      if (this.currentTool.isDraggable) {
        this.$canvas.on("mousedown", this.mouseDownHandler);
      } else
        this.$canvas.on("click", this.canvasClickHandler);
    }
    __name$a(mouseEnterHandler, "mouseEnterHandler");
    function mouseDownHandler(e) {
      if (e.which !== 1 || e.shiftKey || e.altKey || e.ctrlKey || e.metaKey)
        return;
      const coords = this.getRelativeCoordinates(e);
      this.mouseX = coords.x;
      this.mouseY = coords.y;
      this._dragging = true;
      this._emitEvent(TOOL_CLICKED, { x: this.mouseX, y: this.mouseY });
      this._lastDragX = Math.floor(this.mouseX / this._tileWidth);
      this._lastDragY = Math.floor(this.mouseY / this._tileWidth);
      this.$canvas.on("mouseup", this.mouseUpHandler);
      e.preventDefault();
    }
    __name$a(mouseDownHandler, "mouseDownHandler");
    function mouseUpHandler(e) {
      this._dragging = false;
      this._lastDragX = -1;
      this._lastDragY = -1;
      this.$canvas.off("mouseup");
      e.preventDefault();
    }
    __name$a(mouseUpHandler, "mouseUpHandler");
    function mouseLeaveHandler(e) {
      this.$canvas.off("mousedown");
      this.$canvas.off("mousemove");
      this.$canvas.off("mouseup");
      if (this._dragging) {
        this._dragging = false;
        this._lastDragX = -1;
        this._lastDragY = -1;
      }
      this.$canvas.off("click");
      this.mouseX = -1;
      this.mouseY = -1;
    }
    __name$a(mouseLeaveHandler, "mouseLeaveHandler");
    function mouseMoveHandler(e) {
      const coords = this.getRelativeCoordinates(e);
      this.mouseX = coords.x;
      this.mouseY = coords.y;
      if (this._dragging) {
        const x = Math.floor(this.mouseX / this._tileWidth);
        const y = Math.floor(this.mouseY / this._tileWidth);
        const lastX = this._lastDragX;
        const lastY = this._lastDragY;
        if (x !== lastX || y !== lastY) {
          this._emitEvent(TOOL_CLICKED, { x: this.mouseX, y: this.mouseY });
          this._lastDragX = x;
          this._lastDragY = y;
        }
      }
    }
    __name$a(mouseMoveHandler, "mouseMoveHandler");
    function canvasClickHandler(e) {
      if (e.which !== 1 || e.shiftKey || e.altKey || e.ctrlKey || e.metaKey || this.mouseX === -1 || this._mouseY === -1 || this._dragging) {
        return;
      }
      this._emitEvent(TOOL_CLICKED, { x: this.mouseX, y: this.mouseY });
      e.preventDefault();
    }
    __name$a(canvasClickHandler, "canvasClickHandler");
    function toolButtonHandler(e) {
      $(".selected").each(function() {
        this.classList.remove("selected");
        this.classList.add("unselected");
      });
      let el = e.target;
      let $el = $(el);
      if (el.tagName.toLowerCase() === "img") {
        el = el.parentNode;
        $el = $(el);
      }
      $el.removeClass("unselected");
      $el.addClass("selected");
      this.toolName = $el.attr("data-tool");
      this.toolWidth = $el.attr("data-size");
      this.currentTool = this.gameTools[this.toolName];
      this.toolColour = "";
      if (this.toolName !== "query") {
        this.$canvas.removeClass("helpPointer");
        this.$canvas.addClass("pointer");
      } else {
        this.$canvas.removeClass("pointer");
        this.$canvas.addClass("helpPointer");
      }
      e.preventDefault();
    }
    __name$a(toolButtonHandler, "toolButtonHandler");
    InputStatus.prototype.speedChangeHandler = function(e) {
      const requestedSpeed = $("#pauseRequest").text();
      const newRequest = requestedSpeed === "Pause" ? "Play" : "Pause";
      $("#pauseRequest").text(newRequest);
      this._emitEvent(SPEED_CHANGE, requestedSpeed);
    };
    InputStatus.prototype.clearTool = function() {
      if (this.toolName === "query") {
        this.$canvas.removeClass("helpPointer");
        this.$canvas.addClass("pointer");
      }
      this.currentTool = null;
      this.toolWidth = 0;
      this.toolColour = "";
      $(".selected").removeClass("selected");
    };
    const makeHandler = /* @__PURE__ */ __name$a(function(message) {
      const m = Messages[message];
      return function(e) {
        this._emitEvent(m);
      };
    }, "makeHandler");
    var budgetHandler = makeHandler("BUDGET_REQUESTED");
    var debugHandler = makeHandler("DEBUG_WINDOW_REQUESTED");
    var disasterHandler = makeHandler("DISASTER_REQUESTED");
    var evalHandler = makeHandler("EVAL_REQUESTED");
    var screenshotHandler = makeHandler("SCREENSHOT_WINDOW_REQUESTED");
    var settingsHandler = makeHandler("SETTINGS_WINDOW_REQUESTED");
    var saveHandler = makeHandler("SAVE_REQUESTED");

    var __defProp$9 = Object.defineProperty;
    var __name$9 = (target, value) => __defProp$9(target, "name", { value, configurable: true });
    const TIMEOUT_SECS = 30;
    const close = /* @__PURE__ */ __name$9(function(e) {
      if (e)
        e.preventDefault();
      if (this._element.is(":visible"))
        this._element.toggle();
    }, "close");
    const handleClick = /* @__PURE__ */ __name$9(function(e) {
      e.preventDefault();
      if (this._x === -1 || this._y === -1)
        return;
      this._map.centreOn(this._x, this._y);
    }, "handleClick");
    function Notification(element, map, initialText) {
      element = MiscUtils.normaliseDOMid(element);
      this._map = map;
      this._element = $(element);
      this._timeout = null;
      this._handleClick = handleClick.bind(this);
      this._x = -1;
      this._y = -1;
      this._element.click(this._handleClick);
      this.close = close.bind(this);
      if (this._element.is(":visible"))
        this._element.toggle();
    }
    __name$9(Notification, "Notification");
    Notification.prototype._displayLink = function(text, x, y) {
      if (this._timeout !== null) {
        window.clearTimeout(this._timeout);
        this._timeout = null;
      }
      this._element.text(text);
      this._x = x;
      this._y = y;
      this._element.addClass("pointer");
      if (!this._element.is(":visible"))
        this._element.toggle();
      this._timeout = window.setTimeout(
        function() {
          this._timeout = null;
          this.close();
        }.bind(this),
        TIMEOUT_SECS * 1e3
      );
    };
    Notification.prototype._displayText = function(text, x, y) {
      if (this._timeout !== null) {
        window.clearTimeout(this._timeout);
        this._timeout = null;
      }
      this._element.removeClass("pointer");
      this._element.text(text);
      this._x = -1;
      this._y = -1;
      if (!this._element.is(":visible"))
        this._element.toggle();
      this._timeout = window.setTimeout(
        function() {
          this._timeout = null;
          this.close();
        }.bind(this),
        TIMEOUT_SECS * 1e3
      );
    };
    Notification.prototype.createMessage = function(message) {
      if (message.hasOwnProperty("data") && message.data !== void 0 && message.data.hasOwnProperty("x") && message.data.hasOwnProperty("y")) {
        this._displayLink(
          Text.messageText[message.subject],
          message.data.x,
          message.data.y
        );
        return;
      }
      this._displayText(Text.messageText[message.subject]);
    };
    Notification.prototype.badNews = function(message) {
      this._element.removeClass("neutral");
      this._element.removeClass("good");
      this._element.addClass("bad");
      this.createMessage(message);
    };
    Notification.prototype.goodNews = function(message) {
      this._element.removeClass("neutral");
      this._element.removeClass("bad");
      this._element.addClass("good");
      this.createMessage(message);
    };
    Notification.prototype.news = function(message) {
      this._element.removeClass("good");
      this._element.removeClass("bad");
      this._element.addClass("neutral");
      this.createMessage(message);
    };

    var __defProp$8 = Object.defineProperty;
    var __name$8 = (target, value) => __defProp$8(target, "name", { value, configurable: true });
    const queryFormID = "#queryForm";
    const queryOKID = "#queryOK";
    const submit$5 = /* @__PURE__ */ __name$8(function(e) {
      e.preventDefault();
      this.close();
    }, "submit");
    const QueryWindow = ModalWindow(function() {
      this._debugToggled = false;
      $(queryFormID).on("submit", submit$5.bind(this));
      this.$queryOK = $(queryOKID);
    });
    QueryWindow.prototype.close = function() {
      this._toggleDisplay();
      this._emitEvent(QUERY_WINDOW_CLOSED);
    };
    QueryWindow.prototype.open = function() {
      this._toggleDisplay();
      this.$queryOK.focus();
    };

    var __defProp$7 = Object.defineProperty;
    var __name$7 = (target, value) => __defProp$7(target, "name", { value, configurable: true });
    function RCI(parentNode, eventSource, id) {
      if (arguments.length < 2) {
        throw new Error(
          "RCI constructor called with too few arguments " + [].toString.apply(arguments)
        );
      }
      if (id === void 0)
        id = RCI.DEFAULT_ID;
      if (typeof parentNode === "string") {
        const orig = parentNode;
        parentNode = $(MiscUtils.normaliseDOMid(parentNode));
        parentNode = parentNode.length === 0 ? null : parentNode[0];
        if (parentNode === null)
          throw new Error("Node " + orig + " not found");
      }
      this._padding = 3;
      this._buckets = 10;
      this._rectSize = 5;
      this._scale = Math.floor(2e3 / this._buckets);
      this._canvas = $("<canvas></canvas>", { id })[0];
      const elems = $(MiscUtils.normaliseDOMid(id));
      const current = elems.length > 0 ? elems[0] : null;
      if (current !== null) {
        if (current.parentNode === parentNode) {
          parentNode.replaceChild(this._canvas, current);
        } else
          throw new Error("ID " + id + " already exists in document!");
      } else
        parentNode.appendChild(this._canvas);
      this._initialisedBounds = false;
      eventSource.addEventListener(VALVES_UPDATED, this.update.bind(this));
    }
    __name$7(RCI, "RCI");
    RCI.prototype._clear = function(ctx) {
      ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
    };
    RCI.prototype._drawRect = function(ctx) {
      const boxLeft = this._padding * this._rectSize;
      const boxTop = (this._buckets + this._padding) * this._rectSize;
      const boxWidth = 7 * this._padding * this._rectSize;
      const boxHeight = this._padding * this._rectSize;
      ctx.fillStyle = "rgb(192, 192, 192)";
      ctx.fillRect(boxLeft, boxTop, boxWidth, boxHeight);
    };
    RCI.prototype._drawValue = function(ctx, index, value) {
      if (index > 1)
        value = Math.floor(2e3 / 1500 * value);
      const colours = ["rgb(0,255,0)", "rgb(0, 0, 139)", "rgb(255, 255, 0)"];
      const barHeightRect = Math.floor(Math.abs(value) / this._scale);
      const barStartY = value >= 0 ? this._buckets + this._padding - barHeightRect : this._buckets + 2 * this._padding;
      const barStartX = 2 * this._padding + index * 2 * this._padding;
      ctx.fillStyle = colours[index];
      ctx.fillRect(
        barStartX * this._rectSize,
        barStartY * this._rectSize,
        this._padding * this._rectSize,
        barHeightRect * this._rectSize
      );
    };
    RCI.prototype._drawLabel = function(ctx, index) {
      const labels = ["R", "C", "I"];
      const textLeft = 2 * this._padding + index * 2 * this._padding + Math.floor(this._padding / 2);
      ctx.font = "normal xx-small sans-serif";
      ctx.fillStyle = "rgb(0, 0, 0)";
      ctx.textBaseline = "bottom";
      ctx.fillText(
        labels[index],
        textLeft * this._rectSize,
        (this._buckets + 2 * this._padding) * this._rectSize
      );
    };
    RCI.prototype.update = function(data) {
      if (!this._initialised) {
        const rect = this._canvas.parentNode.getBoundingClientRect();
        this._canvas.width = rect.width;
        this._canvas.height = rect.height;
        this._canvas.style.margin = "0";
        this._canvas.style.padding = "0";
        this._intialised = true;
      }
      const ctx = this._canvas.getContext("2d");
      this._clear(ctx);
      this._drawRect(ctx);
      const values = [data.residential, data.commercial, data.industrial];
      for (let i = 0; i < 3; i++) {
        this._drawValue(ctx, i, values[i]);
        this._drawLabel(ctx, i);
      }
    };
    Object.defineProperty(
      RCI,
      "DEFAULT_ID",
      MiscUtils.makeConstantDescriptor("RCICanvas")
    );

    var __defProp$6 = Object.defineProperty;
    var __name$6 = (target, value) => __defProp$6(target, "name", { value, configurable: true });
    const saveFormID = "#saveForm";
    const saveOKID = "#saveOK";
    const submit$4 = /* @__PURE__ */ __name$6(function(e) {
      e.preventDefault();
      this.close();
    }, "submit");
    const SaveWindow = ModalWindow(function() {
      $(saveFormID).on("submit", submit$4.bind(this));
    });
    SaveWindow.prototype.close = function() {
      this._toggleDisplay();
      this._emitEvent(SAVE_WINDOW_CLOSED);
    };
    SaveWindow.prototype.open = function() {
      this._toggleDisplay();
      $(saveOKID).focus();
    };

    var __defProp$5 = Object.defineProperty;
    var __name$5 = (target, value) => __defProp$5(target, "name", { value, configurable: true });
    const screenshotLinkFormID = "#screenshotLinkForm";
    const screenshotLinkID = "#screenshotLink";
    const submit$3 = /* @__PURE__ */ __name$5(function(e) {
      e.preventDefault();
      this.close();
    }, "submit");
    const ScreenshotLinkWindow = ModalWindow(function() {
      $(screenshotLinkFormID).on("submit", submit$3.bind(this));
    });
    ScreenshotLinkWindow.prototype.close = function() {
      this._toggleDisplay();
      this._emitEvent(SCREENSHOT_LINK_CLOSED);
    };
    ScreenshotLinkWindow.prototype.open = function(screenshotLink) {
      $(screenshotLinkID).attr("href", screenshotLink);
      this._toggleDisplay();
    };

    var __defProp$4 = Object.defineProperty;
    var __name$4 = (target, value) => __defProp$4(target, "name", { value, configurable: true });
    const ScreenshotWindow = ModalWindow(function() {
      $(screenshotCancelID).on("click", cancel$1.bind(this));
      $(screenshotFormID).on("submit", submit$2.bind(this));
    });
    var screenshotCancelID = "#screenshotCancel";
    var screenshotFormID = "#screenshotForm";
    ScreenshotWindow.prototype.close = function(action) {
      action = action || null;
      this._toggleDisplay();
      this._emitEvent(SCREENSHOT_WINDOW_CLOSED, action);
    };
    var cancel$1 = /* @__PURE__ */ __name$4(function(e) {
      e.preventDefault();
      this.close(null);
    }, "cancel");
    var submit$2 = /* @__PURE__ */ __name$4(function(e) {
      e.preventDefault();
      let action = null;
      const screenshotType = $(".screenshotType:checked").val();
      if (screenshotType === "visible")
        action = ScreenshotWindow.SCREENSHOT_VISIBLE;
      else
        action = ScreenshotWindow.SCREENSHOT_ALL;
      this.close(action);
    }, "submit");
    ScreenshotWindow.prototype.open = function(screenshotData) {
      this._toggleDisplay();
    };
    const defineAction$1 = function() {
      let uid = 1;
      return function(name) {
        Object.defineProperty(
          ScreenshotWindow,
          name,
          MiscUtils.makeConstantDescriptor(uid)
        );
        uid += 1;
      };
    }();
    defineAction$1("SCREENSHOT_VISIBLE");
    defineAction$1("SCREENSHOT_ALL");

    var __defProp$3 = Object.defineProperty;
    var __name$3 = (target, value) => __defProp$3(target, "name", { value, configurable: true });
    const settingsCancelID = "#settingsCancel";
    const settingsFormID = "#settingsForm";
    const autoBudgetYesID = "#autoBudgetYes";
    const autoBudgetNoID = "#autoBudgetNo";
    const autoBulldozeYesID = "#autoBulldozeYes";
    const autoBulldozeNoID = "#autoBulldozeNo";
    const speedSlowID = "#speedSlow";
    const speedMedID = "#speedMed";
    const speedFastID = "#speedFast";
    const disastersYesID = "#disastersYes";
    const disastersNoID = "#disastersNo";
    const cancel = /* @__PURE__ */ __name$3(function(e) {
      e.preventDefault();
      this.close([]);
    }, "cancel");
    const submit$1 = /* @__PURE__ */ __name$3(function(e) {
      e.preventDefault();
      const actions = [];
      let shouldAutoBudget = $(".autoBudgetSetting:checked").val();
      if (shouldAutoBudget === "true")
        shouldAutoBudget = true;
      else
        shouldAutoBudget = false;
      actions.push({ action: SettingsWindow.AUTOBUDGET, data: shouldAutoBudget });
      let shouldAutoBulldoze = $(".autoBulldozeSetting:checked").val();
      if (shouldAutoBulldoze === "true")
        shouldAutoBulldoze = true;
      else
        shouldAutoBulldoze = false;
      actions.push({
        action: SettingsWindow.AUTOBULLDOZE,
        data: shouldAutoBulldoze
      });
      const speed = $(".speedSetting:checked").val() - 0;
      actions.push({ action: SettingsWindow.SPEED, data: speed });
      let shouldEnableDisasters = $(".enableDisastersSetting:checked").val();
      if (shouldEnableDisasters === "true")
        shouldEnableDisasters = true;
      else
        shouldEnableDisasters = false;
      actions.push({
        action: SettingsWindow.DISASTERS_CHANGED,
        data: shouldEnableDisasters
      });
      this.close(actions);
    }, "submit");
    const SettingsWindow = ModalWindow(function() {
      $(settingsCancelID).on("click", cancel.bind(this));
      $(settingsFormID).on("submit", submit$1.bind(this));
    });
    SettingsWindow.prototype.close = function(actions) {
      actions = actions || [];
      this._emitEvent(SETTINGS_WINDOW_CLOSED, actions);
      this._toggleDisplay();
    };
    SettingsWindow.prototype.open = function(settingsData) {
      if (settingsData.autoBudget)
        $(autoBudgetYesID).prop("checked", true);
      else
        $(autoBudgetNoID).prop("checked", true);
      if (settingsData.autoBulldoze)
        $(autoBulldozeYesID).prop("checked", true);
      else
        $(autoBulldozeNoID).prop("checked", true);
      if (settingsData.speed === Simulation.SPEED_SLOW) {
        $(speedSlowID).prop("checked", true);
      } else if (settingsData.speed === Simulation.SPEED_MED) {
        $(speedMedID).prop("checked", true);
      } else
        $(speedFastID).prop("checked", true);
      if (settingsData.disasters)
        $(disastersYesID).prop("checked", true);
      else
        $(disastersNoID).prop("checked", true);
      this._toggleDisplay();
    };
    const defineAction = function() {
      let uid = 0;
      return function(name) {
        Object.defineProperty(
          SettingsWindow,
          name,
          MiscUtils.makeConstantDescriptor(uid)
        );
        uid += 1;
      };
    }();
    defineAction("AUTOBUDGET");
    defineAction("AUTOBULLDOZE");
    defineAction("SPEED");
    defineAction("DISASTERS_CHANGED");

    var __defProp$2 = Object.defineProperty;
    var __name$2 = (target, value) => __defProp$2(target, "name", { value, configurable: true });
    const touchFormID = "#touchForm";
    const touchOKID = "#touchOK";
    const submit = /* @__PURE__ */ __name$2(function(e) {
      e.preventDefault();
      this.close();
    }, "submit");
    const TouchWarnWindow = ModalWindow(function() {
      $(touchFormID).on("submit", submit.bind(this));
    });
    TouchWarnWindow.prototype.close = function() {
      this._toggleDisplay();
      this._emitEvent(TOUCH_WINDOW_CLOSED);
    };
    TouchWarnWindow.prototype.open = function() {
      this._toggleDisplay();
      $(touchOKID).focus();
    };

    var __defProp$1 = Object.defineProperty;
    var __name$1 = (target, value) => __defProp$1(target, "name", { value, configurable: true });
    let ticks = 0;
    function tick() {
      ticks++;
      this.handleInput();
      if (this.dialogOpen) {
        window.setTimeout(this.tick, 0);
        return;
      }
      if (!this.simulation.isPaused()) {
        this.simulation.simTick();
      }
      this.mouse = this.calculateMouseForPaint();
      window.setTimeout(this.tick, this.tickDuration);
    }
    __name$1(tick, "tick");
    function commonAnimate() {
      if (this.dialogShowing) {
        nextFrame(this.animate);
        return;
      }
      if (!this.isPaused && ticks % 2 === 1) {
        this.simulation.spriteManager.moveObjects(
          this.simulation._constructSimData()
        );
      }
      const sprites = this.calculateSpritesForPaint(this.gameCanvas);
      this.gameCanvas.paint(this.mouse, sprites, this.isPaused);
      nextFrame(this.animate);
    }
    __name$1(commonAnimate, "commonAnimate");
    const disasterTimeout = 20 * 1e3;
    const tileSetCache = {};
    let tileSetImage;
    const nextFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
    function makeWindowOpenHandler(winName, customFn) {
      customFn = customFn || null;
      return function() {
        console.log("Open request", this);
        if (this.dialogOpen) {
          console.warn(
            "Request made to open " + winName + " window. There is a dialog open!"
          );
          if (this._openWindow)
            console.log("Currently open", this._openWindow);
          return;
        }
        this.dialogOpen = true;
        this._openWindow = winName + "Window";
        const win = winName + "Window";
        let data = [];
        if (customFn)
          data = customFn();
        console.log("Open", this._openWindow);
        this[win].open.apply(this[win], data);
      };
    }
    __name$1(makeWindowOpenHandler, "makeWindowOpenHandler");
    class Game {
      constructor({
        map: gameMap,
        tileSet,
        snowTileSet,
        spriteSheet,
        difficulty = 0,
        name = "Microcity"
      }) {
        this.audioContext = null;
        this.audioContextReady = false;
        this.sounds = {};
        this.isPlayingSound = false;
        let savedGame;
        if (!gameMap.isSavedGame) {
          this.gameMap = gameMap;
          savedGame = null;
        } else {
          this.gameMap = new GameMap(
            gameMap.width,
            gameMap.height
          );
          savedGame = gameMap;
        }
        this.tileSet = tileSet;
        this.spriteSheet = spriteSheet;
        this.defaultSpeed = Simulation.SPEED_MED;
        this.difficulty = difficulty;
        this.simulation = new Simulation(
          this.gameMap,
          this.difficulty,
          this.defaultSpeed,
          savedGame
        );
        this.tickDuration = 30;
        this.name = name || "Microcity";
        this.everClicked = false;
        if (savedGame)
          this.loadInitial(savedGame);
        this.rci = new RCI("RCIContainer", this.simulation);
        this.gameCanvas = new GameCanvas("canvasContainer");
        this.gameCanvas.init(this.gameMap, this.tileSet, this.spriteSheet);
        this.inputStatus = new InputStatus(this.gameMap, tileSet.tileWidth);
        this.dialogOpen = false;
        this._openWindow = null;
        this.mouse = null;
        this.lastCoord = null;
        this.simNeededBudget = false;
        this.isPaused = false;
        this.lastBadMessageTime = null;
        const opacityLayerID = "opaque";
        const genericDialogClosure = /* @__PURE__ */ __name$1(() => {
          console.log("genericDialogClosure", this._openWindow);
          this.dialogOpen = false;
          this._openWindow = null;
        }, "genericDialogClosure");
        this.handleEvalRequest = makeWindowOpenHandler(
          "eval",
          function() {
            return [this.simulation.evaluation];
          }.bind(this)
        );
        this.evalWindow = new EvaluationWindow(opacityLayerID, "evalWindow");
        this.evalWindow.addEventListener(
          EVAL_WINDOW_CLOSED,
          genericDialogClosure
        );
        this.inputStatus.addEventListener(
          EVAL_REQUESTED,
          this.handleEvalRequest.bind(this)
        );
        this.handleBudgetRequest = makeWindowOpenHandler(
          "budget",
          function() {
            const budgetData = {
              roadMaintenanceBudget: this.simulation.budget.roadMaintenanceBudget,
              roadRate: Math.floor(this.simulation.budget.roadPercent * 100),
              fireMaintenanceBudget: this.simulation.budget.fireMaintenanceBudget,
              fireRate: Math.floor(this.simulation.budget.firePercent * 100),
              policeMaintenanceBudget: this.simulation.budget.policeMaintenanceBudget,
              policeRate: Math.floor(this.simulation.budget.policePercent * 100),
              taxRate: this.simulation.budget.cityTax,
              totalFunds: this.simulation.budget.totalFunds,
              taxesCollected: this.simulation.budget.taxFund
            };
            return [budgetData];
          }.bind(this)
        );
        this.budgetWindow = new BudgetWindow(opacityLayerID, "budget");
        this.budgetWindow.addEventListener(
          BUDGET_WINDOW_CLOSED,
          this.handleBudgetWindowClosure.bind(this)
        );
        this.inputStatus.addEventListener(
          BUDGET_REQUESTED,
          this.handleBudgetRequest.bind(this)
        );
        this.handleDisasterRequest = makeWindowOpenHandler("disaster");
        this.disasterWindow = new DisasterWindow(opacityLayerID, "disasterWindow");
        this.disasterWindow.addEventListener(
          DISASTER_WINDOW_CLOSED,
          this.handleDisasterWindowClosure.bind(this)
        );
        this.inputStatus.addEventListener(
          DISASTER_REQUESTED,
          this.handleDisasterRequest.bind(this)
        );
        this.handleDebugRequest = makeWindowOpenHandler("debug");
        this.debugWindow = new DebugWindow(opacityLayerID, "debugWindow");
        this.debugWindow.addEventListener(
          DEBUG_WINDOW_CLOSED,
          this.handleDebugWindowClosure.bind(this)
        );
        this.inputStatus.addEventListener(
          DEBUG_WINDOW_REQUESTED,
          this.handleDebugRequest.bind(this)
        );
        this.handleSettingsRequest = makeWindowOpenHandler(
          "settings",
          function() {
            return [
              {
                autoBudget: this.simulation.budget.autoBudget,
                autoBulldoze: BaseTool.getAutoBulldoze(),
                speed: this.defaultSpeed,
                disasters: this.simulation.disasterManager.disastersEnabled
              }
            ];
          }.bind(this)
        );
        this.settingsWindow = new SettingsWindow(opacityLayerID, "settingsWindow");
        this.settingsWindow.addEventListener(
          SETTINGS_WINDOW_CLOSED,
          this.handleSettingsWindowClosure.bind(this)
        );
        this.inputStatus.addEventListener(
          SETTINGS_WINDOW_REQUESTED,
          this.handleSettingsRequest.bind(this)
        );
        this.handleScreenshotRequest = makeWindowOpenHandler("screenshot");
        this.screenshotWindow = new ScreenshotWindow(
          opacityLayerID,
          "screenshotWindow"
        );
        this.screenshotWindow.addEventListener(
          SCREENSHOT_WINDOW_CLOSED,
          this.handleScreenshotWindowClosure.bind(this)
        );
        this.inputStatus.addEventListener(
          SCREENSHOT_WINDOW_REQUESTED,
          this.handleScreenshotRequest.bind(this)
        );
        this.screenshotLinkWindow = new ScreenshotLinkWindow(
          opacityLayerID,
          "screenshotLinkWindow"
        );
        this.screenshotLinkWindow.addEventListener(
          SCREENSHOT_LINK_CLOSED,
          genericDialogClosure
        );
        this.saveWindow = new SaveWindow(opacityLayerID, "saveWindow");
        this.saveWindow.addEventListener(
          SAVE_WINDOW_CLOSED,
          genericDialogClosure
        );
        this.touchWindow = new TouchWarnWindow(opacityLayerID, "touchWarnWindow");
        this.touchWindow.addEventListener(
          TOUCH_WINDOW_CLOSED,
          genericDialogClosure
        );
        this.handleQueryRequest = makeWindowOpenHandler("query");
        this.queryWindow = new QueryWindow(opacityLayerID, "queryWindow");
        this.queryWindow.addEventListener(
          QUERY_WINDOW_CLOSED,
          genericDialogClosure
        );
        this.inputStatus.addEventListener(
          QUERY_WINDOW_NEEDED,
          this.handleQueryRequest.bind(this)
        );
        this.inputStatus.addEventListener(
          SAVE_REQUESTED,
          this.handleSave.bind(this)
        );
        this.simulation.addEventListener(
          FRONT_END_MESSAGE,
          this.processFrontEndMessage.bind(this)
        );
        this.simulation.addEventListener(
          BUDGET_NEEDED,
          this.handleMandatoryBudget.bind(this)
        );
        this.inputStatus.addEventListener(
          TOOL_CLICKED,
          this.handleTool.bind(this)
        );
        this.inputStatus.addEventListener(
          SPEED_CHANGE,
          this.handlePause.bind(this)
        );
        this.simulation.addEventListener(
          DATE_UPDATED,
          this.onDateChange.bind(this)
        );
        this.infoBar = InfoBar(
          "cclass",
          "population",
          "score",
          "funds",
          "date",
          "name"
        );
        this.resetInfoBar();
        this._notificationBar = new Notification(
          "#notifications",
          this.gameCanvas
        );
        this._reachedTown = this._reachedCity = this._reachedCapital = this._reachedMetropolis = this._reacedMegalopolis = false;
        this._notificationBar._element.toggle();
        const $tileSelect = $("#tilesetSelect");
        if ($tileSelect.length) {
          $tileSelect == null ? void 0 : $tileSelect.on("change", (e) => {
            const name2 = e.target.value;
            this.setTileset(name2);
          });
          if ($tileSelect.val() !== "classic")
            $tileSelect.val("classic");
        }
        const $export = $("#exportButton");
        $export.on("click", () => {
          const data = {
            name: this.name,
            everClicked: this.everClicked
          };
          BaseTool.save(data);
          this.simulation.save(data);
          Storage.saveGame(data);
          console.log("Save", data);
          const a = document.createElement("a");
          a.download = "microcity.json";
          a.href = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(data));
          a.click();
        });
        const $import = $("#importButton");
        const $importFileInput = $("#importFileInput");
        $import.on("click", (e) => {
          $importFileInput.click();
        });
        $importFileInput.on("change", ({ target: { files } }) => {
          const reader = new FileReader();
          reader.onload = ({ target: { result } }) => {
            try {
              const data = JSON.parse(result);
              const map = MapGenerator(data.width, data.height);
              this.reload(map, data);
            } catch (e) {
            }
          };
          reader.onerror = (e) => console.error(e);
          reader.readAsText(files[0]);
        });
        const $newGame = $("#newGameButton");
        $newGame.on("click", () => {
          const map = MapGenerator(120, 100);
          const data = {
            name: "Microcity",
            everClicked: false,
            map
          };
          this.reload(map, data);
        });
        $("#zoomInButton").on("click", () => {
          this.gameCanvas.zoomIn();
        });
        $("#zoomOutButton").on("click", () => {
          this.gameCanvas.zoomOut();
        });
        this.tick = tick.bind(this);
        this.tick();
        this.commonAnimate = commonAnimate.bind(this);
        this.animate = (this.commonAnimate).bind(this);
        this.animate();
      }
      save() {
        const data = { name: this.name, everClicked: this.everClicked };
        BaseTool.save(data);
        this.simulation.save(data);
        Storage.saveGame(data);
      }
      loadInitial(data) {
        this.name = data.name;
        this.everClicked = data.everClicked;
        BaseTool.load(data);
        this.simulation.load(data);
        Storage.saveGame(data);
      }
      reload(map, data) {
        this.gameMap = map;
        this.simulation.reset(map);
        this.loadInitial(data);
        this.simulation.init();
        this.gameCanvas.reset(map);
        this.resetInfoBar();
      }
      resetInfoBar() {
        this.infoBar(this.simulation, {
          classification: this.simulation.evaluation.cityClass,
          population: this.simulation.evaluation.cityPop,
          score: this.simulation.evaluation.cityScore,
          funds: this.simulation.budget.totalFunds,
          date: this.simulation.getDate(),
          name: this.name
        });
      }
      revealControls() {
        $(".initialHidden").each(function(e) {
          $(this).removeClass("initialHidden");
        });
        this.rci.update({ residential: 750, commercial: 750, industrial: 750 });
      }
      setTileset(name) {
        if (tileSetCache[name]) {
          this.tileSet = tileSetCache[name];
          this.gameCanvas.changeTileSet(this.tileSet);
          return;
        }
        tileSetImage = tileSetImage || document.createElement("img");
        tileSetImage.src = `/images/tiles/${name}.png`;
        tileSetImage.onload = () => {
          this.tileSet = tileSetCache[name] = new TileSet(
            tileSetImage,
            () => this.gameCanvas.changeTileSet(this.tileSet),
            () => delete tileSetCache[name]
          );
        };
      }
      onDateChange(date) {
      }
      handleDisasterWindowClosure(request) {
        this.dialogOpen = false;
        if (request === DisasterWindow.DISASTER_NONE)
          return;
        switch (request) {
          case DisasterWindow.DISASTER_MONSTER:
            this.simulation.spriteManager.makeMonster();
            break;
          case DisasterWindow.DISASTER_FIRE:
            this.simulation.disasterManager.makeFire();
            break;
          case DisasterWindow.DISASTER_FLOOD:
            this.simulation.disasterManager.makeFlood();
            break;
          case DisasterWindow.DISASTER_CRASH:
            this.simulation.disasterManager.makeCrash();
            break;
          case DisasterWindow.DISASTER_MELTDOWN:
            this.simulation.disasterManager.makeMeltdown();
            break;
          case DisasterWindow.DISASTER_TORNADO:
            this.simulation.spriteManager.makeTornado();
        }
      }
      handleSettingsWindowClosure(actions) {
        this.dialogOpen = false;
        for (let i = 0, l = actions.length; i < l; i++) {
          const a = actions[i];
          switch (a.action) {
            case SettingsWindow.AUTOBUDGET:
              this.simulation.budget.setAutoBudget(a.data);
              break;
            case SettingsWindow.AUTOBULLDOZE:
              BaseTool.setAutoBulldoze(a.data);
              break;
            case SettingsWindow.SPEED:
              this.defaultSpeed = a.data;
              this.simulation.setSpeed(this.defaultSpeed);
              break;
            case SettingsWindow.DISASTERS_CHANGED:
              this.simulation.disasterManager.disastersEnabled = a.data;
              break;
            default:
              console.warn("Unexpected action", a);
          }
        }
      }
      handleDebugWindowClosure(actions) {
        this.dialogOpen = false;
        for (let i = 0, l = actions.length; i < l; i++) {
          const a = actions[i];
          switch (a.action) {
            case DebugWindow.ADD_FUNDS:
              this.simulation.budget.spend(-1e6);
              break;
            default:
              console.warn("Unexpected action", a);
          }
        }
      }
      handleScreenshotWindowClosure(action) {
        this.dialogOpen = false;
        if (action === null)
          return;
        let dataURI;
        if (action === ScreenshotWindow.SCREENSHOT_VISIBLE) {
          dataURI = this.gameCanvas.screenshotVisible();
        } else if (action === ScreenshotWindow.SCREENSHOT_ALL) {
          dataURI = this.gameCanvas.screenshotMap();
        }
        this.dialogOpen = true;
        this._openWindow = "screenshotLinkWindow";
        this.screenshotLinkWindow.open(dataURI);
      }
      handleBudgetWindowClosure(data) {
        this.dialogOpen = false;
        if (!data.cancelled) {
          this.simulation.budget.roadPercent = data.roadPercent / 100;
          this.simulation.budget.firePercent = data.firePercent / 100;
          this.simulation.budget.policePercent = data.policePercent / 100;
          this.simulation.budget.setTax(data.taxPercent - 0);
          if (this.simNeededBudget) {
            this.simulation.budget.doBudgetWindow();
            this.simNeededBudget = false;
          } else {
            this.simulation.budget.updateFundEffects();
          }
        }
      }
      handleMandatoryBudget() {
        this.simNeededBudget = true;
        this.handleBudgetRequest();
      }
      handleTool(data) {
        const x = data.x;
        const y = data.y;
        const tileCoords = this.gameCanvas.canvasCoordinateToTileCoordinate(x, y);
        if (tileCoords === null)
          return;
        const tool = this.inputStatus.currentTool;
        const budget = this.simulation.budget;
        this.simulation.evaluation;
        tool.doTool(tileCoords.x, tileCoords.y, this.simulation.blockMaps);
        tool.modifyIfEnoughFunding(budget);
        switch (tool.result) {
          case tool.TOOLRESULT_NEEDS_BULLDOZE:
            break;
          case tool.TOOLRESULT_NO_MONEY:
            break;
          default:
            if (!(tool instanceof QueryTool)) {
              this.makeSound("rumble", 0.4);
            }
        }
      }
      async resumeAudioContext() {
        if (this.audioContextReady)
          return;
        if (!this.audioContext)
          this.audioContext = new AudioContext();
        if (this.audioContext.state !== "playing") {
          await this.audioContext.resume();
        }
        this.audioContextReady = true;
      }
      async makeSound(name, playbackRate = 1, duration = 300) {
        if (this.isPlayingSound)
          return;
        try {
          if (!this.audioContextReady)
            await this.resumeAudioContext();
          let audioBuffer = this.sounds[name];
          if (!audioBuffer) {
            const response = await fetch(`sounds/${name}.wav`);
            const arrayBuffer = await response.arrayBuffer();
            audioBuffer = this.sounds[name] = await this.audioContext.decodeAudioData(arrayBuffer);
          }
          const sourceNode = new AudioBufferSourceNode(this.audioContext, {
            buffer: audioBuffer,
            playbackRate
          });
          sourceNode.connect(this.audioContext.destination);
          sourceNode.start(0);
          this.isPlayingSound = true;
          setTimeout(() => {
            this.isPlayingSound = false;
            sourceNode.stop();
          }, duration + 300 * Math.random());
        } catch (e) {
        }
      }
      handleSave() {
        this.save();
        this.dialogOpen = true;
        this._openWindow = "saveWindow";
        this.saveWindow.open();
      }
      handlePause() {
        this.isPaused = !this.isPaused;
        if (this.isPaused)
          this.simulation.setSpeed(Simulation.SPEED_PAUSED);
        else
          this.simulation.setSpeed(this.defaultSpeed);
      }
      handleInput() {
        if (!this.dialogOpen) {
          if (this.inputStatus.left)
            this.gameCanvas.moveWest();
          else if (this.inputStatus.up)
            this.gameCanvas.moveNorth();
          else if (this.inputStatus.right)
            this.gameCanvas.moveEast();
          else if (this.inputStatus.down)
            this.gameCanvas.moveSouth();
        }
        if (this.inputStatus.escape) {
          if (this.dialogOpen) {
            this.dialogOpen = false;
            this[this._openWindow].close();
            this._openWindow = null;
          } else
            this.inputStatus.clearTool();
        }
      }
      processFrontEndMessage(message) {
        const subject = message.subject;
        const d = new Date();
        if (Text.goodMessages[subject] !== void 0) {
          let cMessage = this.name + " is now a ";
          switch (subject) {
            case REACHED_CAPITAL:
              if (!this._reachedCapital) {
                this._reachedCapital = true;
                cMessage += "capital!";
              }
              break;
            case REACHED_CITY:
              if (!this._reachedCity) {
                this._reachedCity = true;
                cMessage += "city!";
              }
              break;
            case REACHED_MEGALOPOLIS:
              if (!this._reachedMegalopolis) {
                this._reachedMegalopolis = true;
                cMessage += "megalopolis!";
              }
              break;
            case REACHED_METROPOLIS:
              if (!this._reachedMetropolis) {
                this._reachedMetropolis = true;
                cMessage += "metropolis!";
              }
              break;
            case REACHED_TOWN:
              if (!this._reachedTown) {
                this._reachedTown = true;
                cMessage += "town!";
              }
              break;
          }
          if (this.lastBadMessageTime === null || d - this.lastBadMessageTime > disasterTimeout) {
            this.lastBadMessageTime = null;
            this._notificationBar.goodNews(message);
          }
          if (cMessage !== this.name + " is now a ") {
            console.log("Congratulations", cMessage);
          }
          return;
        }
        if (this.monsterTV && message.data) {
          if (message.data.showable) {
            this.monsterTV.show(message.data.x, message.data.y);
          } else if (message.data.trackable) {
            this.monsterTV.track(message.data.x, message.data.y, message.data.sprite);
          }
        }
        if (Text.badMessages[subject] !== void 0) {
          this._notificationBar.badNews(message);
          if (DISASTER_MESSAGES.indexOf(message.subject) !== -1) {
            this.lastBadMessageTime = d;
          }
          return;
        }
        if (Text.neutralMessages[subject] !== void 0) {
          if (this.lastBadMessageTime === null || d - this.lastBadMessageTime > disasterTimeout) {
            this.lastBadMessageTime = null;
            this._notificationBar.news(message);
          }
          return;
        }
        console.warn("Unexpected message: ", subject);
      }
      calculateMouseForPaint() {
        let mouse = null;
        if (this.inputStatus.mouseX !== -1 && this.inputStatus.toolWidth > 0) {
          const tileCoords = this.gameCanvas.canvasCoordinateToTileOffset(
            this.inputStatus.mouseX,
            this.inputStatus.mouseY
          );
          if (tileCoords !== null) {
            mouse = {};
            mouse.x = tileCoords.x;
            mouse.y = tileCoords.y;
            mouse.width = this.inputStatus.toolWidth - 0;
            mouse.height = this.inputStatus.toolWidth - 0;
            mouse.colour = this.inputStatus.toolColour || "yellow";
          }
        }
        return mouse;
      }
      calculateSpritesForPaint(canvas) {
        const origin = canvas.getTileOrigin();
        const spriteList = this.simulation.spriteManager.getSpritesInView(
          origin.x,
          origin.y,
          canvas.canvasWidth,
          canvas.canvasHeight
        );
        if (spriteList.length === 0)
          return null;
        return spriteList;
      }
    }
    __name$1(Game, "Game");

    var __defProp = Object.defineProperty;
    var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
    const tiles = document.getElementById("tiles");
    const sprites = document.getElementById("sprites");
    function createTileSet() {
      const tileSet = new TileSet(
        tiles,
        /* @__PURE__ */ __name(function onLoad() {
          function onSpritesReady() {
            createGame(tileSet, sprites);
          }
          __name(onSpritesReady, "onSpritesReady");
          if (sprites.complete) {
            onSpritesReady();
          } else {
            sprites.onload = onSpritesReady;
          }
        }, "onLoad"),
        /* @__PURE__ */ __name(function onError() {
          console.error("Failed to load tileset");
        }, "onError")
      );
    }
    __name(createTileSet, "createTileSet");
    if (tiles.complete)
      createTileSet();
    tiles.onload = createTileSet;
    function createGame(tileSet, spriteSheet) {
      const mapWidth = 120;
      const mapHeight = 100;
      let map = MapGenerator(mapWidth, mapHeight);
      let savedGame;
      if (Storage.canStore && (savedGame = Storage.getSavedGame())) {
        map = savedGame;
      }
      const game = new Game({
        map,
        tileSet,
        spriteSheet,
        difficulty: Simulation.LEVEL_EASY
      });
      setInterval(function() {
        Storage.canStore && game.save();
      }, 3e3);
    }
    __name(createGame, "createGame");

})();
//# sourceMappingURL=index.min.js.map
